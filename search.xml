<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>腾讯云集成Azure AD实现多角色SSO</title>
    <url>/2023/03/04/tencent-cloud-azure-ad-sso/</url>
    <content><![CDATA[<p>在之前的博客《利用Azure AD实现Homelab环境中应用的统一认证和授权》中，我们详细讨论了如何使用Azure AD来实现统一认证。而在《Jenkins集成Azure AD》中，我们详细介绍了自托管的Jenkins如何与Azure AD集成。</p>
<p>在本文，我将介绍腾讯云如何和Azure AD集成。</p>
<span id="more"></span>

<h2 id="第一步：在Azure中创建应用"><a href="#第一步：在Azure中创建应用" class="headerlink" title="第一步：在Azure中创建应用"></a>第一步：在Azure中创建应用</h2><h3 id="1-在企业应用中创建一个新的应用"><a href="#1-在企业应用中创建一个新的应用" class="headerlink" title="1. 在企业应用中创建一个新的应用"></a>1. 在企业应用中创建一个新的应用</h3><p>在Azure Active Directory中找到Enterprise applications(企业应用)创建一个新的应用，参考下图，在本文中将会使用Tencent Cloud SSO作为应用名称。</p>
<img src="azure-ad-01.png" width="80%">

<h3 id="2-配置SSO"><a href="#2-配置SSO" class="headerlink" title="2. 配置SSO"></a>2. 配置SSO</h3><p>完成创建之后，进入应用之后，按照下图创建基于SAML的SSO。</p>
<img src="azure-ad-02.png" width="80%">

<p>需要配置的内容下图，总共五部分<br><img src="azure-ad-03.png" width="80%"></p>
<p>我们需要配置的主要是前两个部分。</p>
<h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p>参考下图进行设置，标识符（实体 ID）和回复 URL（断言使用者服务 URL）参考下表<br><img src="azure-ad-04.png" width="80%"></p>
<table>
<thead>
<tr>
<th align="left">所在站点</th>
<th align="left">标识符（实体 ID）</th>
<th align="left">回复 URL（断言使用者服务 URL）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">中国站</td>
<td align="left">cloud.tencent.com</td>
<td align="left"><a href="https://cloud.tencent.com/login/saml">https://cloud.tencent.com/login/saml</a></td>
</tr>
<tr>
<td align="left">国际站</td>
<td align="left">intl.cloud.tencent.com</td>
<td align="left"><a href="https://intl.cloud.tencent.com/login/saml">https://intl.cloud.tencent.com/login/saml</a></td>
</tr>
</tbody></table>
<h4 id="属性和声明"><a href="#属性和声明" class="headerlink" title="属性和声明"></a>属性和声明</h4><p>在配置中，主要增加了下图中标出的两条配置。</p>
<img src="azure-ad-05.png" width="80%">

<table>
<thead>
<tr>
<th align="left">Name(名称)</th>
<th align="left">Namespace(命名空间)</th>
<th align="left">Source(来源)</th>
<th align="left">Source attribute(来源属性)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Role</td>
<td align="left"><a href="https://cloud.tencent.com/SAML/Attributes">https://cloud.tencent.com/SAML/Attributes</a></td>
<td align="left">Attribute</td>
<td align="left">user.assignedroles</td>
</tr>
<tr>
<td align="left">RoleSessionName</td>
<td align="left"><a href="https://cloud.tencent.com/SAML/Attributes">https://cloud.tencent.com/SAML/Attributes</a></td>
<td align="left">Attribute</td>
<td align="left">user.userprincipalname</td>
</tr>
</tbody></table>
<p>添加过程如下：</p>
<img src="azure-ad-06.png" width="80%">

<img src="azure-ad-07.png" width="80%">

<img src="azure-ad-08.png" width="80%">

<h4 id="下载元数据文件"><a href="#下载元数据文件" class="headerlink" title="下载元数据文件"></a>下载元数据文件</h4><p>在第三部分中下载元数据文件。<br><img src="azure-ad-09.png" width="80%"></p>
<h2 id="第二步：在腾讯云中创建角色SSO"><a href="#第二步：在腾讯云中创建角色SSO" class="headerlink" title="第二步：在腾讯云中创建角色SSO"></a>第二步：在腾讯云中创建角色SSO</h2><h3 id="1-创建角色SSO"><a href="#1-创建角色SSO" class="headerlink" title="1. 创建角色SSO"></a>1. 创建角色SSO</h3><p>在访问管理-&gt;身份提供商-&gt;角色SSO中新建一个提供商。</p>
<img src="tencent-01.png" width="80%">
参考下图创建一个新的提供商， 其中元数据文档为Azure AD中下载的元数据文件。
<img src="tencent-02.png" width="80%">

<p>打开创建完成的提供商，将登录链接保存下来。</p>
<h3 id="2-创建角色"><a href="#2-创建角色" class="headerlink" title="2. 创建角色"></a>2. 创建角色</h3><p>在访问管理-&gt;角色中新建角色，可以根据需求创建一个或者多个角色。在本文中，创建了两个角色，具备管理员权限的Administrator和只读权限的ReadOnly。</p>
<p>创建角色的过程如下：<br>点击“新建角色”后，在弹出框中选择“身份提供商”<br><img src="tencent-03.png" width="80%"><br>身份提供商类型选择SAML，身份提供商选择之前创建的身份提供商，在本文中为aad<br><img src="tencent-04.png" width="80%"><br>角色策略可以根据角色需求设置，比如现在创建的是Administrator，因此选中了AdministratorAccess<br><img src="tencent-05.png" width="80%"><br>然后下一步配置角色标签，根据需求自行添加。在审阅中设置角色名称。<br><img src="tencent-06.png" width="80%"><br>完成之后会自动跳转会角色列表，在角色列表中找到刚刚创建的角色并打开。参考下图找到两个重要信息：RoleArn和ProviderArn<br><img src="tencent-07.png" width="80%"></p>
<h2 id="第三步：在Azure-AD中添加角色"><a href="#第三步：在Azure-AD中添加角色" class="headerlink" title="第三步：在Azure AD中添加角色"></a>第三步：在Azure AD中添加角色</h2><h3 id="添加角色"><a href="#添加角色" class="headerlink" title="添加角色"></a>添加角色</h3><p>返回Azure Portal页面，在在Azure Active Directory -&gt; App registrations（应用注册）中选择All Applications，然后找到与企业应用同名的应用并打开，如下图。</p>
<img src="azure-ad-10.png" width="80%">

<p>在Manifest中修改<code>appRoles</code>, 添加新的Role如下图所示。<br><img src="azure-ad-11.png" width="80%"></p>
<p>内容可参考如下设置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;allowedMemberTypes&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;User&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Administrator&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;displayName&quot;</span>: <span class="string">&quot;[Root]Administrator&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;isEnabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;lang&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;origin&quot;</span>: <span class="string">&quot;Application&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;qcs::cam::uin/xxxxx:roleName/Administrator,qcs::cam::uin/xxxxx:saml-provider/aad&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>id是uuid，可以自行生成</li>
<li>value的格式是<code>RoleArn,ProviderArn</code></li>
</ul>
<h3 id="给AD用户-用户组分配角色"><a href="#给AD用户-用户组分配角色" class="headerlink" title="给AD用户/用户组分配角色"></a>给AD用户/用户组分配角色</h3><p>返回到创建的企业应用中，找到“用户和组”，根据需求添加用户和组即可。<br><img src="azure-ad-12.png" width="80%"></p>
<h2 id="第四步：测试"><a href="#第四步：测试" class="headerlink" title="第四步：测试"></a>第四步：测试</h2><p>打开角色SSO中的登录链接，得到如下界面。</p>
<img src="tencent-08.png" width="80%">

]]></content>
      <categories>
        <category>Cloud Computing</category>
        <category>Homelab</category>
        <category>Public Cloud Provider</category>
        <category>Azure</category>
        <category>Tencent Cloud</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
        <tag>Azure Active Directory</tag>
        <tag>Tencent Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 集成 Azure AD</title>
    <url>/2022/07/23/jenkins-deployment-and-integrate-with-aad/</url>
    <content><![CDATA[<p>在<a href="/2022/07/13/homelab-unified-authorization-authentication-1/">《利用Azure AD实现Homelab环境中应用的统一认证和授权》</a>中，我介绍了当前我是如何实现统一认证和授权。这一篇博客中，我将介绍Jenkins如何和Azure AD集成。</p>
<span id="more"></span>

<p>Jenkins等这一类的应用，我会选在部署在k8s集群上，主要原因如下：</p>
<ul>
<li>减少维护成本。比如升级Jenkins，我只需要修改helm，然后部署就行。</li>
<li>Agent可以在k8s集群中自动伸缩，不需要我再次配置。</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>为了保持环境干净，我会重新创建一个 <code>namespace</code>，并把Jenkins部署到该<code>namespace</code>之中。</p>
<p>使用如下命令创建 <code>namespace</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create ns jenkins-lab</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 我使用了命令式命令（Imperative commands）创建 <code>namespace</code>, 这种方式不推荐在生产环境使用。具体参考<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/">Kubernetes Object Management</a>.</p>
<p>推荐使用helm部署Jenkins，Jenkins官方也提供了chart。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm repo add jenkins https:&#x2F;&#x2F;charts.jenkins.io</span><br><span class="line">helm upgrade -i jenkins jenkins&#x2F;jenkins \</span><br><span class="line">  --namespace jenkins-lab \</span><br><span class="line">  --values values.yaml \</span><br><span class="line">  --timeout 10m --wait</span><br></pre></td></tr></table></figure>
<p>需要提供自定义一下<code>values</code>文件，这次部署过程中，我会使用如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">controller:</span><br><span class="line">  installLatestSpecifiedPlugins: true</span><br><span class="line">  overwritePlugins: true</span><br><span class="line">  installPlugins:</span><br><span class="line">    - kubernetes</span><br><span class="line">    - workflow-aggregator</span><br><span class="line">    - git</span><br><span class="line">    - configuration-as-code</span><br><span class="line">  additionalPlugins:</span><br><span class="line">    - azure-ad</span><br><span class="line">  ingress:</span><br><span class="line">    enabled: true</span><br><span class="line">    annotations:</span><br><span class="line">      cert-manager.io&#x2F;cluster-issuer: route53</span><br><span class="line">    hostName: jenkins-lab.xxxx.com</span><br><span class="line">    tls:</span><br><span class="line">     - hosts:</span><br><span class="line">       - jenkins-lab.xxxx.com</span><br><span class="line">       secretName: jenkins-lab-xxx-com</span><br><span class="line">  prometheus:</span><br><span class="line">    enabled: true</span><br><span class="line">  size: &quot;20Gi&quot;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，因为AAD App的reply url需要安全的通信方式，此处即Https。我配置了一个带用tls的ingress，之后会写一篇博客介绍如何自动申请SSL证书。</p>
<p>如果你需要更多的自定义配置，可以参考<a href="https://github.com/jenkinsci/helm-charts/blob/main/charts/jenkins/values.yaml">Jenkins Chart默认的values.yaml</a>。</p>
<p>到这里Jenkins部署完成，下一步注册AAD应用。</p>
<h2 id="注册Azure-AD应用"><a href="#注册Azure-AD应用" class="headerlink" title="注册Azure AD应用"></a>注册Azure AD应用</h2><p>注册Azure AD应用可以使用如下方式：</p>
<ul>
<li>通过<a href="https://aad.portal.azure.com/">Azure AD Portal</a>或者<a href="https://portal.azure.com/">Azure Portal</a>注册。</li>
<li>通过Azure CLI注册。</li>
</ul>
<p>通过web页面注册，交互比较容易，但是过程很难自动化，也没啥意思。因此我将采用CLI的方式，之后可以将其自动化。</p>
<p>注册一个名为 <code>jenkins-lab</code>的AAD应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appName&#x3D;&quot;jenkins-lab&quot;</span><br><span class="line">az ad app create --display-name $appName \</span><br><span class="line">  --sign-in-audience AzureADMyOrg \</span><br><span class="line">  --enable-access-token-issuance true \</span><br><span class="line">  --enable-id-token-issuance true \</span><br><span class="line">  --web-home-page-url https:&#x2F;&#x2F;jenkins-lab.xxxx.com \</span><br><span class="line">  --web-redirect-uris https:&#x2F;&#x2F;jenkins-lab.xxxx.com&#x2F;securityRealm&#x2F;finishLogin</span><br></pre></td></tr></table></figure>

<p><strong>此处有坑：</strong> 查询Azure CLI的官网和使用<code>azure --help</code>的结果可能有较大区别。建议直接使用 <code>--help</code>获取帮助信息。</p>
<p>因为要使用的Group进行权限管理，因此需要将<code>groupMembershipClaims</code>改为<code>SecurityGroup</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appId&#x3D;$(az ad app list --display-name $appName | jq -r -c &quot;.[0].appId&quot;)</span><br><span class="line">az ad app update --id $appId --set groupMembershipClaims&#x3D;SecurityGroup</span><br></pre></td></tr></table></figure>

<p>接下来，需要AAD应用授予<code>User.Read.All</code>, <code>Group.Read.All</code>, <code>People.Read.All</code>应用权限，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">microsoftGraphAppId&#x3D;$(az ad sp list --query &quot;[?appDisplayName&#x3D;&#x3D;&#39;Microsoft Graph&#39;].appId&quot; --all | jq -r -c &quot;.[]&quot;)</span><br><span class="line">permissions&#x3D;($(az ad sp show --id $microsoftGraphAppId | jq -r &#39;[.appRoles[] | select(.value &#x3D;&#x3D; (&quot;User.Read.All&quot;, &quot;Group.Read.All&quot;, &quot;People.Read.All&quot;)) | &quot;\(.id)&#x3D;Role&quot; ] | join(&quot; &quot;)&#39;))</span><br><span class="line">az ad app permission add --id $appId --api $microsoftGraphAppId --api-permissions $permissions</span><br><span class="line">az ad app permission admin-consent --id $appId</span><br></pre></td></tr></table></figure>

<h2 id="Jenkins集成AAD"><a href="#Jenkins集成AAD" class="headerlink" title="Jenkins集成AAD"></a>Jenkins集成AAD</h2><p>第一步： 登录Jenkins，默认用户名为<code>admin</code>，密码使用下面的命令查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl exec --namespace jenkins-lab -it svc&#x2F;jenkins -c jenkins -- &#x2F;bin&#x2F;cat &#x2F;run&#x2F;secrets&#x2F;chart-admin-password &amp;&amp; echo</span><br></pre></td></tr></table></figure>

<p>第二步： 进入<code>Manage Jenkins</code> -&gt; <code>Security</code> -&gt; <code>Configure Global Security</code></p>
<p>第三步： 执行下面的命令，获取Azure AD应用的密钥。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">az ad app credential reset --id $appId</span><br></pre></td></tr></table></figure>
<p>得到如下结果，</p>
<img src="aad-app-credential.png" width="80%">

<p>该密钥有效时长为1年</p>
<p>第四步： 配置<code>Security Realm</code> 并保存</p>
<img src="jenkins-aad-config.png" width="80%">

<p>Client ID：使用第三步返回的结果中的<code>appId</code></p>
<p>Client Secret：使用第三步返回的结果中的<code>password</code></p>
<p>Tenant: 使用第三步返回的结果中的<code>tenant</code></p>
<p>第五步： 保存之后，注销登录</p>
<p>第六步： 重新进入Jenkins，会自动跳转到Microsoft登录页面。</p>
<p>第七步： 配置权限，并保存</p>
<img src="jenkins-authorization.png" width="80%">

<p>在<code>Start typing a name</code>处，输入用户名或者组名，然后添加，授予合适的权限。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在集成的过程中仍然有大量的手动工作，之后计划使用<code>JCasC</code>改进，为什么现在不用？因为之前尝试过，没有成功。</p>
]]></content>
      <categories>
        <category>DevOps</category>
        <category>Cloud Computing</category>
        <category>Homelab</category>
        <category>Public Cloud Provider</category>
        <category>Jenkins</category>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
        <tag>Azure Active Directory</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Azure AD实现Homelab环境中应用的统一认证和授权</title>
    <url>/2022/07/13/homelab-unified-authorization-authentication-1/</url>
    <content><![CDATA[<p>在我的Homelab中搭建了很多服务，比如NAS, Jenkins, Gitlab, SonarQube, Grafana等，如果每一个应用都使用独立的认证授权，我将面对如下问题：</p>
<ul>
<li>需要设置多个密码。</li>
<li>如果设置定期更改策略，就意味着需要定期更改多个应用的用户密码。</li>
<li>当添加一个用户到我的homelab环境的时候，需要在多个应用中添加用户，过程比较繁琐。</li>
<li>当一个用户的角色发生改变时。需要在多个应用中进行更改。</li>
</ul>
<p>我采用的解决方案是：Azure AD + Windows Server AD</p>
<span id="more"></span>

<h2 id="Azure-Active-Directory"><a href="#Azure-Active-Directory" class="headerlink" title="Azure Active Directory"></a><strong><strong>Azure Active Directory</strong></strong></h2><p>Azure Active Directory，简称Azure AD或者AAD，是一种基于云的标识和访问管理服务。 此服务可帮助员工访问外部资源，例如 Microsoft 365、Azure 门户和数以千计的其他 SaaS 应用程序。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>Azure Active Directory Free。跨 Azure、Microsoft 365 和许多常用 SaaS 应用程序提供用户和组管理、本地目录同步、基本报告、云用户的自助密码更改以及单一登录。</li>
<li>Azure Active Directory Premium P1。 除了免费版功能，P1 还允许混合用户访问本地资源和云资源。 它还支持高级管理，例如动态组、自助服务组管理、Microsoft Identity Manager 以及允许本地用户进行自助密码重置的云写回功能。</li>
<li>Azure Active Directory Premium P2<strong>。</strong> 除了免费版和 P1 版功能，P2 还提供 <a href="https://docs.microsoft.com/zh-cn/azure/active-directory/identity-protection/overview-identity-protection">Azure Active Directory 标识保护</a>，可帮助对应用和重要的公司数据提供基于风险的条件访问，以及提供 <a href="https://docs.microsoft.com/zh-cn/azure/active-directory/privileged-identity-management/pim-getting-started">Privileged Identity Management</a>以便发现、限制和监视管理员及其对资源的访问，并在需要时提供实时访问。</li>
</ul>
<p>该部分内容来自其技术文档，更多内容请访问<a href="https://docs.microsoft.com/zh-cn/azure/active-directory/fundamentals/active-directory-whatis">什么是 Azure Active Directory？</a></p>
<h3 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h3><p>获取Azure Active Directory的方法有两种：</p>
<p>方法一：注册Azure账号即可使用Azure Active Directory Free版本。该方法是最简单，也是长期可用的。但是部分功能无法使用，比如使用本地写回进行自助式密码重置/更改/解锁。</p>
<p>方法二：通过<strong><strong>Microsoft 365 Developer Program</strong></strong>获取Azure AD Premium P2。该方式可以解锁所有Azure AD功能，但是通过该方式申请到Microsoft 365 E5订阅有效期只有120天，之后微软会根据规则决定是否自动续期。目前，可以在网上找到如何自动续期的方案。</p>
<h2 id="Active-Directory-Domain-Service"><a href="#Active-Directory-Domain-Service" class="headerlink" title="Active Directory Domain Service"></a>Active Directory Domain Service</h2><p>Active Directory 存储有关网络上对象的信息，并使管理员和用户可以轻松查找和使用这些信息。 Active Directory 使用结构化数据存储作为目录信息的逻辑分层组织的基础。</p>
<h3 id="如何获取AD"><a href="#如何获取AD" class="headerlink" title="如何获取AD"></a>如何获取AD</h3><p>获取AD有两种方式：</p>
<p>方法一，使用Azure Active Directory Domain Services。对于个人用户而言，价格有点高，比如在East Asia一个月至少需要109美元。其好处也是不言而喻的，可靠性是有保障的。</p>
<p>方法二，在本地Windows Server上安装AD。与我而言，我会选择这种方案，因为其成本相对而言会低很多，可靠性的优先级并不是很高。</p>
<h3 id="Windows-AD-和Azure-AD之间的同步"><a href="#Windows-AD-和Azure-AD之间的同步" class="headerlink" title="Windows AD 和Azure AD之间的同步"></a>Windows AD 和Azure AD之间的同步</h3><p>Azure 提供了现成的工具，只需要在Windows Server上安装Azure AD Connect sync。详细内容可以参考：<a href="https://docs.microsoft.com/en-us/azure/active-directory/hybrid/how-to-connect-sync-whatis">https://docs.microsoft.com/en-us/azure/active-directory/hybrid/how-to-connect-sync-whatis</a></p>
<p>如果AAD的license是P1或者P2，可以开启密码回写，这样就可以通过微软提供的服务进行密码修改。可以参考： <a href="https://docs.microsoft.com/en-us/azure/active-directory/hybrid/how-to-connect-password-hash-synchronization">https://docs.microsoft.com/en-us/azure/active-directory/hybrid/how-to-connect-password-hash-synchronization</a></p>
<p>如果只是free license，还想通过web页面修改密码，需要借助Remote Desktop Services来实现，可以参考：<a href="https://www.devopsage.com/how-to-setup-web-page-to-change-users-password/">https://www.devopsage.com/how-to-setup-web-page-to-change-users-password/</a></p>
<h3 id="如何管理用户和用户组"><a href="#如何管理用户和用户组" class="headerlink" title="如何管理用户和用户组"></a>如何管理用户和用户组</h3><p>我采用的方案如下：</p>
<ul>
<li>在Windows Server AD上维护用户组，之后用户组会自动同步到AAD上。</li>
<li>在Windows Server AD上维护用户，之后用户组会自动同步到AAD上。</li>
<li>根据使用场景创建用户组。以Jenkins为例，我将用户分为两类：Admin和User，Admin可以管理Jenkins的系统配置，User只能使用Jenkins，因此我会建立两个用户组：JenkinsAdmin 和 JenkinsUser。使用AAD实现SSO，最终根据用户组分配权限。</li>
</ul>
<h2 id="利用Azure-AD实现应用SSO"><a href="#利用Azure-AD实现应用SSO" class="headerlink" title="利用Azure AD实现应用SSO"></a>利用Azure AD实现应用SSO</h2><p>Azure AD可以与很多种身份验证和同步协议集成。通过身份验证集成，只需对使用旧式身份验证方法的应用程序进行少量更改（或无需更改），即可使用 Azure AD 及其安全和管理功能。 利用同步集成，可以将用户和组数据同步到 Azure AD，然后使用用户 Azure AD 管理功能。 某些同步模式还支持自动预配。</p>
<p>支持的旧式身份验证方式：</p>
<ul>
<li>基于标头的身份验证（Header-based authentication）</li>
<li>LDAP身份验证（LDAP authentication）</li>
<li>OAuth 2.0身份验证（OAuth 2.0 authentication）</li>
<li>OIDC身份验证（OIDC authentication）</li>
<li>基于密码的SSO身份验证（Password based SSO authentication）</li>
<li>RADIUS 身份验证（RADIUS authentication）</li>
<li>远程桌面网关服务（Remote Desktop Gateway services）</li>
<li>Secure Shell (SSH)</li>
<li>SAML 身份认证（SAML authentication）</li>
<li>Windows身份认证（Windows Authentication - Kerberos Constrained Delegation）</li>
</ul>
<p>支持的同步模式</p>
<ul>
<li>目录同步：从本地 Active Directory 环境同步到 Azure AD</li>
<li>LDAP同步</li>
<li>SCIM同步</li>
</ul>
<p>更多详细的内容可以看<a href="https://docs.microsoft.com/zh-cn/azure/active-directory/fundamentals/auth-sync-overview">Azure Active Directory 身份验证和同步协议概述 - Microsoft Entra | Microsoft Docs</a>，毕竟是官方文档。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用一张图总结一下。在我的Homelab环境中，AD之间的同步，以及用户如何使用Azure AD登录到Jenkins上。</p>
<img src="azure-ad-sso.png" width="80%">

<p>接下来我会分享几篇实践性的博客，讲讲Azure AD与Synology NAS, Jenkins, Gitlab等的集成。</p>
]]></content>
      <categories>
        <category>DevOps</category>
        <category>Cloud Computing</category>
        <category>Homelab</category>
        <category>Public Cloud Provider</category>
        <category>Azure</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
        <tag>Authorization</tag>
        <tag>Authentication</tag>
        <tag>SSO</tag>
        <tag>Azure</tag>
        <tag>Azure Active Directory</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写README</title>
    <url>/2022/06/28/how-to-write-readme/</url>
    <content><![CDATA[<p>在代码项目根目录里，我们会经常看见README.md。README是什么？它是项目的自我介绍，类似于你的简历，都是用来销售自己的，让公司雇佣你，让别人采纳你的项目。</p>
<p>在本文中，我将尝试着为介绍一下如何写README。</p>
<span id="more"></span>

<p>写README可以按照5W1H(what, why, when, how, where, who)的思路去写，主要还是使用What, Why, How, Who。</p>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p><strong>What</strong> 主要是以下两方面：</p>
<ul>
<li>是什么？</li>
<li>能干什么？（提供了什么功能）</li>
</ul>
<p>比如在 <a href="https://github.com/kubernetes/kubernetes">Kubernetes</a>  的README中，</p>
<blockquote>
<p>Kubernetes, also known as K8s, is an open source system for managing containerized applications across multiple hosts. It provides basic mechanisms for deployment, maintenance, and scaling of applications.</p>
</blockquote>
<p>通过这段话，我们知道了如下信息：</p>
<ul>
<li>Kubernetes, also known as K8s, is an open source system for managing containerized applications across multiple hosts.（<strong>是什么</strong>）</li>
<li>It provides basic mechanisms for deployment, maintenance, and scaling of applications.（<strong>能干什么？</strong>）</li>
</ul>
<p>除了<strong>是什么</strong>和<strong>能干什么</strong>，还可能会有起源，License等</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p><strong>Why</strong> 主要是说明<strong>动机:</strong></p>
<ul>
<li>为什么做？</li>
<li>解决了什么问题？</li>
<li>带来了哪些好处（benefits）？</li>
</ul>
<p>比如在<a href="https://github.com/hashicorp/vault">Hashicorp Vault</a> 中，</p>
<blockquote>
<p>A modern system requires access to a multitude of secrets: database credentials, API keys for external services, credentials for service-oriented architecture communication, etc. Understanding who is accessing what secrets is already very difficult and platform-specific. Adding on key rolling, secure storage, and detailed audit logs is almost impossible without a custom solution. This is where Vault steps in.</p>
</blockquote>
<p>第一句话介绍了背景，第二句话说明在该背景之下，所面对的困难。最后一句告诉大家Vault这个工具就是解决这些问题的。</p>
<p>关于带来了哪些好处，这部分通常而言是和What中能干什么（功能）有重合的。</p>
<h2 id="Who"><a href="#Who" class="headerlink" title="Who"></a>Who</h2><p><strong>Who</strong> 有如下内容：</p>
<ul>
<li>谁维护该项目？</li>
<li>有哪些贡献者？</li>
<li>沟通方式。比如slack channel。</li>
</ul>
<p>关于<strong>谁维护该项目</strong>，在开源项目中会默认是社区或者repo的拥有者维护。但是在内部项目，随着人员的流动，还是很有必要注明该项目当前是谁/哪个团队负责维护的。</p>
<p>有哪些贡献者，在开源项目中经常会在README中看见很多提交代码人的头像，这样可以激励大家去提交代码。</p>
<p>比如在<a href="https://github.com/vuejs/vue">Vue</a>中Contribution部分就做了这件事情。</p>
<p>沟通方式和下面的部分内容有一定的重复，提供一个或者多个平台，发布信息，让大家交流，提供反馈等。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>这部分重点关注两类人：使用者和开发者。</p>
<p>使用者，也就是用户。对于用户，我们需要告诉用户如下内容：</p>
<ul>
<li>使用的前置条件（Prerequisite）。安装哪些依赖，需要什么credentials等等。比如我写一个docker-compose文件用来在本地运行Jenkins，那么我的前置条件就是：docker和docker-compose已经安装在本地了。</li>
<li>如何安装？个人建议：提供一个脚本实现一键安装，这样可以降低用户使用门槛。</li>
<li>如何使用？</li>
<li>如何卸载？这部分内容是绝大数项目所缺少的，本来的我只是想尝试一下，结果我安装之后就无法卸载了，这也是一件很蛋疼的事情。</li>
<li>如何提供反馈？用户在使用过程中，出现了bug，用户在哪里反馈这个bug。通常情况下，用户可以提issue，可以不写。如果不是，应当写出来。</li>
</ul>
<p>这部分内容通常会集中在Documentation或者Getting Started这一类的标题之下。</p>
<p>比如在<a href="https://github.com/hashicorp/vault#documentation-getting-started-and-certification-exams">Hashicorp Vault</a> 中，Documentation, Getting Started, and Certification Exams就是用来告诉用户如何使用。</p>
<p>再比如在<a href="https://github.com/vuejs/vue">Vue</a>中，Documentation就是指向一些案例和文档，Issues就是告诉用户遇到问题如何创建一个issue。</p>
<p>开发者，可能对你项目感兴趣的人，想在你的基础上添加一些功能，或者发现了bug帮助你修复。我们需要提供给开发者Contributing Guide，包含如下内容：</p>
<ul>
<li>技术栈。可以考虑使用badge来标示关键依赖。badge可以参考<a href="https://shields.io/">https://shields.io/</a></li>
<li>Code of Conduct</li>
<li>CI/CD 状态。建议使用badge。</li>
<li>如何执行测试？</li>
<li>如何执行代码风格检查?</li>
<li>如何构建（build）?</li>
<li>如何提交代码？如果涉及多分支，说明不同分支的用途。</li>
</ul>
<p>以上的每一项不一定都需要，以上的内容也不是全部内容。通常这部分内容会出现在Development，contribution等这一类的标题之下。</p>
<p>比如在<a href="https://github.com/hashicorp/vault#documentation-getting-started-and-certification-exams">Hashicorp Vault</a> 中，有一个小节Developing Vault来告诉开发者如何开发。</p>
<p>在<a href="https://github.com/vuejs/vue">Vue</a>中，并不是将如何贡献代码写到了contribution之下，而是将其内容放到了另外一个页面，这是非常好的做法。<strong>在写README的时候，如果某个部分内容太长了就应该将其移到另外一个文件中。保持README完整，简洁，有条理是很重要的。</strong>不要尝试着增加用户（使用者/开发者）的阅读负担。</p>
]]></content>
      <categories>
        <category>Development</category>
      </categories>
      <tags>
        <tag>Development</tag>
        <tag>README</tag>
      </tags>
  </entry>
  <entry>
    <title>新手如何学习Git</title>
    <url>/2022/03/24/how-to-learning-git/</url>
    <content><![CDATA[<p>版本控制记录着软件的每一次改变，每一次发布，以及每一个Bug。 它贯穿于软件的生命周期，从生到死，<strong>请慎重对待每一次提交，像记录历史一样书写提交记录</strong>。</p>
<p>当下最流行的Git是一个不错的选择，<strong>作为合格的软件开发人员你应该熟练的使用它</strong>。你可以构造一些场景去练习git命令，比如：</p>
<span id="more"></span>

<ul>
<li>在Github创建一个repo，并向其提交代码。（clone, add, commit, push）</li>
<li>从main分支创建一个新的分支dev，改变代码，然后通过PR的方式将代码合并到main分支。(checkout, pr, branch)</li>
<li>从main分支创建一个新的分支dev，改变代码提交。然后切回main分支，改变代码，提交至远端分支。再切换dev分支，将main分支的提交合并到当前分支。（练习rebase和reset）</li>
<li>从main分支创建一个新的分支dev, 创建7个commit，然后将他们合并为1个commit. （练习使用reset或者rebase）</li>
<li>从main分支创建一个新的分支dev, 创建7个commit，然后将第七个commit合并到第一个commit，抛弃第二个commit，仅修改第三个commit的commit message，仅修改第四个commit的commit author，修改第六个commit的代码。（练习rebase，以及如何整理commit message）</li>
<li>Fork一个repo，本地clone，修改代码。在被fork的repo主分支出现新的提交之后，将本地代码和被fork的repo同步。（练习remote, fetch, rebase）</li>
</ul>
<p>这里只列举了一些场景，你也可以根据你的需求再写一些场景用来练习。<strong>建议使用命令行练习</strong>，也建议以后的开发过程中使用命令行，最好不要使用IDE提供的UI。</p>
<p>当你了解了Git之后，也需要学习一下常见的git工作流：</p>
<ul>
<li>Git flow</li>
<li>Trunk-based</li>
<li>Feature branching</li>
<li>Forking Workflow</li>
</ul>
<p>学习资料:</p>
<ul>
<li>官方文档：<a href="https://git-scm.com/doc">Git - Documentation (git-scm.com)</a>. 官方文档已经写的很详尽了。</li>
<li>一本书 Pro Git: <a href="https://github.com/progit/progit2/releases/download/2.1.338/progit.pdf">https://github.com/progit/progit2/releases/download/2.1.338/progit.pdf</a></li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
        <category>Development</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Git</tag>
        <tag>Version Control</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL开发环境搭建分享</title>
    <url>/2022/01/13/wsl-development/</url>
    <content><![CDATA[<p>一篇平平无奇的WSL使用推荐指南。在本篇中，不会讨论什么是WSL，如何安装WSL，单纯地分享我是如何使用WSL进行日常开发的。</p>
<p>我当前是使用的WSL配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME            STATE           VERSION</span><br><span class="line">* Ubuntu-20.04    Running         2</span><br></pre></td></tr></table></figure>

<p>我习惯使用大量的CLI来提升自己的工作效率以及使用体验，因此一个好用的Terminal和一系列高效率的CLI工具对我是十分重要的。</p>
<span id="more"></span>

<h2 id="WSL-配置"><a href="#WSL-配置" class="headerlink" title="WSL 配置"></a>WSL 配置</h2><p>文件的权限问题，解决方法参考<a href="https://chengqing.dev/2021/04/24/long-term-wsl/">[长期更新] WSL使用记录</a></p>
<p>配置git，执行下面命令之后，使用https clone的代码就不用经常输入用户名密码了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<p>WSL中Git的默认编辑器对于我来说不咋好用，我比较喜欢使用vim。可以使用下面的命令更改默认编辑器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.editor vim</span><br></pre></td></tr></table></figure>

<h2 id="CLI工具"><a href="#CLI工具" class="headerlink" title="CLI工具"></a>CLI工具</h2><h3 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h3><p>在Windows上面，我推荐使用 Windows Terminal （<a href="https://www.microsoft.com/store/productId/9N0DX20HK701">下载链接</a>）。推荐理由：</p>
<ul>
<li>微软官方开发维护。</li>
<li>可以根据自己的使用习惯定制化。</li>
<li>可以在WSL，PowerShell，CMD，Azure Cloud Shell之间切换。</li>
</ul>
<h3 id="Zsh"><a href="#Zsh" class="headerlink" title="Zsh"></a>Zsh</h3><p>ubuntu 里面默认提供的是Bash，不是特别适合日常使用。相较于Bash，Zsh更加适合交互，比如如下功能：</p>
<ul>
<li>无需 <code>cd</code> 也可以切换目录，在Bash需要使用 <code>cd projects</code> ，在Zsh下直接 <code>projects</code> 就行了。</li>
<li>扩展路径，比如输入 <code>/u/loc</code> 然后Tab，就会变成 <code>/usr/local/</code> 。</li>
<li>支持插件和主题。</li>
</ul>
<p>如何安装Zsh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install zsh -y</span><br></pre></td></tr></table></figure>

<p>如果想知道更多有关Zsh的知识，请阅读<a href="https://zsh.sourceforge.io/">官方文档</a>。</p>
<h3 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h3><p>Oh My Zsh 是一个开源的管理Zsh配置的框架。在其<a href="https://github.com/ohmyzsh/ohmyzsh">GitHub</a>的Readme中有一句很有意思的话，<strong>Oh My Zsh will not make you a 10x developer…but you may feel like one.</strong></p>
<p>如何安装Oh My Zsh：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wget -y</span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>我使用的是Oh My Zsh的默认主题，如果想更改主题，请阅读 <a href="https://github.com/ohmyzsh/ohmyzsh#themes">Readme</a>.</p>
<h3 id="Oh-My-Zsh-插件"><a href="#Oh-My-Zsh-插件" class="headerlink" title="Oh My Zsh 插件"></a>Oh My Zsh 插件</h3><p>插件是一个重头戏，利用插件可以提升我们的工作效率。</p>
<p><code>autojump</code> 是一个小工具，可以帮助我们快速导航到一个目录中，支持模糊匹配。比如有一个目录名称我记得其中包含了 <code>hexo</code> 而且我曾经进入过，那么我就可以使用 <code>j hexo</code> 尝试进入。<strong>强烈推荐</strong>。</p>
<p>安装方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install autojump -y</span><br></pre></td></tr></table></figure>

<p>安装完之后，修改 <code>~/.zshrc</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(git autojump)</span><br></pre></td></tr></table></figure>

<p><code>git</code> 支持git的插件时oh-my-zsh 默认添加了的，提供了很多简写的别名。比如我常用的 <code>gst</code> 就是 <code>git status</code> 的别名。更多别名，请参考 <a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git">ohmyzsh/plugins/git</a>。</p>
<p>Oh My Zsh还支持很多插件，详情请参考<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">Plugins</a>。</p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a><strong>Homebrew</strong></h3><p>Homebrew 是一个包管理器。Homebrew也提供了很多有用的cli工具，我使用Homebrew 的原因是我公司配置的电脑是Macbook，在WSL中继续使用该工具，可以给我带来一致性的体验。而且Homebrew自己开发CLI工具，安装等相比于apt更加方便。</p>
<p>安装方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>更多使用方式，请参考<a href="https://brew.sh/">The Missing Package Manager for macOS (or Linux) — Homebrew</a></p>
<h3 id="tig"><a href="#tig" class="headerlink" title="tig"></a>tig</h3><p>在使用git的过程中，本地看提交记录，或者reset的时候找起点等等情况下，如果使用 <code>git log</code> 就会很难受，tig完美地解决了这个问题，还能快速浏览每一个提交的内容等。</p>
<p>安装方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tig -y</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">brew install tig</span><br></pre></td></tr></table></figure>

<h2 id="语言开发环境管理"><a href="#语言开发环境管理" class="headerlink" title="语言开发环境管理"></a>语言开发环境管理</h2><p>这里只是列举了一些，我使用过的管理工具，其它语言请自行探索。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>管理工具</th>
<th>安装方式</th>
<th>文档</th>
</tr>
</thead>
<tbody><tr>
<td>Java</td>
<td>jenv</td>
<td><code>brew install jenv</code></td>
<td><a href="https://github.com/jenv/jenv">jenv/jenv: Manage your Java environment</a></td>
</tr>
<tr>
<td>Node.js</td>
<td>nvm</td>
<td><code>wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</code></td>
<td><a href="https://github.com/nvm-sh/nvm">nvm-sh/nvm: Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions</a></td>
</tr>
<tr>
<td>Ruby</td>
<td>rbenv</td>
<td><code>brew install rbenv</code></td>
<td><a href="https://github.com/rbenv/rbenv">rbenv/rbenv: Manage your app’s Ruby environment</a></td>
</tr>
<tr>
<td>Python</td>
<td>pyenv</td>
<td><code>brew install pyenv</code></td>
<td><a href="https://github.com/pyenv/pyenv">Simple Python version management (from pyenv)</a></td>
</tr>
</tbody></table>
<h3 id="与JetBrains-IDE集成"><a href="#与JetBrains-IDE集成" class="headerlink" title="与JetBrains IDE集成"></a>与JetBrains IDE集成</h3><p>与JetBrains IDE集成，需要做两件事情。</p>
<ol>
<li>切换Terminal，默认的是CMD。为了更好的体验，可以切换到wsl. </li>
</ol>
<p><code>Settings</code> → <code>Tools</code>  → <code>Terminal</code> , 在 <code>Application Settings</code> 中 <code>Shell path</code> 改成 <code>wsl</code> .</p>
<img src="wsl-terminal.png" width="80%">

<ol start="2">
<li>设置SDK，以 WebStorm为例。<img src="wsl-sdk.png" width="80%"></li>
</ol>
<h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><ol>
<li>在vscode中安装扩展插件 <code>Remote Development</code> </li>
<li><code>Ctrl + Shift + P</code> , 输入 <code>shell command</code> , 执行 <code>Install &#39;code&#39; command in PATH command</code></li>
<li>在WSL中就可以使用vscode了，比如 <code>code .</code> 在vscode中打开当前目录。</li>
</ol>
]]></content>
      <categories>
        <category>Windows</category>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>wsl</tag>
        <tag>development</tag>
      </tags>
  </entry>
  <entry>
    <title>AWTRIX 显示Hexo博客阅读数量</title>
    <url>/2022/01/12/awtrix-hexo-leancloud-counter/</url>
    <content><![CDATA[<h2 id="为啥想写这个App"><a href="#为啥想写这个App" class="headerlink" title="为啥想写这个App"></a>为啥想写这个App</h2><p>21年的时候做桌面改造的时候，想给自己加一个时钟。看了一圈之后，最终入手了AWTRIX Pro mini。</p>
<p>在AWTRIX App Store中有很多有趣的App，比如GithubFollowers, Bilibili等，并且安装了GithubFollowers，一段时间之后，发现那个数字一直卡在7，尴尴尬尬，内心毫无波澜，于是卸掉。</p>
<p>于是就想看看自己自己博客有多少有效阅读量（每篇博客的阅读量之和）。</p>
<span id="more"></span>

<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>这是我第一次开发AWTRIX App，我也是极其懵逼。阅读官方文档是最快捷的方法，如果有兴趣可以参考<a href="https://awtrixdocs.blueforcer.de/#/en-en/appcoding">Programming (blueforcer.de)</a></p>
<p>我的博客是使用Hexo搭建的，阅读计数使用的是LeanCloud。</p>
<p>LeanCloud是提供了API接口，文档参见 <a href="https://leancloud.cn/docs/rest_api.html">存储 REST API 使用指南 - LeanCloud 文档</a></p>
<h3 id="第一步：获取数据"><a href="#第一步：获取数据" class="headerlink" title="第一步：获取数据"></a>第一步：获取数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Sub <span class="title">App_startDownload</span><span class="params">(jobNr As Int)</span></span></span><br><span class="line"><span class="function">	Select jobNr</span></span><br><span class="line"><span class="function">		Case 1</span></span><br><span class="line"><span class="function">			App.<span class="title">Download</span><span class="params">(App.get(<span class="string">&quot;API&quot;</span>)</span>&amp;&quot;/1.1/classes/Counter&quot;)</span></span><br><span class="line"><span class="function">			App.Header </span>= CreateMap(<span class="string">&quot;X-LC-Id&quot;</span>:App.get(<span class="string">&quot;AppId&quot;</span>), <span class="string">&quot;X-LC-Key&quot;</span>:App.get(<span class="string">&quot;AppKey&quot;</span>))</span><br><span class="line">	End Select</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>

<p>这一步需要注意的是 <code>App.get()</code> 中key的大小写，我在这里栽倒了。</p>
<h3 id="第二步：处理数据"><a href="#第二步：处理数据" class="headerlink" title="第二步：处理数据"></a>第二步：处理数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Sub <span class="title">App_evalJobResponse</span><span class="params">(Resp As JobResponse)</span></span></span><br><span class="line"><span class="function">	Try</span></span><br><span class="line"><span class="function">		If Resp.success Then</span></span><br><span class="line"><span class="function">			Select Resp.jobNr</span></span><br><span class="line"><span class="function">				Case 1</span></span><br><span class="line"><span class="function">					Dim parser As JSONParser</span></span><br><span class="line"><span class="function">					parser.<span class="title">Initialize</span><span class="params">(Resp.ResponseString)</span></span></span><br><span class="line"><span class="function">					Dim root As Map </span>= parser.NextObject</span><br><span class="line">					Dim results As List = root.Get(<span class="string">&quot;results&quot;</span>)</span><br><span class="line">					total_view = <span class="number">0</span></span><br><span class="line">					For Each postView As Map In results</span><br><span class="line">						total_view = total_view + postView.Get(<span class="string">&quot;time&quot;</span>)</span><br><span class="line">					Next</span><br><span class="line">			End Select</span><br><span class="line">		End If</span><br><span class="line">	Catch</span><br><span class="line">		App.throwError(LastException)</span><br><span class="line">	End Try</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>

<p><code>total_view</code> 是一个全局变量，记得清零。</p>
<h3 id="第三步：显示输出"><a href="#第三步：显示输出" class="headerlink" title="第三步：显示输出"></a>第三步：显示输出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sub App_genFrame</span><br><span class="line">	App.genSimpleFrame(total_view,<span class="number">1720</span>,True,False,Null,True)</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>

<p>代码详见：<a href="https://github.com/chengqing-su/awtrix-hexo-leancloud-counter">https://github.com/chengqing-su/awtrix-hexo-leancloud-counter</a></p>
<p>如果你需要编译号的Jar包，请自取：<a href="https://github.com/chengqing-su/awtrix-hexo-leancloud-counter/releases/download/v1.0.0/HexoLeanCloud.tar.gz">https://github.com/chengqing-su/awtrix-hexo-leancloud-counter/releases/download/v1.0.0/HexoLeanCloud.tar.gz</a></p>
<h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p>最近几天看着数字不对地变化，感觉自己更加有动力去写博客，去维护博客。</p>
<img src="show.jpg" width="80%">
]]></content>
      <categories>
        <category>Homelab</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
        <tag>AWTRIX</tag>
      </tags>
  </entry>
  <entry>
    <title>版本控制</title>
    <url>/2022/01/05/version-control/</url>
    <content><![CDATA[<p>本文将聊一聊版本控制和版本控制系统。</p>
<span id="more"></span>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>在大学的期间，我们会以团队的方式完成一项大作业，比如写一个小编译器，基本上大作业都会要求写一份报告。</p>
<p>团队成员：A、B、C、D</p>
<p>报告结构：介绍、原理分析、设计、实现、总结和展望</p>
<p>分工：</p>
<p>A：完成介绍、总结和展望两部分，合并报告</p>
<p>B：完成原理分析部分</p>
<p>C：完成设计部分</p>
<p>D：完成实现部分</p>
<img src="version-control-1.drawio.svg" width="50%">

<p>为了统一风格，比如标题字体、正文字体，以及大家各自完成各自的部分不用等待别人，因此我们会先做一个模版。之后A、B、C、D都会基于改模版去填充各自的内容。这时候我们就有了一个Word文件，我们姑且取名为 <code>homework-v0.docx</code>.</p>
<p>当B在开始写<em>原理分析</em>的时候，他需要先从A那边拿到， 然后复制一份<code>homework-v0.docx</code>并命名为<code>homework-v0.1.docx</code>。在新文件中开始自己的工作，写完之后保存。检查一遍之后，他发现有些小问题要改一下，因此复制<code>homework-v0.1.docx</code>并命名为<code>homework-v0.2.docx</code>。</p>
<p> 当B完成了自己的部分，这个时候需要将B完成的部分合并到模版中。复制<code>homework-v0.docx</code> 为<code>homework-v1.docx</code> ，在新文件中插入B完成的内容然后保存，这个时候就形成了v1版本的报告。</p>
<p>这个时候，我们有了两份文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">homework-v0.docx</span><br><span class="line">homework-v1.docx </span><br></pre></td></tr></table></figure>

<p>v0和v1之间的区别是什么？v1在v0的基础上新增了内容，而上文中v0.1和v0.2是更改了一些内容，我们称这些内容为变更。上文中，我们通过复制文件方式实现了版本的管理和追踪，实现了对变更的管理和追踪。</p>
<p>这只是版本控制的一种实现方式，一种最简单的实现方式。接下来再聊聊版本控制系统。</p>
<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><p><strong>什么是版本控制系统，用于管理和追踪变更的工具</strong>。这里面的变更不仅仅是针对代码的，也可以是文档或者其他的工程文件等。</p>
<h3 id="本地版本控制系统-Local-Version-Control-Systems"><a href="#本地版本控制系统-Local-Version-Control-Systems" class="headerlink" title="本地版本控制系统(Local Version Control Systems)"></a>本地版本控制系统(<strong>Local Version Control Systems)</strong></h3><p>使用复制文件这种方式，很容易犯错，一不小心就会写错文件或者覆盖到意料之外的文件。</p>
<img src="lvcs.png" width="60%">

<p>因此就有了<strong>本地版本控制系统，通常是采用数据库来记录文件的历次更新差异</strong>。本地版本控制系统是第一代版本控制系统，其代表是Revision Control System(RCS)。<a href="https://www.gnu.org/software/rcs/">RCS</a>的工作原理是将补丁（文件之间的差异）以一种特殊的方式保存在磁盘上，然后添加补丁的方式重新创建任何时间点的文件。</p>
<h3 id="集中版本控制系统-Centralized-Version-Control-Systems"><a href="#集中版本控制系统-Centralized-Version-Control-Systems" class="headerlink" title="集中版本控制系统(Centralized Version Control Systems)"></a>集中版本控制系统(<strong>Centralized Version Control Systems)</strong></h3><p>在本地版本控制系统的使用过程，不可避免的问题就是如何与其他开发者协同工作。</p>
<img src="cvcs.png" width="60%">

<p>因此就有了集中版本控制系统，也就是第二代版本控制系统。相对于本地VCS，其提供了如下优点：</p>
<ul>
<li>项目透明度。项目成员可以知道项目中其他成员在做什么。</li>
<li>更加精确的权限控制。CVCS的管理员可以设置谁可以做什么。</li>
<li>更方便管理。</li>
</ul>
<p>当然也是有缺点的，最大的缺点就是单点故障。日常的开发协作是严重依赖于中心服务器，如果服务器挂了，项目成员将不能进行协作，如果服务器的磁盘损坏且无备份，有可能会损失整个历史记录。</p>
<p>其代表工具有CVS，Subversion(SVN)</p>
<h3 id="分布式版本控制系统-Distributed-Version-Control-Systems"><a href="#分布式版本控制系统-Distributed-Version-Control-Systems" class="headerlink" title="分布式版本控制系统(Distributed Version Control Systems)"></a>分布式版本控制系统(<strong>Distributed Version Control Systems)</strong></h3><p>分布式版本控制系统中，每一个客户端不是提取了最新的快照，而是镜像了整个代码仓库，包括历史记录等，如果某个服务器挂，可以使用任何客户端的存储库复制回服务器中以将其还原。</p>
<img src="dvcs.png" width="60%">

<p>分布式版本控制系统，又称为第三代版本控制系统，其代表有BitKeeper、Git、Monotone、darcs、Mercurial。目前Git是主流的选择。</p>
<p>以上部分，关于<em>本地版本控制系统，集中版本控制系统，分布式版本控制系统</em> 主要来自于<a href="https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control">Git的官网</a>，只有部分内容，详细内容请阅读官方资料。</p>
<h2 id="为什么需要版本控制系统"><a href="#为什么需要版本控制系统" class="headerlink" title="为什么需要版本控制系统"></a>为什么需要版本控制系统</h2><ol>
<li>协作。在一个多人的项目中，项目成员更加方便地贡献代码，更加快速地高效地采用其他成员贡献的代码。</li>
<li>版本存储。</li>
<li>回滚。因为有版本存在，可以快速回滚到什么一个版本。</li>
<li>追踪变更历史。可以清楚地知道整个代码库中，谁在什么时间做出了什么改动，改动的具体内容是什么。</li>
<li>备份。备份时分布式版本控制系统附带一个非常好用的功能，每个项目成员都拥有完整的代码副本，当服务器挂了，也可以快速恢复。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control">About Version Control (git-scm.com)</a></p>
<p><a href="https://www.atlassian.com/git/tutorials/what-is-version-control">what is version-control</a></p>
]]></content>
      <categories>
        <category>DevOps</category>
        <category>Version Control</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Version Control</tag>
      </tags>
  </entry>
  <entry>
    <title>2021干得不错,2022继续加油</title>
    <url>/2021/12/30/2021-2022/</url>
    <content><![CDATA[<p>2021年，于我而言是变化极多的一年。总体趋势是好的，我看见了更多的可能和更多的希望。</p>
<p>还完了贷款。</p>
<p>换了一份工作。离开了ThoughtWorks，加入了SAP。</p>
<p>完成了第一场纯英语Session（2021年10月28日）。</p>
<p>学会了游泳。</p>
<p>做了一次桌面改造。</p>
<p>接种了新冠疫苗。这是我小学几年级之后第一次接种疫苗，小学接种完疫苗之后没多久就得了脑膜炎，虽然二者没有啥相关性，但是还是怕。</p>
<p>入手了一个扫地机器人。</p>
<p>组装了一台电脑。6月组装电脑，年底发12代，有一种49年入国军的感觉。</p>
<p>新入手了一台NAS。目前总存储应该超过了30T了。</p>
<p>……</p>
<span id="more"></span>

<h2 id="2021年"><a href="#2021年" class="headerlink" title="2021年"></a>2021年</h2><h3 id="完成了的目标"><a href="#完成了的目标" class="headerlink" title="完成了的目标"></a>完成了的目标</h3><ul>
<li>考证计划。 Azure Developer Associate</li>
<li>在新加坡看一场电影。在新加坡看了一场电影，忘记名字了（看来是真的老了）。</li>
<li>小说。追完《临渊行》和《帅教官》（一如既往的草草结尾），目前没啥网络小说可以追了。</li>
<li>小破站。对小破站的上的内容开始有点挑剔了，知识性内容的差距和国外某站还是很大的。今年发现一个比较给力的UP主 先看测评。</li>
<li>回国。提桶跑路，比预想的回国早了很多。</li>
</ul>
<h3 id="没有完成的目标"><a href="#没有完成的目标" class="headerlink" title="没有完成的目标"></a>没有完成的目标</h3><ul>
<li>52篇博客。数了一下，只完成了17篇。</li>
<li>把《中国乡村》看完。社科的书籍是真难啃。今年看了《实践论》《矛盾论》，伟人就是伟人。</li>
</ul>
<h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p><strong>刚跑路，前东家就上市了。</strong></p>
<p>今年不适合理财，或者说我不适合理财。</p>
<p>在坡县觉得没地方可去，回国后是啥地方也没有去（就回了一趟家，然后去了一趟深圳）。</p>
<p>至今买不起显卡，现在的显卡连帝国时代都带不动。</p>
<h2 id="2022年"><a href="#2022年" class="headerlink" title="2022年"></a>2022年</h2><p>2022年，要有规律。早睡早起好身体。<br>2022年，要有朝气。<br>2022年，要多出去走走。</p>
<h3 id="新的目标"><a href="#新的目标" class="headerlink" title="新的目标"></a>新的目标</h3><ol>
<li>减肥20斤，76kg→66kg，1-5月每个月瘦4斤，6-8月保持，9-12月争取每月瘦1斤。</li>
<li>加强Python,Java,Ruby,Typescript,PHP, 学习Go。</li>
<li>每季度阅读一本社科人文书籍。</li>
<li>每月输出3-4篇有效有质量的博客。</li>
<li>每月读阅读一本技术书籍。</li>
<li>证书目标：Azure DevOps(1-2月)，Azure Solutions Architect Expert(5-6月), AWS Certified Solutions Architect – Professional（3-4月）</li>
<li>每天坚持写日志。</li>
<li>每周至少做一次饭（正餐）。</li>
</ol>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>2020</tag>
        <tag>总结</tag>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab pipeline 等待手动操作</title>
    <url>/2021/12/20/gitlab-waiting-for-approval/</url>
    <content><![CDATA[<p>在持续交付的过程中，需要手动确认，然后才能继续部署到生产环境。在本文中将实现这个过程，也是一个踩坑的过程。</p>
<span id="more"></span>

<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>说出来其实很简单，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">waiting-for-approval:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">waiting-for-approval</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">allow_failure:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;waiting-for-approval&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里面有两个关键字段： <code>when</code> 和 <code>allow_failure</code> 。</p>
<h3 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h3><p>该字段指示在什么条件下执行该Job。可以使用如下值,</p>
<ul>
<li><code>on_success</code> (默认): 当上一个stage中的所有Job成功执行之后才能执行或者上一个stage中所有的Job 配置有字段<code>allow_failure: true</code> 。</li>
<li><code>manual</code>: 手动触发该Job。</li>
<li><code>always</code>: 无论之前的stage是否成功，总是执行该Job。</li>
<li><code>on_failure</code>: 当上一个stage中有Job失败的情况下，执行该Job。</li>
<li><code>delayed</code>: 延迟一段时间执行该Job。</li>
<li><code>never</code>: 不执行该Job.</li>
</ul>
<h3 id="allow-failure"><a href="#allow-failure" class="headerlink" title="allow_failure"></a><code>allow_failure</code></h3><p>该字段决定了当前Job执行失败的情况下，是否继续执行pipeline。值可以是<code>true</code> 或者<code>false</code> 。</p>
<p><strong>注意其默认值，这是比较坑的一点</strong></p>
<ul>
<li>当Job有 <code>when: true</code> 时，默认值为 <code>true</code></li>
<li>当Job有 <code>when: true</code> 并且配置了 <code>rules</code> ，默认值为 false</li>
<li>其他情况，默认值为 <code>true</code></li>
</ul>
<h2 id="踩坑过程"><a href="#踩坑过程" class="headerlink" title="踩坑过程"></a>踩坑过程</h2><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>我想实现如所示pipeline</p>
<img src="ci-demo.png" width="80%">

<p><code>.gitlab-ci.yml</code> 如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">deploy-to-qa</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">waiting-for-approval</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">deploy-to-prod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;build&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-to-qa:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy-to-qa</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;deploy-to-qa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">waiting-for-approval:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">waiting-for-approval</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;waiting-for-approval&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-to-prod:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy-to-prod</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;deploy-to-prod&quot;</span></span><br></pre></td></tr></table></figure>

<p>得到执行结果如下：<br><img src="pipeline-stream.png" width="80%"></p>
<p>我还没有点approval，怎么就执行 <code>deploy-to-prod</code> 了？又看了一眼pipeline的状态是 <code>passed</code> ，怎么就 <code>passed</code> 了？<br><img src="pipeline-status.png" width="80%"></p>
<h3 id="坑在哪里？"><a href="#坑在哪里？" class="headerlink" title="坑在哪里？"></a>坑在哪里？</h3><p>又去看看了文档<a href="https://docs.gitlab.com/ee/ci/yaml/#when">Keyword reference for the <code>.gitlab-ci.yml</code> file | GitLab</a> ，在 <strong><code>Additional details</code></strong> 中发现 了下面这段话</p>
<blockquote>
<p>The default behavior of <code>allow_failure</code> changes to <code>true</code> with <code>when: manual</code>. However, if you use <code>when: manual</code> with <code>[rules](https://docs.gitlab.com/ee/ci/yaml/#rules)</code>, <code>allow_failure</code> defaults to <code>false</code>.</p>
</blockquote>
<p>谜题解开了！</p>
<p>之后又找到另外一篇文档 <a href="https://docs.gitlab.com/ee/ci/jobs/job_control.html#create-a-job-that-must-be-run-manually">Choose when to run jobs | GitLab</a> ，创建一个必须被手动触发的Job。</p>
<h3 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h3><p>修改<code>.gitlab-ci.yml</code> ，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">deploy-to-qa</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">waiting-for-approval</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">deploy-to-prod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;build&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-to-qa:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy-to-qa</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;deploy-to-qa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">waiting-for-approval:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">waiting-for-approval</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">allow_failure:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;waiting-for-approval&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-to-prod:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy-to-prod</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;deploy-to-prod&quot;</span></span><br></pre></td></tr></table></figure>

<p>其执行结果如下：<br><img src="pipeline-stream-2.png" width="80%"><br><img src="pipeline-status-2.png" width="80%"></p>
]]></content>
      <categories>
        <category>DevOps</category>
        <category>Gitlab</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Gitlab</tag>
        <tag>手动Job</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab CI/CD 之 动态pipeline</title>
    <url>/2021/12/11/gitlab-dynamic-pipeline/</url>
    <content><![CDATA[<p>在pipeline的最佳实践中，不推荐使用动态pipeline。任何代码的可读性都是至关重要的，一旦开始使用动态pipeline就很难保证可读性，甚至无法保证可维护性。</p>
<p>虽然不推荐使用动态pipeline，但是在某些场景之下，使用动态pipeline会帮助我们在保证可读性不变甚至提高的情况下，同时提高了可维护性，这个时候我们推荐使用动态pipeline。</p>
<span id="more"></span>

<p>比如，我们需要在CI上对同一个项目跑100个测试，这一个测试唯一的区别就是传入参数不一样，这些参数会随着我们产品的演进而进行更新，比如如下一个片段重复100次，是不是会很痛苦？</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test-with-arg-100:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">auto/test</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="父子pipeline（Parent-child-pipeline）"><a href="#父子pipeline（Parent-child-pipeline）" class="headerlink" title="父子pipeline（Parent-child pipeline）"></a>父子pipeline（<strong>Parent-child pipeline）</strong></h2><p>在Gitlab CI/CD 中，父子pipeline就是在一个pipeline中嵌套执行另外一个pipeline配置文件，即子pipeline。</p>
<p>子管道类型：</p>
<ul>
<li>合并请求子pipeline（Merge request child pipelines）</li>
<li>动态子pipeline（Dynamic child pipelines）</li>
<li>嵌套子pipeline（Nested child pipelines）</li>
</ul>
<p>更多内容可以参考<a href="https://docs.gitlab.com/ee/ci/pipelines/parent_child_pipelines.html">官方文档</a></p>
<h2 id="案例：使用动态子pipeline部署多个应用"><a href="#案例：使用动态子pipeline部署多个应用" class="headerlink" title="案例：使用动态子pipeline部署多个应用"></a>案例：使用动态子pipeline部署多个应用</h2><p>在我的Homelab环境中，有一个Infrastructure的Kubernetes集群，集群中需要部署一系列的基础应用，比如：</p>
<ul>
<li>external dns用于注册ingress dns到DNS server上。</li>
<li>Hashicorp Vault、Jenkins等实验应用</li>
<li>Prometheus等监控应用</li>
</ul>
<p>每一个应用都有一个对应的部署脚本，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── auto</span><br><span class="line">│   ├── deploy-elasticsearch</span><br><span class="line">│   ├── deploy-exdns-homelab-local</span><br><span class="line">│   ├── deploy-grafana</span><br><span class="line">│   ├── deploy-hashicorp-vault</span><br><span class="line">│   ├── deploy-influxdb</span><br><span class="line">│   ├── deploy-ingress</span><br><span class="line">│   ├── deploy-jenkins</span><br><span class="line">│   ├── deploy-prometheus</span><br><span class="line">│   ├── deploy-sonarqube</span><br><span class="line">│   └── deploy-vsphere-prometheus</span><br></pre></td></tr></table></figure>

<p>上面的部署脚本，我都是使用 <code>auto/deploy-*</code> 这样的模式命名部署脚本的。这样根据部署脚本规律生成子pipeline的YAML配置文件，生成脚本如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash -eu</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>/..&quot;</span></span><br><span class="line"></span><br><span class="line">CI_CONFIG_FILE=<span class="string">&quot;child-ci.yml&quot;</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF &gt; &quot;$&#123;CI_CONFIG_FILE&#125;&quot;</span></span><br><span class="line"><span class="string">image: $CI_REGISTRY_IMAGE</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">default:</span></span><br><span class="line"><span class="string">  retry: 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">variables:</span></span><br><span class="line"><span class="string">  KUBERNETES_SERVICE_ACCOUNT_OVERWRITE: k8s-infra-admin</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stages:</span></span><br><span class="line"><span class="string">  - deploy</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> script_name <span class="keyword">in</span> auto/deploy-* ; <span class="keyword">do</span></span><br><span class="line">      cat &lt;&lt;<span class="string">EOF &gt;&gt; &quot;$&#123;CI_CONFIG_FILE&#125;&quot;</span></span><br><span class="line"><span class="string">$&#123;script_name//\//-&#125;:</span></span><br><span class="line"><span class="string">  stage: deploy</span></span><br><span class="line"><span class="string">  script:</span></span><br><span class="line"><span class="string">    - $&#123;script_name&#125;</span></span><br><span class="line"><span class="string">  only:</span></span><br><span class="line"><span class="string">    - main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>部分pipeline配置文件 <code>.gitlab-ci.yml</code> 如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">generate-ci</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">run-ci</span></span><br><span class="line"><span class="attr">default:</span></span><br><span class="line">  <span class="attr">retry:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">generate-config:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">alpine:3.12</span></span><br><span class="line">  <span class="attr">before_script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">apk</span> <span class="string">--no-cache</span> <span class="string">add</span> <span class="string">bash</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">generate-ci</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">auto/generate-ci-config</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">child-ci.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">child-pipeline:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">run-ci</span></span><br><span class="line">  <span class="attr">trigger:</span></span><br><span class="line">    <span class="attr">strategy:</span> <span class="string">depend</span></span><br><span class="line">    <span class="attr">include:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">artifact:</span> <span class="string">child-ci.yml</span></span><br><span class="line">        <span class="attr">job:</span> <span class="string">generate-config</span></span><br></pre></td></tr></table></figure>

<p>pipeline执行图如下所示：<br><img src="pipeline.png" width="80%"></p>
]]></content>
      <categories>
        <category>DevOps</category>
        <category>Gitlab</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Gitlab</tag>
        <tag>动态pipeline</tag>
      </tags>
  </entry>
  <entry>
    <title>桌面改造1.0</title>
    <url>/2021/10/26/refactor-desk-1-0/</url>
    <content><![CDATA[<p>2021年6月2日，解除隔离，被放出来。时隔半年，我又回到了我的小窝。</p>
<p>在当时，可以预见的是，下一份工作可以长期在家办公（WFH），因此桌面还是需要改造一下，让自己在未来的生活和工作满意，取悦自己。</p>
<span id="more"></span>

<h2 id="之前的桌面"><a href="#之前的桌面" class="headerlink" title="之前的桌面"></a>之前的桌面</h2><p>先看一下之前的桌面，</p>
<img src="before.jpg" width="80%">

<p>主要部件如下：</p>
<ol>
<li>23.8寸显示器（<strong>AOC Q2490PXQ</strong>）x2</li>
<li>屏幕挂灯(<strong>倍思</strong>) x2</li>
<li>摄像头（<strong>罗技 C310</strong>）x1</li>
<li>台灯（<strong>小米 米家LED智能台灯1S</strong>）x1</li>
<li>HUB (<strong>ORICO 全铝高速USB3.1Gen2</strong>) x1</li>
<li>HDMI 切换器（<strong>威迅 HDMI切换器二进一出 4K</strong>) x1</li>
<li>KVM切换器（<strong>绿联 KVM切换器 HDMI切屏器2进1出4K高清</strong>）x1</li>
<li>USB充电器 (<strong>小米 原装60W USB充电器快充版 六口输出 QC3.0快充协议</strong>) x1</li>
<li>温湿度传感器（<strong>小米 米家蓝牙温湿度计2</strong>）x1</li>
<li>插排（<strong>公牛（BULL） 防过充插座带多口全USB插排</strong>）x1</li>
<li><strong>微软（Microsoft）Designer 无线蓝牙鼠标</strong> x1</li>
<li>键盘（<strong>TT G821 青轴</strong>）x1</li>
<li><strong>罗技（Logitech） M720 鼠标</strong> x1</li>
<li>鼠标垫（<strong>宜适酷 典雅黑 BAS1801-01</strong>）x1</li>
<li>桌子（宜家 <strong>利蒙 150x75桌面 + 可调节桌腿</strong>）x 1</li>
<li>电脑椅（<strong>联丰 ds-177黑</strong>）x1</li>
</ol>
<p>主要问题：</p>
<ol>
<li>显示器屏幕分辨率为2k。虽然2k，但是内心却是向往4k。2k的屏敲代码一点儿都不开心。</li>
<li>摄像头不支持Windows Hello</li>
<li>桌面太乱了</li>
</ol>
<h2 id="第一部分改造"><a href="#第一部分改造" class="headerlink" title="第一部分改造"></a>第一部分改造</h2><h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><p>选择显示器最重要的是解决第一个问题，让我可以开心地码字。</p>
<p>第一步，确定确定尺寸。我桌面宽度是75cm，之前的是显示器是23.8寸，感觉还是比较舒适的，因此<strong>尺寸范围是23.8-27</strong>。</p>
<p>第二步，确定分辨率。之前的显示器是2560*1440dpi，文字显示的细腻度虽然比1080p好很多，但是依然有点糊以及有锯齿。我使用显示器的主要场景是写代码，所以文字显示细腻度对我来说是很重要的，因此选择<strong>分辨率为4K</strong>。</p>
<p>第三步，确定其他功能。我长期面对屏幕，因此<strong>护眼</strong>对我比较重要。</p>
<p>第四步，显示器品牌。我个人更加倾向于DELL，LG这一类的大厂，也包括之前使用过的AOC。</p>
<p><strong>最终的选择是DELL P2721Q。</strong></p>
<p>最开始的时候购入的并不是DELL P2721Q，而是<strong>AOC U27U2D</strong>。从参数上来说AOC U27U2D完全满足我的需求，但是使用了一天之后，有一丢丢眩晕，然后7天无理由退货，重新购入DELL P2721Q。选择显示器的时候，重要的还是自己的眼睛舒服。</p>
<h3 id="屏幕挂灯"><a href="#屏幕挂灯" class="headerlink" title="屏幕挂灯"></a>屏幕挂灯</h3><p>之前的屏幕挂灯使用的是<strong>倍思</strong>的，其开关和调节按钮均在挂灯，每次开关都需要站起来，很不方便。</p>
<p>更换成<strong>小米</strong>的显示器挂灯。这款挂灯最大的优势就是够用而且便宜。</p>
<h3 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h3><p>之前使用的罗技C310摄像头是2017年购入，但是主要使用还是在2020年。主要的使用场景就是Zoom视频会议，除此之外没啥太大功能。</p>
<p>更换摄像头最主要的理由还是想使用Windows Hello。我使用1Password管理自己几乎所有的密码，使用了Windows Hello之后，我就不用每次输入PIN码或者密码了。</p>
<p>Windows Hello摄像头可选项特别少，当然淘宝上也还是有不少自行改装的。下面是几款我知道的支持Windows hello 的摄像头</p>
<ul>
<li>Intel RealSense SR300 F200 （3D结构光）</li>
<li>联想500 （红外）</li>
<li>罗技（Logitech）C1000e （红外）</li>
</ul>
<p>我购入的是联想500（购入时价格399）。理由就是相较于罗技C1000e（京东报价1499）便宜，而且当时没发现Intel RealSense F200（淘宝200多）。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>2021年6月，第一部分改造到这里就结束，主要是对一部分硬件进行了升级和更换。</p>
<img src="in-progress.jpg" width="80%">

<h2 id="第二部分改造"><a href="#第二部分改造" class="headerlink" title="第二部分改造"></a>第二部分改造</h2><p>2021年6月21日，加入我现在的公司，开始了长期的在家办公。</p>
<p>第二部分改造起因如下：</p>
<ul>
<li>2021年10月的时候发现，宜家利蒙桌子的桌面弯曲了</li>
<li>电脑椅也歪了</li>
</ul>
<p>改造目标：</p>
<ul>
<li>电动升降桌</li>
<li>电竞椅/人体工学椅</li>
<li>无线桌面。桌面整洁，尽可能的没有线之类的。</li>
</ul>
<h3 id="电动升降桌"><a href="#电动升降桌" class="headerlink" title="电动升降桌"></a>电动升降桌</h3><p>为什么选择电动升降桌？</p>
<p>久坐的危害是非常大的，比如人脑供血不足，全身肌肉酸痛，脖子僵硬，痔疮，肥胖等等。坐站交替可以有效的缓解这些问题，电动升降桌就提供了站着办公的可能性。</p>
<p>如何选购可参考如下链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/158779121">2021年电动升降桌选购攻略及高性价比电动升降桌推荐（20210628更） - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/383385657">电动升降桌推荐|电动升降桌选购指南 - 知乎 (zhihu.com)</a></p>
<p>我最终购入的是<strong>Brateck北弧 K33。</strong>桌面大小，我个人还是倾向于选择150*75的。使用了快一个月了，够用但是并不优秀，比如：</p>
<ul>
<li>站立办公打字的时候，会有轻微的晃动，在我的可接受范围内。</li>
<li>加上桌面最低高度76cm，有点略高，使用时需要将椅子调整到最高位置。</li>
</ul>
<p>综合其价格和配置，总体上还是满意的。</p>
<h3 id="电脑椅"><a href="#电脑椅" class="headerlink" title="电脑椅"></a>电脑椅</h3><p>我购入的电脑椅是黑白调的电竞椅，入手这款椅子的原因：</p>
<ol>
<li>皮质，不容易积灰。</li>
<li>配色，红黑配。我挺喜欢红黑配色。</li>
</ol>
<p>我比较喜欢在疲惫的时候小憩一会儿或者单纯闭着眼睛躺着思考，这款电脑椅支持后躺，但是并不完美。当坐着的时候靠背有一定的支持作用，比较合适。但是躺下的时候，颈部是悬空的，很难受，加一个颈枕可以缓解这个痛点。</p>
<p>电脑椅和电动升降桌，每一个拎出来看，都还行。但是1+1 &lt; 2啊，两个之间的高度不契合，因此我加了一个网易严选的乳胶坐垫。</p>
<h3 id="显示器增高架"><a href="#显示器增高架" class="headerlink" title="显示器增高架"></a>显示器增高架</h3><p>选择入手显示增高架的原因如下：</p>
<ol>
<li>站立办公和坐着办公的时候，显示器的高度是需要调节，让自己感到舒适。DELL显示器支持的调节范围并不在我的舒适范围内。</li>
<li>增加桌面可利用空间。</li>
</ol>
<p>最终是在淘宝上购入的一款120cm的实木增高架。</p>
<img src="zeng-gao.jpg" width="80%">

<p>在增高架上可以摆放一些小物价，比如书签、蓝牙温湿度传感器、便利贴等等。增高架最右边放着两个控制屏幕挂灯的旋转按钮。旁边是两个叠在一起的收纳盒，用于收纳数据线。将小米USB充电器使用3M魔术贴粘在了增高架上，可以进一步利用空间。这样剩下的空间就可以收纳键盘和鼠标。比如在看书或者吃饭的时候就可以把，键鼠收纳起来，桌面空间就足够大了。</p>
<h3 id="桌底收纳槽"><a href="#桌底收纳槽" class="headerlink" title="桌底收纳槽"></a>桌底收纳槽</h3><p>收纳桌下的各种线，是桌底下变得整洁。之前总是不小心踢掉某根线啥的。</p>
<img src="shou-na.jpg" width="80%">

<p>在长81cm的收纳槽可以放下很多东西，一个10孔插排，一个KVM切换器，一个4空插排。可以使用束线带将多余的线收纳起来，这样线就不会特别乱。</p>
<h3 id="洞洞板"><a href="#洞洞板" class="headerlink" title="洞洞板"></a>洞洞板</h3><p>洞洞板可以灵活地收纳一些物品，比如将剪刀、手工刀、卷尺等挂在上面使用起来更加方便。</p>
<img src="dong-dong-ban.jpg" width="80%">

<p>我选择的这一款带有一个托盘，托盘下面的空间放下扫地机器人，托盘上放打印机，这样可以更加有效率地利用空间。</p>
<h3 id="KVM切换器"><a href="#KVM切换器" class="headerlink" title="KVM切换器"></a>KVM切换器</h3><p>简单介绍一下我的使用场景，我有两台电脑，一台是公司的macbook pro，一台是自己组装的台式机。每天我都需要在这两个设备之间切换使用，工作的时候使用公司的电脑，非工作时间就使用自己的电脑。</p>
<p>之前的解决方案是使用了两个切换器，一个HDMI切换器用于切换其中一个屏幕，另外一个便宜的KVM的切换器用于切换屏幕和键鼠等外接设备。主要问题是，每次切换需要手动按两次按钮。</p>
<p>购入新的KVM切换器之后，可以使用鼠标在两个设备之间快速切换。而且因为不需要手动在切换器上操作，可以将其收纳到桌下理线槽上，进一步节省桌面空间。</p>
<p>到这里，第二部分改造就完成了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="finished.png" width="80%">

<p>主要部件：</p>
<ol>
<li>屏幕挂灯(<strong>小米显示器挂灯</strong>) x2  <a href="https://item.jd.com/100007773997.html">京东</a></li>
<li>摄像头（<strong>联想500</strong>）x1</li>
<li>显示器（<strong>戴尔(DELL) P2721Q</strong>）x2 <a href="https://item.jd.com/100008883679.html">京东</a></li>
<li>120cm显示器增高架 x1 <a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.31c42e8dqDa5uR&id=647103981604&_u=qenv8fsfe9d">淘宝</a></li>
<li>温湿度传感器（<strong>小米 米家蓝牙温湿度计2</strong>）x1 <a href="https://item.jd.com/100010622784.html">京东</a></li>
<li>收纳盒（<strong>JEKO 透明桌面收纳盒</strong>） x2 <a href="https://item.jd.com/100012243060.html">京东</a></li>
<li>USB充电器 (<strong>小米 原装60W USB充电器快充版 六口输出 QC3.0快充协议</strong>) x1</li>
<li>台灯（<strong>小米 米家LED智能台灯1S</strong>）x1 <a href="https://item.jd.com/100005676004.html">京东</a></li>
<li>键盘（<strong>TT G821 青轴</strong>）x1 <a href="https://item.jd.com/100010955206.html">京东</a></li>
<li>鼠标（<strong>罗技（Logitech） M720 鼠标</strong>） x1 <a href="https://item.jd.com/3903182.html">京东</a></li>
<li>鼠标垫（<strong>宜适酷 典雅黑 BAS1801-01</strong>）x1 <a href="https://item.jd.com/6383781.html">京东</a></li>
<li>桌子（<strong>Brateck升降桌K33</strong>) x1 <a href="https://item.jd.com/100018027300.html#crumb-wrap">京东</a></li>
<li>电脑椅（<strong>黑白调HDJY002BMJ</strong>）x1 <a href="https://item.jd.com/71134747428.html">京东</a></li>
<li>桌底收纳槽 x1 <a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.31c42e8dqDa5uR&id=652211892542&_u=qenv8fse9b2">淘宝</a></li>
<li>KVM切换器（<strong>eKL 412HK</strong>）x1 <a href="https://item.jd.com/100009668205.html">京东</a></li>
<li>洞洞板 x1 <a href="https://item.taobao.com/item.htm?spm=a1z09.2.0.0.31c42e8dqDa5uR&id=609165789095&_u=qenv8fsb97f">淘宝</a></li>
</ol>
<p>通过这次改造之后，我能够更好地利用桌面空间，在不同的任务之间更好地切换。比如在看书的时候，可以把键鼠收纳到增高架下。利用增高架可以有效地将线缆隐藏起来，使用收纳槽可以更好地收纳线缆。</p>
<p>我也曾尝试使用磁吸模块将线缆固定在桌子侧边，这样桌面虽然看起来很整洁但是桌下依旧乱，因此暂时放弃了这种方案。<strong>即时收纳，物归原处才能够保持桌面的整洁</strong>。</p>
<p>到此刻位置，其实还有很多事情没有做，比如：</p>
<ul>
<li>无线充电</li>
<li>氛围灯</li>
<li>桌面时钟</li>
<li>提醒工具</li>
</ul>
<p>这些会在桌面改造2.0中慢慢来做，在未来的部分我更加倾向于自己DIY。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>桌面改造</tag>
      </tags>
  </entry>
  <entry>
    <title>使用群晖NAS备份vSphere虚拟机</title>
    <url>/2021/10/19/homelab-backup-vsphere-vm-to-synology/</url>
    <content><![CDATA[<p>TL;DR（太长不读版本）</p>
<p>大致思路就是，在Homelab环境中，利用Synology套件Active Backup for Business进行Vmware vSphere虚拟机备份。</p>
<hr>
<p>数据的灾备是很重要的，就像是开车系安全带，骑小摩托戴头盔，都是为了安全。在这篇博客中，将带着大家一起看看在利用群晖NAS备份vsphere中的虚拟机。</p>
<span id="more"></span>

<h2 id="Active-Backup-for-Business"><a href="#Active-Backup-for-Business" class="headerlink" title="Active Backup for Business"></a>Active Backup for Business</h2><p><code>Active Backup for Business</code>是群晖NAS的一个套件。</p>
<p>主要功能：</p>
<ul>
<li>支持Windows 服务器/PC、Linux服务器、SMB/rsync文件服务器以及VMware vSphere/Microsoft Hyper-V虚拟机备份</li>
<li>灵活的计划和保留策略可自定义备份策略</li>
<li>支持备份数据还原，包括完整设备还原、即时还原和精细文件还原</li>
</ul>
<p>详细信息参考 <a href="%5Bhttps://www.synology.cn/zh-cn/dsm/6.2/software_spec/abb%5D(https://www.synology.cn/zh-cn/dsm/6.2/software_spec/abb)">Active Backup for Business技术规范</a></p>
<h2 id="从头开始创建一个备份任务"><a href="#从头开始创建一个备份任务" class="headerlink" title="从头开始创建一个备份任务"></a>从头开始创建一个备份任务</h2><h3 id="第一步：-安装并打开Active-Backup-for-Business"><a href="#第一步：-安装并打开Active-Backup-for-Business" class="headerlink" title="第一步： 安装并打开Active Backup for Business"></a>第一步： 安装并打开Active Backup for Business</h3><p>在套件中心中安装Active Backup for Business，该套件是免费的，很实在。</p>
<p>安装完成之后，打开它。</p>
<img src="synology-backup-1.png" width="80%">

<h3 id="第二步：添加一个Hypervisor"><a href="#第二步：添加一个Hypervisor" class="headerlink" title="第二步：添加一个Hypervisor"></a>第二步：添加一个Hypervisor</h3><p>Hypervisor，也称为虚拟机器监视器或 VMM，是创建和运行虚拟计算机 （VM） 的软件。</p>
<p>按照下图添加你的esxi或者vCenter：</p>
<img src="synology-backup-2.png" width="80%">

<p>添加完成之后，就可以在界面上看到Esxi或者vCenter的机器了，如下图所示。</p>
<img src="synology-backup-3.png" width="80%">

<h3 id="第三步：创建备份任务"><a href="#第三步：创建备份任务" class="headerlink" title="第三步：创建备份任务"></a>第三步：创建备份任务</h3><img src="synology-backup-4.png" width="80%">

<p>在创建过程中，我们通常会指定一个备份名称（上图中是vSphere-Task-1）， 然后可以选择是备份一台虚拟机还是多台虚拟机（上图中选中了openvpn-access-server），然后点击<em>下一步</em>。</p>
<img src="synology-backup-5.png" width="80%">

<p>在列表中，选中一个共享文件夹用来存放备份数据。安装套件的时候会默认创建一个叫ActiveBackupforBusiness的共享文件夹。然后点击<em>下一步</em>。</p>
<img src="synology-backup-6.png" width="80%">

<p>继续点击<em>下一步</em>。</p>
<img src="synology-backup-7.png" width="80%">

<p>在这一步中是配置<em>备份任务</em>。可以使用默认配置，或者根据自己需求配置。然后点击<em>下一步</em>。</p>
<img src="synology-backup-8.png" width="80%">

<p>这是一个检查页面，没问题就直接点击<em>下一步</em>。</p>
<img src="synology-backup-9.png" width="80%">

<p>这一步就是很重要的一步，默认情况下是手动备份。这里推荐使用定时备份，这就不需要人为干预了。这样的备份也就更有意义了。然后<em>下一步</em>。</p>
<img src="synology-backup-10.png" width="80%">

<p>这一块儿是设置保留策略，推荐使用。可以根据自己的情况进行选择，然后<em>下一步</em>。</p>
<img src="synology-backup-11.png" width="80%">

<p>这一块儿是设置恢复权限，然后<em>下一步</em>。</p>
<img src="synology-backup-13.png" width="80%">

<p>整个备份任务的总结，检查一下，没有问题就点击<em>完成</em>。这时候会有弹窗弹出，讯问是否现在备份，可根据自己的实际情况进行选择。</p>
<img src="synology-backup-14.png" width="80%">

<p>到任务列表中，我们就可以看到刚才创建的备份任务以及上一次备份状态和下一次备份时间。</p>
<h3 id="第四步：备份"><a href="#第四步：备份" class="headerlink" title="第四步：备份"></a>第四步：备份</h3><p>定时备份任务会定时被触发，而手动备份就需要自己手动触发。</p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><img src="synology-restore-1.png" width="80%">

<p>在虚拟机列表中选中已经备份了的虚拟机，然后点击<em>恢复</em></p>
<img src="synology-restore-2.png" width="80%">

<p>从版本列表中选择一个备份版本，然后<em>下一步</em>。</p>
<img src="synology-restore-3.png" width="80%">

<p>选择恢复到VMware vSphere，然后<em>下一步</em></p>
<img src="synology-restore-4.png" width="80%">

<p>选择快速恢复还是完全恢复。</p>
<p>快速恢复：将NAS的磁盘挂载到Esxi上作为Datastore。</p>
<p>完全恢复：将备份数据复制到Esxi的Datastore中。</p>
<p>根据自己的实际情况选择，然后<em>下一步</em>。</p>
<img src="synology-restore-5.png" width="80%">

<p>选择虚拟机恢复到哪里，支持原路径恢复，也可以更改到新的位置。然后<em>下一步</em>。</p>
<img src="synology-restore-6.png" width="80%">

<p>检查一下，没有问题就点击<em>完成</em>，开始恢复。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Homelab环境中，利用NAS对数据备份可以有效地保证数据安全。</p>
<p>重要的数据一定要多备份。</p>
]]></content>
      <categories>
        <category>Homelab</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
        <tag>群晖</tag>
        <tag>Synology</tag>
        <tag>Active Backup for Business</tag>
        <tag>Esxi</tag>
        <tag>vSphere</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是DevOps</title>
    <url>/2021/10/18/what-is-devops/</url>
    <content><![CDATA[<p>DevOps是什么？在不同的组织会给出不同的解释，目前也没有一个通用的定义。总结一下，如下。</p>
<p>DevOps 是一系列<strong>文化理念</strong>、<strong>实践</strong>和<strong>工具</strong>的集合。其目的是：</p>
<ol>
<li>提高组织<strong>高速的可靠的交付能力。</strong></li>
<li>提升组织内部<strong>沟通和协作。敏捷软件开发实践</strong>打破了BA（需求分析）、QA（测试）和Dev（开发）之间的“墙”，使得三者之间信息互通，对于同一个需求理解是一致的。DevOps则是打破了Dev(开发)和Ops之间的“墙”，使得软件开发、部署、维护之间形成一条流动的通道。</li>
</ol>
<span id="more"></span>

<h2 id="文化理念"><a href="#文化理念" class="headerlink" title="文化理念"></a>文化理念</h2><p>DevOps文化的核心目的打破团队（Dev和Ops）之间的“墙”，提高团队之间的透明度、沟通和协作。DevOps的核心理念可以理解为如下四点：</p>
<ol>
<li>共同承担责任（shared responsibilities）</li>
<li>反馈（Feedback）</li>
<li>自动化（Automation）</li>
<li>质量内建（Build quality in）</li>
</ol>
<h3 id="共同承担责任（shared-responsibilities）"><a href="#共同承担责任（shared-responsibilities）" class="headerlink" title="共同承担责任（shared responsibilities）"></a>共同承担责任（shared responsibilities）</h3><p>狭义上，Dev和Ops应当共同对产品的成败负责。在敏捷软件开发的实践前提下，团队中的所有角色（包括但不限于BA、Dev、QA、Ops）共同对产品的成败负责。在整个产品的生命周期内，团队应当共同承担维护系统的责任，确保可以更快<strong>可靠地交付产品。</strong></p>
<h3 id="反馈（Feedback）"><a href="#反馈（Feedback）" class="headerlink" title="反馈（Feedback）"></a>反馈（Feedback）</h3><p>反馈对于DevOps是非常重要的。通过反馈，我们可以不断地改进团队不同角色之间的协同工作方式以及系统。</p>
<p>反馈不仅仅包括团队角色之间的反馈，还应该包含系统与团队的反馈。比如：</p>
<ol>
<li>pipeline状态，应当及时地通知到团队，推动团队下一步的工作。</li>
<li>生产事故，监控到生产事故应当及时反馈给团队。当API Gateway短时间内出现大量5xx错误，我们应当及时处理，提高用户的满意度。</li>
<li>根据生产监控的各种指标来优化系统。</li>
</ol>
<p>在DevOps的实践过程中，我们要将反馈这个核心理念铭记于心。在增强反馈的过程中，也要注意不要过度，应当避免团队成员陷入过多工具和消息中。</p>
<h3 id="自动化（Automation）"><a href="#自动化（Automation）" class="headerlink" title="自动化（Automation）"></a>自动化（Automation）</h3><p>自动化是整个DevOps的基石，有助于团队协作。自动化测试、自动化部署等可以让团队各种关注于业务本身，减少人为错误的机会。自动化可以让团队更快、更可靠地构建、测试、发布产品。</p>
<p>在实践DevOps的过程中，我们应当尽可能地减少手动操作。实现自动化的过程中，我们需要不同角色之间的协作和沟通。建议有一套统一的自动化脚本来增强团队不同角色之间的协作，建立统一的上下文。</p>
<h3 id="质量内建（Build-quality-in）"><a href="#质量内建（Build-quality-in）" class="headerlink" title="质量内建（Build quality in）"></a>质量内建（Build quality in）</h3><p>质在开发过程中，要求软件生命周期之间参与的各个角色都需要实时的对软件的质量负责。确保软件在交付到下一环节前已经有了基础的质量保证。从而减少因为质量问题导致的返工，避免浪费大量人力成本。</p>
<p>为更快更可靠地交付应用和服务，在源头上对质量进行把控是必不可少的。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>DevOps的常见实践如下：</p>
<ol>
<li><a href="/2021/04/24/what-is-ci-cd/">CI/CD</a>： 持续集成、持续交付或持续部署。CI/CD是整个DevOps的基础，pipeline就是CI/CD的具象化。</li>
<li>持续测试（Continuous testing）</li>
<li>持续监控（Continuous Monitoring）</li>
<li>基础设施既代码（Infrastructure as Code，IaC）</li>
</ol>
<p>DevOps实践的具体解释，不在此文中赘述，为有另外的文章单独解释。</p>
<h2 id="常见工具"><a href="#常见工具" class="headerlink" title="常见工具"></a>常见工具</h2><p>协作工具：Jira, Mural, Slack, Microsoft Teams等</p>
<p>版本控制工具：Github, Gitlab, Bitbucket等</p>
<p>持续集成工具：Jenkins, TeamCity, Travis CI等</p>
<p>部署工具：Terraform, AWS CloudFormation, Ansible, Helm等</p>
<p>监控工具：Zabbix， AWS CloudWatch等</p>
<p>DevOps的工具极其种类非常多，上述不过是其一小部分。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="%5Bhttps://en.wikipedia.org/wiki/DevOps%5D(https://en.wikipedia.org/wiki/DevOps)">DevOps</a></li>
<li><a href="%5Bhttps://aws.amazon.com/devops/what-is-devops/%5D(https://aws.amazon.com/devops/what-is-devops/)">AWS-What is DevOps</a></li>
<li><a href="%5Bhttps://www.atlassian.com/devops%5D(https://www.atlassian.com/devops)">Atlassian - DevOps</a></li>
<li><a href="%5Bhttps://martinfowler.com/bliki/DevOpsCulture.html%5D(https://martinfowler.com/bliki/DevOpsCulture.html)">Martin Fowler- DevOps Culture</a></li>
</ol>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>小米智能家居体验</title>
    <url>/2021/06/21/homelab-xiaomi-smarthome/</url>
    <content><![CDATA[<p>很早就想写一篇这样东西来分享一下自己简单的家庭网络，但是一直懒得写。现在(2021-06-20 03:20:00)有点失眠,就开个头,不知道啥时候能写完,随缘吧。写到后面（2021年6月21日２２：００），果然写偏了，干脆改成小米智能家居体验了。</p>
<span id="more"></span>

<h2 id="场景＆体验"><a href="#场景＆体验" class="headerlink" title="场景＆体验"></a>场景＆体验</h2><p>租住的地方是一个一室一厅带厨房和阳台的回迁房，这也基本上就是我的活动范围。白天不是在沙发上窝着，就是书桌前坐着，晚上当然是躺床上了。</p>
<p>先从最简单的地方说起，卧室。卧室里面最主要的两个东西，空调和床。这个空调是一个我之前从未听说过的品牌—志高，当然也有点老旧了，也自然是不可能联网的。成都的夏天还是比较热的，在客厅书桌前干活的我感觉到了热了之后，需要回到卧室找到遥控器打开空调，略微有点麻烦，也容易打断自己的思路。</p>
<p>这个时候就需要引入一个设备—<strong>米家空调伴侣2</strong>。这个小东西可以将普通空调智能化，说人话，就是遥控器可以做的事情它都可以做，还不需要你在它面前操作。你把它插在空调插座上，再把空调插头插在它身上，让它蹭上你家WiFi，然后就可以通过<strong>米家APP</strong>操作空调了。这是第一步，我们可以把遥控器扔到某个不用的角落里面了。</p>
<p>在炎热的夏天，我在电脑前面敲着键盘，码着字，机柜里面几台服务器呼呼地跑着，温度逐渐上升，感受到了温度的残忍，于是我拿出手机，通过<strong>米家APP</strong>将空调打开并调至１６度，慢慢感觉到了一丝凉爽。简而言之，当我坐在书桌前且周围的温度让我感到炎热时，开启空调，调整为制冷模式，设定温度为16度。如果我知道具体温度是多少，我就可以将“<strong>让我感到炎热时</strong>”量化为一个具体数值。因此我们需要一个传感器来测量温度－－－<strong>小米温湿度传感器</strong>。再来一个<strong>小米人体传感器</strong>来检测是否有人移动，这个比较鸡肋，一分钟检测一次，假设第一分钟检测到了你，然后你保持不动，那么后续就不会检测到有人移动。然后在米家APP中添加一条智能：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">同时满足　小米人体传感器有人移动　和　小米温湿度传感器温度高于30度时　执行开启空调到指定状态</span><br></pre></td></tr></table></figure>

<p>添加之后需要一段时间之后才会生效，大概几分钟吧，没有具体测试。当你感受到炎热时，站起来再坐下就可以触发上述规则了。有点智障了。。。。人体传感器就不能判断有没有人吗？</p>
<p>有一段时间，尝试着不把手机带入卧室，这个时候就需要一个闹钟叫醒我起床，还有如果半夜醒来了看个时间。小爱触屏音响就完美的满足了我的需求，在工作日和非工作日可以在不同的时间叫醒我。懒到极致的我，在之前总是被迫起床关灯以及抹黑找床（经常撞伤），因为卧室只有一个开关且在门口，直到有一天看到<strong>米家床头灯２代</strong>，及时购入。之后的生活就是进卧室时，“小爱同学，开灯”，躺下睡觉时，“小爱同学，关灯”。</p>
<p>一朝被盗，终身防贼。２０１8年９月７日凌晨（具体我也不知道），在我回成都的第三个月，我家被入室盗窃了，当天报案，至今没有结果，估摸着没有结果了。当天入手了门窗传感器，人体传感器，小米摄像头等，所有有可能的进入的家里的窗户和门都安装了门窗传感器，阳台安装了小米摄像头和红外传感器。同时小米摄像头的数据也会传输到NAS中，多NAS备份，异地备份。租房的一个小Tips，不要租低楼层的，临街的以及外面有可能进入的。</p>
<p>一个人住总是怕钥匙忘带或者不小心把钥匙丢了，没有备份就没有安全感。<strong>小米智能门锁</strong>完美解决了这个问题。并且在我回家的时候，可以自动触发关闭摄像头并开启<strong>小米网关</strong>在家模式。</p>
<h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>使用过程中，有哪些痛点？</p>
<p>１.　我会经常更换自己家里的WiFi密码，看心情可能一周一换，也可能一月一换。在更新的过程中，需要把这些智能家居设备重新联网，工作量巨大。</p>
<p>２.　上述的那个问题，小米给出了解决方案，使用小米路由器的一个新功能畅快连。经过本人试验，并没有什么用途，因为我家所有的设备的最新固件都不支持。并且小米路由器对于我不适用，重度网络使用者很容易就感受到了断流的痛。</p>
<p>３.　米家APP在设备多的时候，极其难用。没有一个很好的控制中心。未来打算尝试一下Home Assistant，自己收集数据，自己做dashboard，不让数据离开局域网。</p>
<p>４.　如果你的小米网关坏掉了，那我只能表示恭喜你了。你需要重新添加设备，然后重新命名极其麻烦的过程。</p>
<p>５.　核心模块（比如小米网关）不是高可用的。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在这个野蛮的互联网时代，谁又不是在裸奔呢？</p>
<p>如果不是一个公众人物，选择一个某个智能家居平台的时候，只需要问自己信任与否。在使用的过程中，尽量减少对云存储的使用，在家的时候尽量关闭摄像头等等。没有什么事比健康安全地活着更重要。</p>
<p>如果你是一个公众人物，能不用就不用，攻击你的收益远远高于成本。</p>
]]></content>
      <categories>
        <category>Homelab</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
        <tag>小米</tag>
        <tag>智能家居</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps的实践经验</title>
    <url>/2021/05/31/some-devops-practices/</url>
    <content><![CDATA[<p>这又是一番偏执的胡言乱语。做DevOps两年以来，见过好的实践，也见过糟糕的实践。每一个对DevOps实践都有不同的认识，在这篇博客，我只是聊聊自己的观点，如有不对敬请指正。</p>
<p>大致而言，我会遵循三个原则：</p>
<ol>
<li>零手动操作。</li>
<li>干净：童子军军规。</li>
<li>简单：奥卡姆剃刀。</li>
</ol>
<span id="more"></span>

<h2 id="零手动操作"><a href="#零手动操作" class="headerlink" title="零手动操作"></a>零手动操作</h2><p>什么是手动操作？任何没有被代码化（as code）的资源或者操作都可以被认为是手动操作。</p>
<p>常见的手动操作：</p>
<ul>
<li>基础设施没有代码化，存在资源是没有被代码管理，或者部分操作没有被管理。</li>
<li>应用部署流程需要手动干预。</li>
<li>应用配置需要手动指定等。</li>
</ul>
<h3 id="真的要手动操作？"><a href="#真的要手动操作？" class="headerlink" title="真的要手动操作？"></a>真的要手动操作？</h3><p>当你需要做任何手动操作之前，先问自己一系列问题：</p>
<ol>
<li>该操作是否以及被代码化（as code），如果是，那就执行代码。不要把自己的代码遗落在角落里。如果没有，继续下一个问题。</li>
<li>该操作是否紧急？如果紧急，那么可以临时手动操作，但是需要多个人一起以及严格的流程。之后，需要将该操作代码化。如果你不想代码化，那么看看下面一系列问题？</li>
<li>该操作在后续是否还有发生的机率？如果有，就需要代码化。如果你依然不愿意，继续下一个问题。</li>
<li>如何确保在下一次执行（可能间隔一周，也可能是间隔一个月）的时候完全重复当前操作？任何手动操作都是不可被追溯的，不可完全被重复的。如果确保不了，那就需要代码化。如果能确保，那你就是神，我只能表示膜拜。</li>
<li>我们有完备的文档，还需要代码化吗？代码比文档可靠，优雅的代码可读性远高于文档。</li>
</ol>
<h3 id="避免手动操作的实践"><a href="#避免手动操作的实践" class="headerlink" title="避免手动操作的实践"></a>避免手动操作的实践</h3><ol>
<li>基础设施即代码（IaC，Infrastructure as code）</li>
<li>CI/CD</li>
<li>自动化脚本（Automation script）</li>
<li>GitOps</li>
</ol>
<h2 id="干净：童子军军规"><a href="#干净：童子军军规" class="headerlink" title="干净：童子军军规"></a>干净：童子军军规</h2><blockquote>
<p>The Boy Scout Rule: Always leave the campground cleaner than you found it.</p>
</blockquote>
<p>干净，可以从两方面说，<strong>代码整洁</strong>和<strong>环境干净</strong>。童子军军规：让营地比你来时更干净。这是一条非常适用的规则。</p>
<h3 id="代码整洁"><a href="#代码整洁" class="headerlink" title="代码整洁"></a><strong>代码整洁</strong></h3><p>代码整洁中的“代码”不仅仅指业务代码，还应当包含测试代码，基础设施代码等一切代码。我见过一些业务代码很整洁，非业务代码很糟糕的项目，为什么会这样呢？我大胆地猜测一下，团队没有把基础设施代码当成代码，而是在战略上忽视了它。</p>
<p>所有的代码享有平等的地位。无论是否是业务代码，在应用的生命周期中，我们都需要去维护。</p>
<p>关于这部分的内容，<strong>强烈推荐学习一下《代码整洁之道》和《重构》</strong>。</p>
<h3 id="环境干净"><a href="#环境干净" class="headerlink" title="环境干净"></a>环境干净</h3><p>在开发阶段，保持开发环境的干净。</p>
<p>在CI/CD 环境中，保持构建、测试、部署环境干净。通常而言，一个CI/CD 的Agent会被不止一个应用使用，因此保持环境的干净就显得尤为重要。</p>
<p>在生产环境中，保持运行环境干净。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ol>
<li>TDD</li>
<li>Simple Design</li>
<li>容器化</li>
<li>Code Diff</li>
</ol>
<h2 id="简单：奥卡姆剃刀原理"><a href="#简单：奥卡姆剃刀原理" class="headerlink" title="简单：奥卡姆剃刀原理"></a>简单：奥卡姆剃刀原理</h2><blockquote>
<p>Entities should not be multiplied unnecessarily</p>
</blockquote>
<p>在写这篇的博客的时候，我也一直在纠结是不是要把干净和简单合并在一起写。在提到干净的时候，它和脏是对立的，往往是指代码是否整洁。而简单和复杂是相对应的，通常是和业务，架构，技术栈等相关的。</p>
<p>业务复杂与否是来自于功能需求，这一块儿没有深入研究过，暂且不谈。</p>
<p>架构和技术栈的复杂度来自于非功能性需求。一个项目总会有人员的变动，在人员变动的过程中，复杂的东西在传递的过程中很容易失真。在引入一项新的技术或者语言时，需要仔细考虑是否真的需要，如果不是必须的就不要引入。简而言之，遵循奥卡姆剃刀原理：如无必要，勿增实体(Entities should not be multiplied unnecessarily)。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>实践</tag>
        <tag>Best Practices</tag>
        <tag>零手动操作</tag>
        <tag>童子军军规</tag>
        <tag>奥卡姆剃刀</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么需要本地开发环境容器化？</title>
    <url>/2021/05/25/why-containerize-local-dev-env/</url>
    <content><![CDATA[<p>一个线上运行的应用，最开始都是在软件工程师的电脑里面开发的。因此，软件工程师的电脑里面会有一个本地的开发环境，用于IDE以及本地测试。</p>
<span id="more"></span>

<h2 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h2><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p>如果项目是一个大型的单体应用，通常而言会有前端和后端开发工程师，以后端开发工程师为例，在后端开发工程师的电脑中会装有以下环境：</p>
<ul>
<li>语言的运行环境，比如JDK，Node.js等。</li>
<li>数据库，比如MySQL，PostgreSQL。</li>
<li>其他奇奇怪怪的东西。</li>
</ul>
<p>如果该项目只有一个后端开发工程师，可能会有以下问题：</p>
<ul>
<li>线上运行环境与本地不一致，进而导致凭啥我本地都是好的，上线就遇到各种奇奇怪怪的问题。</li>
<li>更换电脑之后，需要再次手动安装运行环境。</li>
<li>操作系统升级可能会破坏已有运行环境。</li>
</ul>
<p>如果该项目有多个后端开发工程师，在基于一个后端开发工程师可能会遇到的问题的基础上，可能还会遇到如下问题：</p>
<ul>
<li>工程师之间的操作系统版本不一样，通常不会遇到什么问题，遇到了那就呵呵哒。</li>
<li>工程师之间的运行环境可能不一致，有可能是patch版本的差异，也可能minor版本的差异。</li>
<li>重复的工作会被不同的人干很多次。</li>
<li>上新人的成本高昂，需要事无巨细地指导。</li>
<li>即使有一份完备的环境配置文档，也会出现手动配置错误。不要相信任何的手动操作，任何的手动操作都是不可靠的，无论操作者的水平多高或者多低。</li>
</ul>
<p>如果该项目上线之后，转移给另外的一个运维团队去维护，可能会遇到如下问题：</p>
<ul>
<li>这东西怎么在本地启动？虽然有文档存在，但是在开发工程中仍然会有很多隐性的上下文。</li>
<li>本地测试怎么跑？</li>
<li>运维团队的工程师需要在本地安装无数的运行环境。</li>
</ul>
<h3 id="微服务应用"><a href="#微服务应用" class="headerlink" title="微服务应用"></a>微服务应用</h3><p>如果微服务应用是一个团队开发的，那么可能会遇到如下问题：</p>
<ul>
<li>工程师之间的运行环境可能不一致。</li>
<li>服务之间的运行环境不一样，本地环境需要配置多个不同版本的环境。</li>
</ul>
<p>如果是微服务应用多个团队开发的，基于上面情况遇到问题，可能还会出现如下问题：</p>
<ul>
<li>技术栈不一样，比如A团队使用Golang，B团队使用Java，C团队使用Node.js。</li>
<li>代码风格不一致。</li>
</ul>
<p>如果之后转移给一个独立的运维团队维护，会遇到如下问题：</p>
<ul>
<li>技术栈的多样性，导致运维团队学习成本居高不下。</li>
<li>技术栈的多样性，同样会增加保持本地环境与线上环境的一致性的难度。</li>
<li>代码风格的不一致，运维在修复一个bug的时候，可能会不停地切换技术栈和代码风格，甚至同一个技术栈的不同版本，运维团队的体验度会不断下降。</li>
</ul>
<p>可能还有诸多问题是我所未考虑到的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大致总结一下上述问题：</p>
<ul>
<li>运行环境不一样，工程师之间的本地环境不一样，本地开发环境和线上运行环境不一样。</li>
<li>技术栈的多样性，进而引入的隐性context。</li>
<li>代码风格不一致</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>基于上面的诸多问题，只能对一些问题提供解决一些解决思路。</p>
<h3 id="运行环境的不一致"><a href="#运行环境的不一致" class="headerlink" title="运行环境的不一致"></a>运行环境的不一致</h3><p>在所有的问题中，运行环境不一样是最普遍也是做容易解决的一个问题。在这一类问题中，最简单的解决方案就是容器化。</p>
<p>需要做到两个容器化：</p>
<ul>
<li>本地开发环境容器化。</li>
<li>线上运行环境容器化。</li>
</ul>
<p>我相信绝大多数团队都可以做到线上运行环境的容器化，因为这并不是一件很难的事情。而本地开发环境的容器化确实最容易被忽略的。</p>
<p>本地开发环境的容器化，可以很好地确保开发工程师之间的环境一致以及开发环境和线上环境的一致。同时，也可以很好地解决不同服务之间所采用的运行环境版版本不一致而导致开发出现的各种奇奇怪怪的问题。</p>
<h3 id="技术栈的多样性"><a href="#技术栈的多样性" class="headerlink" title="技术栈的多样性"></a>技术栈的多样性</h3><p>技术栈的多样性是我们所推崇和所追求的，其本身并不是问题，但是技术栈的多样性不可避免的会引入一定的副作用。而隐性上下文就是其中最明显的而又不容易被关注的。</p>
<p>什么是隐性上下文？简单举个例子，</p>
<ul>
<li>A团队使用 <code>node.js</code> 开发，使用 <code>npm</code> 对包进行管理，可能会把单元测试脚本命令放在 <code>package.json</code> 中，也可能不会。</li>
<li>B团队同样使用 <code>node.js</code> 开发，但是使用 <code>yarn</code> 进行包管理，同样单元测试脚本可能放到 <code>package.json</code> , 也可能不会。</li>
<li>C团队使用 <code>Java</code> 开发，使用 <code>gradle</code> 进行包管理。</li>
<li>D团队使用 <code>Kotlin</code> 开发，使用 <code>maven</code> 进行包管理。</li>
</ul>
<p>对于A团队而言，A团队知道如何把自己团队的本地环境运行起来，如何运行单元测试，可能会忘记这些内容写入到readme中或者package.json中。突然有一天，B团队的成员需要去更改一个A团队的实现，这个时候基于B团队的成员使用的技术栈而言，虽然会花点时间去阅读代码，或者基于已有的技术背景做出一些探索性的尝试，也是比较容易了解到如何本地启动A团队的服务，如何进行单元测试。</p>
<p>如果是C团队的程序需要更改A团队的一个实现，那么会是如何的呢？</p>
<p>如果有一天这个微服务应用完全交给了一个独立的运维团队运维，那么又会是什么样的呢？</p>
<p><strong>这一类团队内部默认都知道的，没有通过脚本或者文档呈现出来的上下文可以被理解为隐性上下文。</strong></p>
<p>如何解决隐性上下文？基于本地开发环境容器化的基础上，自动化脚本是一个比较好的实践方案。比如在每个服务代码库中，都写一个 <code>auto/test</code> 脚本，这脚本是负责跑单元测试，这样在不同团队之间是否会更好的管理这些隐性上下文？再比如代码风格检查也可以有一个脚本叫做 <code>auto/check-style</code> 。</p>
<h3 id="代码风格不一致"><a href="#代码风格不一致" class="headerlink" title="代码风格不一致"></a>代码风格不一致</h3><p>服务与服务之间的代码风格不一致，这是正常的，不同的技术栈必然会导致风格不一致。</p>
<p>那什么是问题？</p>
<ul>
<li>服务内部的代码风格不一致。</li>
<li>服务之间的代码风格不一致，但没有一个强有力的约束工具。</li>
</ul>
<p>如何解决？我们所遵循的所有代码风格都应该被工具管理起来，都可以配置化。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>上述几个问题，解决方案就是 本地开发环境容器化以及自动化脚本。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>开发环境</tag>
        <tag>容器化</tag>
        <tag>自动化脚本</tag>
        <tag>隐性上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是CI/CD</title>
    <url>/2021/04/24/what-is-ci-cd/</url>
    <content><![CDATA[<p>CI/CD是一种持续软件开发的方法论，通过自动化脚本将软件开发过程中引入错误的可能性降到最小。从一个新功能的开发到其被部署到生产环境的过程中，尽可能地减少人工干预甚至没有人工干预。</p>
<p>CI/CD中涉及到三个概念：持续集成（Continuous Integration）、持续交付（Continuous Delivery）、持续部署（Continuous Deployment）。</p>
<span id="more"></span>

<h2 id="持续集成（Continuous-Integration）"><a href="#持续集成（Continuous-Integration）" class="headerlink" title="持续集成（Continuous Integration）"></a>持续集成（Continuous Integration）</h2><p>持续集成是指代码push到代码库后，通过运行构建和测试的过程来减少引入错误的可能，这个过程是自动被触发的。持续集成并不会消除bug，但是能够让我们更加容易地发现和修复bug。</p>
<p>持续集成主要运行构建、单元测试以及代码风格检查等这一类运行较快的测试和验证。</p>
<p>持续集成会运行在开发分支和master分支上，通常情况下，在开发分支上通过了持续集成的代码才能被合并到master分支。</p>
<h2 id="持续交付（Continuous-Delivery）"><a href="#持续交付（Continuous-Delivery）" class="headerlink" title="持续交付（Continuous Delivery）"></a>持续交付（Continuous Delivery）</h2><p>持续交付是持续集成的扩展，确保可以以一种可持续的方式将新的变更快速发布到生成环境。持续交付主要是确保应用可部署，可以随时发布到生产环境。</p>
<p>持续交付相比较持续集成，增加了验收测试，自动部署到staging环境等。可能会在staging环境做一些人工验证工作，验证工作完成之后再部署到生产环境。</p>
<p>持续交付主要运行在master分支，但是验收测试有时也会在开发分支上运行。</p>
<h2 id="持续部署（Continuous-Deployment）"><a href="#持续部署（Continuous-Deployment）" class="headerlink" title="持续部署（Continuous Deployment）"></a>持续部署（Continuous Deployment）</h2><p>持续部署也是基于持续集成的，与持续交付相似，比持续交付更进一步。持续部署会将每一个主线上的改变自动部署到生产环境。</p>
<p>相较于持续交付，它需要更加完备的测试。</p>
<p><img src="ci-cd.png" alt="ci/cd"><br>图片来源：<a href="http://www.atlassian.com/">www.atlassian.com</a></p>
<h2 id="CI-CD带来了什么好处"><a href="#CI-CD带来了什么好处" class="headerlink" title="CI/CD带来了什么好处"></a>CI/CD带来了什么好处</h2><p>下面将列举一些引入CI/CD带来的好处。</p>
<ul>
<li><p>频繁部署: CI/CD会加速应用构建和部署过程。能够帮助我们一天多次部署。</p>
</li>
<li><p>降低风险：通过不断发布尽可能小的功能，可以减少生产出现Bug的风险。同时也会让QA和客户对于发布不会感到很痛苦。</p>
</li>
<li><p>降低成本：引入CI/CD意味着需要覆盖更全的单元测试，更加完善的验收测试，看起来是引入更多的工作量。其实不尽然，没有很好的单元测试和验收测试，意味需要花费大量的时间去手工测试，同时有可能导致已有功能被破坏。当出现bug的时候（bug一定会出现的），没有测试，就意味着可能需要大量去查找和修复问题。</p>
</li>
<li><p>提高质量：通过一系列可靠的测试，可以及时地发现和修复bug。</p>
</li>
<li><p>提高团队协作：通过一系列的测试，能够帮助我们确认，我们的改动没有破坏到已有功能。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Continuous Integration</tag>
        <tag>Continuous Delivery</tag>
        <tag>Continuous Deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>[长期更新] WSL使用记录</title>
    <url>/2021/04/24/long-term-wsl/</url>
    <content><![CDATA[<p>这是一篇长期更新的博客，主要记录我在使用<code>WSL</code>期间踩过的坑，小工具，优化等等。</p>
<span id="more"></span>

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="文件权限问题"><a href="#文件权限问题" class="headerlink" title="文件权限问题"></a>文件权限问题</h3><p>在WSL中挂载Windows的磁盘时，文件的权限会变成777，在<code>ls</code>的时候会发现绿油油的一片。</p>
<p>第一步：执行<code>sudo vim /etc/wsl.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[automount]</span><br><span class="line">enabled &#x3D; true</span><br><span class="line">root &#x3D; &#x2F;</span><br><span class="line">options &#x3D; &quot;metadata,umask&#x3D;22,fmask&#x3D;11&quot;</span><br><span class="line">mountFsTab &#x3D; false</span><br></pre></td></tr></table></figure>
<p>第二步：重启wsl</p>
<p>对于WSL2可以在PowerShell或者CMD中执行<code>wsl --shutdown</code><br>对于WSL1可以以管理员身份在PowerShell或者CMD中，执行<code>net stop LxssManager</code>和<code>net start LxssManager</code></p>
<p>更多WSL的配置参考<a href="https://docs.microsoft.com/en-us/windows/wsl/wsl-config">wsl-config</a></p>
<h3 id="磁盘问题"><a href="#磁盘问题" class="headerlink" title="磁盘问题"></a>磁盘问题</h3><p>如果在WSL中遇到了 <code>Error: EPERM: operation not permitted, symlink</code> 或者说和<code>symlin</code> 有关的错误的时候，可以先检查一个磁盘的格式是否是NTFS或者ReFS 。</p>
<p>更多内容，请阅读<a href="/2021/01/01/wls-symlink/">WSL踩坑之硬盘格式问题</a></p>
<h3 id="时间同步问题"><a href="#时间同步问题" class="headerlink" title="时间同步问题"></a>时间同步问题</h3><p>在使用<code>WSL</code>的过程中，有时候会出现时间同步问题，通常是<code>WSL</code>时间比<code>Windows 10</code>的时间晚。</p>
<p><strong>如何解决？</strong></p>
<p>如果是Ubuntu的话，可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ntpdate</span><br><span class="line">sudo ntpdate time.windows.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Long Term</category>
        <category>Windows</category>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>Windows 10</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>[长期更新] Windows 10/Windows 11工具推荐</title>
    <url>/2021/04/04/long-term-windows-tools/</url>
    <content><![CDATA[<p>这篇博客主要记录我在Windows 10上使用的一些有提升效率或者花里胡哨的工具，会一直更新下去。毕竟是个软粉嘛。</p>
<span id="more"></span>

<h2 id="通用工具"><a href="#通用工具" class="headerlink" title="通用工具"></a>通用工具</h2><h3 id="Microsoft-PowerToys"><a href="#Microsoft-PowerToys" class="headerlink" title="Microsoft PowerToys"></a>Microsoft PowerToys</h3><p>Microsoft PowerToys是一组小工具，用户可以利用该工具调整和简化其Windows 10体验，以提高工作效率。 </p>
<p><img src="power-toys.png" alt="power-toys.png"></p>
<p>目前支持的功能：</p>
<ul>
<li>Color Picker: 一个抓取颜色的小工具。快捷键：<code>Win + Shift + C</code>。没咋使用过，我对这个工具没啥需求。</li>
<li>FancyZones: Windows窗口管理工具，可以更加流畅高效地管理窗口布局。没用过。</li>
<li>File Explorer Add-ons: 增强文件管理器的预览功能，增加了对Markdown，SVG的预览支持。</li>
<li>Image Resizer: 图片大小调整工具。在图片上“右键”-&gt;“Resize Pictures”就能生成特定大小的图片。</li>
<li>Keyboard Manager: 快捷键管理工具。</li>
<li>PowerRename: 一个强大的文件重命名工具。在文件管理器中，选中多个文件就可以对多个文件按照指定规则重命名，选中文件夹可以递归重命名下面的文件。</li>
<li>PowerToys Run: 这是我最常用的一个工具之一，这是非常强大的工具。之后有空的话，单独开一篇聊聊这个工具。快捷键<code>Alt + Space</code></li>
<li>Shortcut Guide: 当长按 <code>Windows</code>键时，可以给你一些快捷键的提示。</li>
</ul>
<p>下载地址：<a href="https://github.com/microsoft/PowerToys/releases/">https://github.com/microsoft/PowerToys/releases/</a></p>
<h3 id="snipaste：一款强大的截图工具"><a href="#snipaste：一款强大的截图工具" class="headerlink" title="snipaste：一款强大的截图工具"></a>snipaste：一款强大的截图工具</h3><p>方案一：Windows 自带的 <code>Snip &amp; Sketch</code> 和 <code>Print Screen</code>。<code>Snip &amp; Sketch</code>可以使用快捷键 <code>Win + Shift + S</code>,如果截图使用不多的话，可以使用该工具。</p>
<p>方案二：一个第三方工具snipaste，很强大的一个截图工具，易用性高于Windows 10 自带的工具。下载地址：<a href="https://www.snipaste.com/">https://www.snipaste.com/</a></p>
<p><img src="snipaste.png" alt="snipaste.png"></p>
<h3 id="Bandizip：-解压工具"><a href="#Bandizip：-解压工具" class="headerlink" title="Bandizip： 解压工具"></a>Bandizip： 解压工具</h3><p>这是目前我自己最喜欢用的一款解压工具，没有发现明显的痛点。最开始使用的时候，该工具免费版本还没有内嵌广告，现在已经有广告了。</p>
<p><img src="bandizip.png" alt="bandizip.png"></p>
<p>下载地址：<a href="https://en.bandisoft.com/bandizip/">https://en.bandisoft.com/bandizip/</a></p>
<h3 id="EasySwitch：窗口切换工具"><a href="#EasySwitch：窗口切换工具" class="headerlink" title="EasySwitch：窗口切换工具"></a>EasySwitch：窗口切换工具</h3><p>虽然在<code>Windows 10</code>上可以使用<code>Alt + Tab</code>切换窗口，但是这个快捷键是跨多个应用的。于我而言，很多时候需要的是在同一个应用之间切换，比如多个Microsoft Word之间切换。</p>
<p>如果需要在多个应用之间切换窗口，可以使用<code>Alt + Tab</code>。</p>
<p>如果需要在同一个应用直接切换窗口可以使用<code>EasySwitch</code>，快捷键 <code>Alt + `</code></p>
<p>下载地址： <a href="https://neosmart.net/EasySwitch/">https://neosmart.net/EasySwitch/</a></p>
<h2 id="美化工具"><a href="#美化工具" class="headerlink" title="美化工具"></a>美化工具</h2><h3 id="动态壁纸工具：-WinDynamicDesktop"><a href="#动态壁纸工具：-WinDynamicDesktop" class="headerlink" title="动态壁纸工具： WinDynamicDesktop"></a>动态壁纸工具： WinDynamicDesktop</h3><p>该工具在Windows 10 上实现了macOS Mojave的动态壁纸功能。</p>
<p><img src="win-dynamical-desktop.png" alt="win-dynamical-desktop.png"></p>
<p>下载地址：<a href="https://github.com/t1m0thyj/WinDynamicDesktop">https://github.com/t1m0thyj/WinDynamicDesktop</a></p>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>Visual Studio Code，一个很强大的IDE。</p>
<p><img src="code.png" alt="code.png"></p>
<p>下载地址：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
<h3 id="Hosts管理工具：Hozz"><a href="#Hosts管理工具：Hozz" class="headerlink" title="Hosts管理工具：Hozz"></a>Hosts管理工具：Hozz</h3><p>我有一个小小的内网，里面有很多的服务，目前阶段没有时间做DNS服务器，所以就需要一个随时切换Hosts，因此一款够用的Hosts工具就显得很重要。</p>
<p>Hozz就是这样一款工具，可以帮助我更快捷地访问自己服务。</p>
<p>下载地址：<a href="https://blog.zhangruipeng.me/Hozz/">https://blog.zhangruipeng.me/Hozz/</a></p>
]]></content>
      <categories>
        <category>Long Term</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows 10</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>给Asus AX86U加个监控</title>
    <url>/2021/03/28/monitor-your-router/</url>
    <content><![CDATA[<p>使用Node Exporter + Prometheus + Grafana给Asus AX86U加个监控。弄这一套的目的有两个，第一是了解一下Prometheus是如何工作的，第二也是尝试将家里的网络设备监控起来。</p>
<span id="more"></span>

<p>Node Exporter: 一个用来收集 Linux/UNIX 硬件和OS metric的工具，并将收集到metric通过HTTP的方式暴露出来。<br>Prometheus: 开源的系统监视和警报工具。<br>Grafana: 查询，可视化metric并记录警报。</p>
<h2 id="安装Node-Exporter"><a href="#安装Node-Exporter" class="headerlink" title="安装Node Exporter"></a>安装Node Exporter</h2><p>Asus AX86U是ARMv8架构。亲测，可以使用ARMv7的的包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/prometheus/node_exporter/releases/download/v1.1.2/node_exporter-1.1.2.linux-armv7.tar.gz</span><br><span class="line">tar xzvf node_exporter-1.1.2.linux-armv7.tar.gz</span><br><span class="line">mkdir -p /jffs/bin/</span><br><span class="line">cp node_exporter-1.1.2.linux-armv7/node_exporter /jffs/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cru a \&quot;node_exporter\&quot; \&quot;*/1 * * * * ps | grep node_exporter | grep -v -q grep || /jffs/bin/node_exporter\&quot;&quot;</span> &gt;&gt; /jffs/scripts/services-start</span><br><span class="line"></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>当Node Exporter安装成功之后，访问路由器的9100端口. 如果你的路由器IP是<code>192.168.1.1</code>, 那么可以访问一下 <code>http://192.168.1.1:9100/metrics</code> 就可以得到类似下面的这样的结果。</p>
<p><img src="node-exporter.png" alt="Node Exporter"></p>
<p>看到这样的结果，就说明Node Exporter安装成功了。</p>
<p>需要说明的是，</p>
<ol>
<li>这里使用的包是直接拿的Linux的二进制包，所以会比较大，大约16M。可能对于JFFS空间不足的小伙伴儿，就比较难受了。</li>
<li>这里采集的Linux OS的数据，所以很多的信息对于路由器而言是大可不必的，而有些需要的又没有的。看之后有没有空，自己DIY一版。</li>
</ol>
<h2 id="安装Prometheus"><a href="#安装Prometheus" class="headerlink" title="安装Prometheus"></a>安装Prometheus</h2><p>在开始的时候，我本打算起一个VM用来专门跑Prometheus，但是后来想了一下大可不必。我最终的方案是在Synology DS216+II 上用容器跑了。</p>
<p>配置文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">api_version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> []</span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">honor_timestamps:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">metrics_path:</span> <span class="string">/metrics</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">localhost:9090</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">asuswrt</span></span><br><span class="line">  <span class="attr">honor_timestamps:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">metrics_path:</span> <span class="string">/metrics</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span><span class="string">:9100</span></span><br></pre></td></tr></table></figure>

<p><img src="prometheus.png" alt="Prometheus"></p>
<h2 id="安装Grafana"><a href="#安装Grafana" class="headerlink" title="安装Grafana"></a>安装Grafana</h2><p>使用了一个已经搭建好了的Grafana，来展示路由器的信息</p>
<p>下面是自己做的一个Dashboard。</p>
<p><img src="grafana.png" alt="Grafana"></p>
<p>如果不想自己做，可以使用以下现成的dashboard</p>
<p><a href="https://grafana.com/grafana/dashboards/13978">https://grafana.com/grafana/dashboards/13978</a></p>
<p><a href="https://grafana.com/grafana/dashboards/1860">https://grafana.com/grafana/dashboards/1860</a></p>
]]></content>
      <categories>
        <category>Homelab</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
        <tag>家庭网络</tag>
        <tag>监控</tag>
        <tag>Prometheus</tag>
        <tag>Node Exporter</tag>
        <tag>Grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps 起源</title>
    <url>/2021/03/22/devops-history/</url>
    <content><![CDATA[<p>当想更深入的理解一件事物时，我们可能需要去看看这个事物的前世今生。本文只是简单地梳理了DevOps的历史。</p>
<span id="more"></span>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><blockquote>
<p>2007年，比利时</p>
</blockquote>
<p>2007 年，Patrick Debois 受比利时政府部门的委托，协助数据中心迁移。在项目中他的角色是certification/readiness testing。因此，他需要跨开发团队和运维团队工作。这两个团队存在一堵隔离墙，采用了不同的工作方式，这使得在两个团队之间来回切换的Debois非常沮丧。</p>
<p><img src="patrick-debois.png" alt="Patrick Debois"></p>
<blockquote>
<p>2008年8月，加拿大多伦多，Agile Conference 2008</p>
</blockquote>
<p>2008年8月，在加拿大多伦多的 Agile Conference 2008（敏捷大会）上， Andrew Shafer 提交了一个名为“Agile Infrastructure”的临时话题。只有一个人出席了，这个人就是Patrick Debois。Andrew 和 Patrick 讨论和分享他们对“agile systems administration.”的想法和观点。并在 Google Group 上建立了一个 Agile System Adminstration  的讨论组继续这个话题。</p>
<p><img src="agile-conference-2008.png" alt="Agile Conference 2008"></p>
<blockquote>
<p>2009年6月，美国圣荷西，第二届 Velocity 大会</p>
</blockquote>
<p>2009年6月，两名 Flickr 员工 John Allspaw 和 Paul Hammond 分享了一个名为“10+ Deploys Per Day: Dev and Ops Cooperation at Flickr”的演讲。这个演讲的内容可以作为 DevOps 萌发的标志。他们认为，唯一合理的前进道路是使应用开发和运维无缝、透明和完全集成。</p>
<p>Patrick Debois 在网上看了这个视频后，他受到启发，以及其他人的鼓励下在比利时举办了“DevOpsDays“</p>
<p><img src="velocity.png" alt="Velocity"></p>
<blockquote>
<p>2009年10月，比利时根特，DevOpsDays</p>
</blockquote>
<p>Patrick Debois 模仿Velocity 大会在比利时举办了一个为期两天的”DevOpsDays”。人们从世界各地蜂拥而至，除了开发工程师和运维工程师，还有各种IT管理人员和工具爱好者。两天的会议已经结束后，参与 DevOpsDays 的人们把这次会议的内容带回到了世界各个角落。于是， DevOps 这个称谓正式诞生。</p>
<p><img src="DevOpsDays.png" alt="DevOpsDays"></p>
<blockquote>
<p>2010年， 德国汉堡，DevOpsDays</p>
</blockquote>
<p>2010 年，在德国汉堡举办了第二届DevOpsDays大会，《持续交付》的作者Jez Humble做了 “持续交付”的演讲。《持续交付》中所提到的实践给 Patrick 和 Andrew 最初所遇到的问题给出了最佳实践。</p>
<p><img src="cd.png" alt="持续交付"></p>
<blockquote>
<p>2013年，凤凰项目</p>
</blockquote>
<p>由Gene Kim，Kevin Behr，George Spafford共同完成《凤凰项目》发布。这是DevOps的一个标志性事件。</p>
<p><img src="phoenix.png" alt="凤凰项目"></p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li>10+ Deploys Per Day: Dev and Ops Cooperation at Flickr 演讲视频：<a href="https://www.bilibili.com/video/BV16K4y1S7Re">https://www.bilibili.com/video/BV16K4y1S7Re</a></li>
<li>DevOpsDays：<a href="https://devopsdays.org/">https://devopsdays.org</a></li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>History</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑备忘录---Nginx反向代理之server_name与ip</title>
    <url>/2021/03/07/nginx-proxy-ssl-server-name/</url>
    <content><![CDATA[<p>我们的系统依赖一个第三方的服务，该服务是通过IP限制访问权限的。出于安全考虑，我们的系统会校验证书，因此我们采用Nginx反向代理去访问该服务。该服务迁移到cloud上之后，我们系统出现了问题。</p>
<span id="more"></span>

<p>Nginx的配置文件如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend.example.com &#123;</span><br><span class="line">        server backend1.example.com:443;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen      80;</span><br><span class="line">        server_name www.example.com;</span><br><span class="line"></span><br><span class="line">        location /upstream &#123;</span><br><span class="line">            proxy_pass                    https://backend.example.com;</span><br><span class="line">            proxy_ssl_certificate         /etc/nginx/client.pem;</span><br><span class="line">            proxy_ssl_certificate_key     /etc/nginx/client.key;</span><br><span class="line">            proxy_ssl_protocols           TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">            proxy_ssl_ciphers             HIGH:!aNULL:!MD5;</span><br><span class="line">            proxy_ssl_trusted_certificate /etc/nginx/trusted_ca_cert.crt;</span><br><span class="line"></span><br><span class="line">            proxy_ssl_verify        on;</span><br><span class="line">            proxy_ssl_verify_depth  2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>在出现线上问题的时候，第一时间检查了配置文件的改动记录 ⇒ 配置文件没有改到。</p>
<p>接着检查了，证书是否过期⇒没有过期。</p>
<p>通过域名curl请求 ⇒ 第三方服务正常，证书正确。</p>
<p>在我们没有任何改动的情况下，第三方服务也是单纯地做了迁移，然后就挂了。</p>
<p>思考了很久之后，Nginx没有任何改动，那么出问题的一定不是我们。那么出问题一定是第三方，最直接的方式是联系第三方提供商，联系渠道很繁琐，时间成本也会很高。为了快速修复问题，我们决定盲调Bug。</p>
<h2 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h2><p>第一次尝试，已知curl请求一切正常。尝试着将upstream干掉，直接写道proxy_path中。依旧是失败，错误日志中出现了”<a href="https://1.1.1.1/">https://1.1.1.1:443</a> TLS handshake failed”。推断，proxy_path会将域名转换成ip。</p>
<p>第二次尝试，尝试检查curl ip来访问服务。失败。推断，IP和域名指向了两个不同的服务。到这里算是找到root cause了。</p>
<p>解决思路：反向代理时候，通过域名访问而不是IP访问。</p>
<p>查询文档，发现可以使用配置项：<code>proxy_ssl_server_name</code>，该配置项默认值是off，需要将一些内容写到配置文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_ssl_server_name on;</span><br></pre></td></tr></table></figure>

<p>第三次尝试，将<code>proxy_ssl_server_name on</code>写入到配置文件中。成功。</p>
<h2 id="什么是server-name"><a href="#什么是server-name" class="headerlink" title="什么是server_name"></a>什么是server_name</h2><p>服务器名称指示（Server Name Indication, SNI）是对TLS协议的扩展。在握手过程开始时，通过该协议，客户端指示其尝试连接的主机名。该协议允许服务器上的同一个IP和TCP端口拥有多个证书，因此允许同一个IP地址为多个HTTPS网站提供服务，且无需所有网站使用相同的证书。</p>
]]></content>
      <categories>
        <category>踩坑备忘录</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Terraform部署AWS Lambda</title>
    <url>/2021/01/17/lambda-deployment-via-terraform/</url>
    <content><![CDATA[<blockquote>
<p>手动置顶：写这一篇博客不代表我喜欢Terraform。</p>
</blockquote>
<p>这部分内容比较啰嗦，推荐直接去看我的Github。<br>使用本地Terraform部署：<a href="https://github.com/chengqing-su/lambda-deployment-via-terraform">https://github.com/chengqing-su/lambda-deployment-via-terraform</a><br>使用Docker部署：<a href="https://github.com/chengqing-su/lambda-deployment-via-dockerized-terraform">https://github.com/chengqing-su/lambda-deployment-via-dockerized-terraform</a></p>
<span id="more"></span>

<h2 id="使用本地的Terraform部署"><a href="#使用本地的Terraform部署" class="headerlink" title="使用本地的Terraform部署"></a>使用本地的Terraform部署</h2><p>一个最简单的AWS Lambda组成：</p>
<ul>
<li>Lambda 的code: 定义这个Lambda做什么以及具体怎么做</li>
<li>AWS Lambda function’s execution role：定义这个Lambda function有权限做什么</li>
<li>AWS Lambda function 资源</li>
<li>AWS Cloudwatch Log Group(可选)：执行的日志</li>
</ul>
<p>写了一个很简单的demo，这个demo只是简单地输出日志,该demo使用的是Nodejs 12和Typescript编写的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── deployment</span><br><span class="line">│         ├── main.tf</span><br><span class="line">│         ├── outputs.tf</span><br><span class="line">│         └── variables.tf</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│         └── index.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>

<p>如果觉得这部分内容，过于啰嗦，可以直接到Github上看代码：<a href="https://github.com/chengqing-su/lambda-deployment-via-terraform">https://github.com/chengqing-su/lambda-deployment-via-terraform</a></p>
<p>然后如果感兴趣如何使用Docker部署，以及为啥要使用Docker部署可以直接看“容器化部署” 或者看我的代码：<a href="https://github.com/chengqing-su/lambda-deployment-via-dockerized-terraform">https://github.com/chengqing-su/lambda-deployment-via-dockerized-terraform</a></p>
<h3 id="Lambda的code"><a href="#Lambda的code" class="headerlink" title="Lambda的code"></a>Lambda的code</h3><p>业务代码放在了<code>src</code>下面。这是一个极其简单的demo，因此没有测试代码，如果有测试的话，需要将测试放在与<code>src</code>同级的<code>tests</code>下面（有点啰嗦了）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    CloudWatchLogsEvent</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;aws-lambda&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> handler = <span class="keyword">async</span> (</span><br><span class="line">    event: CloudWatchLogsEvent</span><br><span class="line">): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;This is test lambda&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着便是infra的代码，放在了<code>deployment</code>下面。<br>通常而言，需要先对lambda的业务代码进行打包。下面的代码就是生产我们最终用于部署的业务代码，并打包成一个zip压缩包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resource &quot;null_resource&quot; &quot;package&quot; &#123;</span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    working_dir &#x3D; &quot;$&#123;path.module&#125;&#x2F;..&#x2F;&quot;</span><br><span class="line">    command &#x3D; &quot;yarn &amp;&amp; yarn compile&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  triggers &#x3D; &#123;</span><br><span class="line">    run_every_time &#x3D; uuid()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;archive_file&quot; &quot;lambda&quot; &#123;</span><br><span class="line">  type &#x3D; &quot;zip&quot;</span><br><span class="line">  source_dir &#x3D; &quot;$&#123;path.module&#125;&#x2F;..&#x2F;dist&quot;</span><br><span class="line">  output_path &#x3D; &quot;$&#123;path.module&#125;&#x2F;..&#x2F;function.zip&quot;</span><br><span class="line"></span><br><span class="line">  depends_on &#x3D; [null_resource.package]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AWS-Lambda-function’s-execution-role"><a href="#AWS-Lambda-function’s-execution-role" class="headerlink" title="AWS Lambda function’s execution role"></a>AWS Lambda function’s execution role</h3><p>Lambda function’s execution role 定义了这个function访问AWS服务和资源的权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># lambda execution role</span><br><span class="line">resource &quot;aws_iam_role&quot; &quot;execution_role&quot; &#123;</span><br><span class="line">  name &#x3D; &quot;lambda_execution_role&quot;</span><br><span class="line"></span><br><span class="line">  assume_role_policy &#x3D; &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">  &quot;Statement&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Action&quot;: &quot;sts:AssumeRole&quot;,</span><br><span class="line">      &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">      &quot;Principal&quot;: &#123;</span><br><span class="line">                        &quot;Service&quot;: &quot;lambda.amazonaws.com&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_role_policy_attachment&quot; &quot;lambda_logs_policy&quot; &#123;</span><br><span class="line">  policy_arn &#x3D; &quot;arn:aws:iam::aws:policy&#x2F;service-role&#x2F;AWSLambdaBasicExecutionRole&quot;</span><br><span class="line">  role &#x3D; aws_iam_role.execution_role.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AWS-Lambda-function-资源"><a href="#AWS-Lambda-function-资源" class="headerlink" title="AWS Lambda function 资源"></a>AWS Lambda function 资源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resource &quot;aws_lambda_function&quot; &quot;function&quot; &#123;</span><br><span class="line">  function_name &#x3D; var.function_name</span><br><span class="line">  handler &#x3D; &quot;index.handler&quot;</span><br><span class="line">  role &#x3D; aws_iam_role.execution_role.arn</span><br><span class="line">  runtime &#x3D; &quot;nodejs12.x&quot;</span><br><span class="line"></span><br><span class="line">  filename &#x3D; data.archive_file.lambda.output_path</span><br><span class="line"></span><br><span class="line">  depends_on &#x3D; [data.archive_file.lambda]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AWS-Cloudwatch-Log-Group"><a href="#AWS-Cloudwatch-Log-Group" class="headerlink" title="AWS Cloudwatch Log Group"></a>AWS Cloudwatch Log Group</h3><p>创一个Log Group 用来存放Lambda执行的日志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resource &quot;aws_cloudwatch_log_group&quot; &quot;logs&quot; &#123;</span><br><span class="line">  name &#x3D; &quot;&#x2F;aws&#x2F;lambda&#x2F;$&#123;var.function_name&#125;&quot;</span><br><span class="line">  retention_in_days &#x3D; 90</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用本地Terraform部署"><a href="#使用本地Terraform部署" class="headerlink" title="使用本地Terraform部署"></a>使用本地Terraform部署</h3><p>啰啰嗦嗦地写到了这里，还是得说一下怎么部署，说出来又觉得过于简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd deployment&#x2F;</span><br><span class="line">terraform init</span><br><span class="line">terraform deploy -auto-prove</span><br></pre></td></tr></table></figure>

<h2 id="容器化部署"><a href="#容器化部署" class="headerlink" title="容器化部署"></a>容器化部署</h2><p>使用本地化部署的痛点就是：</p>
<ul>
<li>如果没有安装相关的环境，还得重新安装一遍环境。如果有环境，也不知道环境是不是干净的，也不知道其他人在跑的时候用环境版本对不对。比如在上面这个demo中，就需要安装Node.js 12（最新的LTS版本是14）, Yarn, 以及Terraform 0.14.4（如果版本高了或者低了都可能出现无法预估的问题）。</li>
<li>在实际的项目，我们会使用多个Lambda，甚至Lambda之间也会使用不同的技术栈，有的使用Python，有的使用Ruby，有的使用Node。那么问题来了，把所有环境都安装一边是不是过于麻烦？</li>
</ul>
<p>所以，容器化是必要的。</p>
<p>首先，会在根目录引入一个<code>docker-compose.yaml</code>，下面是一个node的示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">dev:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">node:12</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/app</span></span><br></pre></td></tr></table></figure>

<p>然后再引入一个和<code>deployment</code>同级的<code>auto</code>目录，里面会存放的是一些自动化脚本。简单看一个Terraform的示例<code>auto/terraform</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash -e</span></span><br><span class="line"></span><br><span class="line">cd &quot;$(dirname &quot;$0&quot;)/..&quot;</span><br><span class="line"></span><br><span class="line">docker run --rm \</span><br><span class="line">  --volume &quot;$(pwd):/app&quot; \</span><br><span class="line">  --workdir &quot;/app/deployment&quot; \</span><br><span class="line">  -e AWS_ACCESS_KEY_ID \</span><br><span class="line">  -e AWS_SECRET_ACCESS_KEY \</span><br><span class="line">  -e AWS_DEFAULT_REGION=ap-southeast-1 \</span><br><span class="line">  hashicorp/terraform:0.14.4 \</span><br><span class="line">  &quot;$&#123;@&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>因为了<code>auto/terraform</code>之后，我们如何部署？这个时候，还会添加一个新的自动化脚本<code>auto/deploy</code>,如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash -e</span></span><br><span class="line"></span><br><span class="line">&quot;$(dirname &quot;$0&quot;)&quot;/compile</span><br><span class="line"></span><br><span class="line">&quot;$(dirname &quot;$0&quot;)&quot;/terraform init</span><br><span class="line">&quot;$(dirname &quot;$0&quot;)&quot;/terraform apply -auto-approve</span><br></pre></td></tr></table></figure>
<p>那么部署就变得极其简单了，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export AWS_ACCESS_KEY_ID=&lt;YOUR_AWS_ACCESS_KEY_ID&gt;</span><br><span class="line">export AWS_SECRET_ACCESS_KEY=&lt;YOUR_AWS_SECRET_ACCESS_KEY&gt; </span><br><span class="line">export AWS_DEFAULT_REGION=&lt;YOUR_AWS_DEFAULT_REGION&gt;</span><br><span class="line"></span><br><span class="line">./auto/deploy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DevOps</category>
        <category>Cloud Computing</category>
        <category>Public Cloud Provider</category>
        <category>Terraform</category>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>Terraform</tag>
        <tag>AWS Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>EP，从成都到新加坡</title>
    <url>/2021/01/02/chengdu-to-singapore/</url>
    <content><![CDATA[<p>这是我第一次出国，第一次去一个陌生的国家。</p>
<span id="more"></span>

<h2 id="准备EP材料"><a href="#准备EP材料" class="headerlink" title="准备EP材料"></a>准备EP材料</h2><p>2020年8月21日，正式启动LTA的流程。然后开始收集feedback，之后是新加坡办公室的同事准备新的offer。</p>
<p>开始准备Employment Pass（缩写 EP）签证相关的材料：</p>
<ul>
<li>学位证书<ul>
<li>原件的扫描件</li>
<li>翻译件（新加坡的官方语言是英语，所以需要翻译一份）</li>
<li>中国学位与教育文凭网（<a href="https://www.chinadegrees.cn/cqva/gateway.html">https://www.chinadegrees.cn/cqva/gateway.html</a>）的英文认证</li>
</ul>
</li>
<li>毕业证<ul>
<li>原件的扫描件</li>
<li>翻译件</li>
<li>学信网（<a href="https://www.chsi.com.cn/">https://www.chsi.com.cn/</a>）的Online Verification Report of Higher Education Qualification Certificate</li>
</ul>
</li>
<li>passport<ul>
<li>个人详情页的扫描件</li>
</ul>
</li>
</ul>
<p>通常而言，学位证书和学历证书（毕业证）的翻译件是需要联系学校提供的。</p>
<p>2020年9月4日，收到了新加坡办公室的offer。</p>
<p>2020年9月8日，新加坡办公室的同事正式提交了EP的申请。</p>
<h2 id="等待EP申请结果"><a href="#等待EP申请结果" class="headerlink" title="等待EP申请结果"></a>等待EP申请结果</h2><p>如何查询EP申请状态？</p>
<ul>
<li>新加坡政府提供了网上查询渠道： <a href="https://eponline.mom.gov.sg/epol/PEPOLENQM007DisplayAction.do">https://eponline.mom.gov.sg/epol/PEPOLENQM007DisplayAction.do</a></li>
</ul>
<p>通常情况下，EP的申请会在3周内处理完。请记住这是通常情况！！！</p>
<p>2020年9月15日，EP的申请状态是pending。</p>
<p>2020年9月22日，EP的申请状态是pending。</p>
<p>2020年9月29日，三周过去了，EP的申请状态依然是pending。</p>
<p>……</p>
<p>2020年10月27日，EP的申请状态依然是pending。开始做心理建设，如果不过，之后再国内准备干什么。并开始了双十一囤货计划。</p>
<p>2020年11月1日，已经做好了心理建设。国内多香，去国外干啥。并在京东上买了一堆书，比如《耶路撒冷三千年》《西方史纲》等。也就是从这一刻开始期待EP申请挂掉。</p>
<p>2020年11月23日星期一，早上开完站会后，查了一下EP状态。看到结果之后，我内心是绝望的，真的是绝望的。过了？为什么会过了？为什么没有挂掉？下午收到了新加坡同事发过来的congratulation邮件。</p>
<p>然后就是绝望和纠结的一周，去还是不去这是一个值得思考的问题。</p>
<p>2020年11月30日，最终决定还是去吧，体验一下国外的生活。</p>
<p>整个EP的申请用了10周多，不知道我这个记录会不会有同事能够破掉。我后面另外一个同事EP两周就下来了。</p>
<h2 id="准备出行"><a href="#准备出行" class="headerlink" title="准备出行"></a>准备出行</h2><p>2020年11月30日， 正式通知公司EP通过的消息，并确定了出行时间。</p>
<p>2020年12月1日，由于疫情原因，携程商旅没有直达新加坡的机票，所以在国航APP上定了2020年12月21日的机票。</p>
<p>2020年12月2日，新加坡同事发来一个MOM的批准信。</p>
<p>2020年12月9日，新加坡同事帮助预定了COVID-19 SWAB TEST（核酸检测）。</p>
<p>2020年12月19日，提交了SG arrival card（<a href="https://eservices.ica.gov.sg/sgarrivalcard/">https://eservices.ica.gov.sg/sgarrivalcard/</a>），注意选择的是Foreign visitors，我一开始的时候选错了，在下飞机的时候又重新填了一次。</p>
<p>2020年12月19日，打印相关材料：IPA，MOM的批准信以及健康申明的告知邮件（SG arrival card）</p>
<p>2020年12月20日，在国航APP上值机。</p>
<p>准备行李：</p>
<ul>
<li>短袖，短裤等衣物。强烈建议带几件薄外套，新加坡的公交地铁已经商场等温度都很低，低到怀疑人生。在办公室的第一天就被冻的有点感冒了。</li>
<li>泳裤。已经在新加坡的小伙伴儿告诉我公寓有游泳池，25年的旱鸭子终于有机会下水了。</li>
<li>一些常备药：999感冒冲剂、三九胃泰颗粒、板蓝根、口咽冷敷凝露。</li>
<li>转换插座：飞利浦旅行插座<em>3，插排</em>2。</li>
<li>15.6创维4K便携式显示器：这玩意有点儿垃圾，配的那款充电头的功率不够，连接到电脑上会导致笔记本不断黑屏（两个笔记本上都出现了这问题），直接使用使用笔记本的Type-C供电亮度最高能到50，超了之后立马就不断黑屏。人已在国外只能将就着用了。</li>
<li>笔记本电脑：公司的Mac Pro 虽然也能干很多事，但是还是自己准备一个比较方便以及安全。</li>
<li>口罩：10只N95，50只医用外科口罩。这边口罩和国内相比还好，出发前可以去Amazon或者Lazada上看看再决定是不是要多带。</li>
<li>小米自拍杆：虽然质量一般（上一个活了不到三个月就挂了），但是便宜啊。</li>
<li>ASUS路由器：为了方便回国。</li>
<li>2T希捷移动硬盘：考虑过带一个NAS出国，最后还是放弃了，目标太大。</li>
<li>数码包：这个还是很实用的，可以装很多线和小配件，比如U盘，type-c数据线，电动牙刷充电线等。</li>
<li>防晒霜。带了，但是快两周了也没有开封。</li>
<li>行李箱：28寸+18寸</li>
</ul>
<h2 id="出发当天"><a href="#出发当天" class="headerlink" title="出发当天"></a>出发当天</h2><p>2020年12月21日，出发</p>
<p>6:00, 起床。再次检查行李是否齐全，家里的电源是否关闭。</p>
<p>6:40，拉着一个28寸的箱子和一个18寸的箱子，背着一个小背包出门。滴滴司机在6点的时候就到了，虽然我预约的是7点的。</p>
<p>7:00，到达双流机场T1，需要扫码进入，天府通或者国家政务服务平台的健康码均可。</p>
<p>开始办理行李托运，整个过程大概需要一个小时。</p>
<p>7:21，收到了国航的短信，由于天气原因起飞时间调整到12:00</p>
<p>7:30， 终于轮到我了，然后被一个小姐姐拉到一边查资料。然后需要出示我的核酸检测预约单，我是一脸懵逼啊。开始手忙脚乱地连VPN，在邮箱里面查找。</p>
<p>主要的时间是排队等待工作人员<strong>检查你的资料是否齐全，是否已经预定了核酸检测，是否填写了SG Arrival Card，建议提前准备好这些材料</strong>。完成材料检查之后，工作人员会发一个表格并签字，托运的时候需要把这个表格交给柜台。</p>
<p>8:00，办行李托运的时候，发现了行李箱超重了1kg，柜台小哥哥说下次少带点，这次就算了。</p>
<p>8:10，填写海关的健康申报记录。建议通过微信小程序 海关旅客指尖服务 填报。</p>
<p>8:30，过海关。在过海关之前有一次小的安检，这次安检不需要开箱。过海关的时候，小哥哥或者小姐姐会问你一些问题，但是基本上也没啥。</p>
<p>过海关的时候，会在护照上盖个戳。人生第一次过海关，就这么结束了，就一个戳。</p>
<p>然后就是第二次机场安检，这次安检就比较麻烦了，比如我就需要把电脑，iPad，surface，相机啥的全部掏出来，再装回去。</p>
<p>然后就开始漫长的候机，百无聊赖的时候，这个时候可以看看书消遣消遣时间。</p>
<p>11:20，开始登机。</p>
<p>漫长的飞行时间，尝试着睡觉，但是睡不着。只能继续看看书，还是有意义的，至少把《持续交付2.0》看了一小半。</p>
<p>飞机进入平飞状态没多久之后，机组就开始派餐了，还是比较丰盛。</p>
<p>在飞机降落前，机组人员都换上了防护服，也有乘客陆陆续续地换上防护服。</p>
<p>16:41，到达新加坡樟宜机场。</p>
<p>到达机场之后，按照引导牌就可以去海关那边，过海关有点慢，即使走的是EP的通道。查验我资料的那位大叔直接用中文问我要各种材料，用中文通关。</p>
<p>18:00, 排队做核酸检测</p>
<p>过完海关之后，就到了取行李那边。当我到达行李盘的时候，所有的行李都已经被放在了地上，快速找到自己的行李箱。</p>
<p>之后会有专门的工作人员引导去特定位置做核酸检测，人生第一次做核酸检测，那感觉也是很酸爽，先捅喉咙，然后左右两个鼻孔，完事之后总是感觉自己的鼻子在流鼻血。</p>
<p>18:30, 出机场，找了很久拿我名字指示牌的小哥，结果并没有。被迫营业打电话给酒店，让其帮助安排车。</p>
<p>次日03:40, 梦见自己核酸检测过，然后从梦中醒来看了一下手机果然过了，根据之前同事的经验可能需要一两天。</p>
<h2 id="后续事宜"><a href="#后续事宜" class="headerlink" title="后续事宜"></a>后续事宜</h2><p>2020年12月22日，到达公司。开始一连串的session和入职事宜。下午的时候去MOM完成了拍照和按指纹。</p>
<p>2020年12月29日，收到了EP card.</p>
]]></content>
      <categories>
        <category>Travel</category>
        <category>Singapore</category>
      </categories>
      <tags>
        <tag>Chengdu</tag>
        <tag>Singapore</tag>
        <tag>EP</tag>
        <tag>出国务工人员</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL踩坑之硬盘格式问题</title>
    <url>/2021/01/01/wls-symlink/</url>
    <content><![CDATA[<p>TL;DR</p>
<p>如果在WSL中遇到了 <code>Error: EPERM: operation not permitted, symlink</code> 或者说和<code>symlin</code> 有关的错误的时候，可以先检查一个磁盘的格式是否是NTFS或者ReFS 。</p>
<span id="more"></span>

<p>按照惯例昨天晚上写一年一度总结和立flag的博客，运行 <code>npm install</code> 的时候，发现了下面这样的错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm ERR! code EPERM</span><br><span class="line">npm ERR! syscall symlink</span><br><span class="line">npm ERR! path ../esprima/bin/esparse.js</span><br><span class="line">npm ERR! dest /e/hexo-blog/node_modules/.bin/esparse</span><br><span class="line">npm ERR! errno -1</span><br><span class="line">npm ERR! Error: EPERM: operation not permitted, symlink <span class="string">&#x27;../esprima/bin/esparse.js&#x27;</span> -&gt; <span class="string">&#x27;/e/hexo-blog/node_modules/.bin/esparse&#x27;</span></span><br><span class="line">npm ERR!  [OperationalError: EPERM: operation not permitted, symlink <span class="string">&#x27;../esprima/bin/esparse.js&#x27;</span> -&gt; <span class="string">&#x27;/e/hexo-blog/node_modules/.bin/esparse&#x27;</span>] &#123;</span><br><span class="line">npm ERR!   cause: [Error: EPERM: operation not permitted, symlink <span class="string">&#x27;../esprima/bin/esparse.js&#x27;</span> -&gt; <span class="string">&#x27;/e/hexo-blog/node_modules/.bin/esparse&#x27;</span>] &#123;</span><br><span class="line">npm ERR!     errno: -1,</span><br><span class="line">npm ERR!     code: <span class="string">&#x27;EPERM&#x27;</span>,</span><br><span class="line">npm ERR!     syscall: <span class="string">&#x27;symlink&#x27;</span>,</span><br><span class="line">npm ERR!     path: <span class="string">&#x27;../esprima/bin/esparse.js&#x27;</span>,</span><br><span class="line">npm ERR!     dest: <span class="string">&#x27;/e/hexo-blog/node_modules/.bin/esparse&#x27;</span></span><br><span class="line">npm ERR!   &#125;,</span><br><span class="line">npm ERR!   stack: <span class="string">&quot;Error: EPERM: operation not permitted, symlink &#x27;../esprima/bin/esparse.js&#x27; -&gt; &#x27;/e/hexo-blog/node_modules/.bin/esparse&#x27;&quot;</span>,</span><br><span class="line">npm ERR!   errno: -1,</span><br><span class="line">npm ERR!   code: <span class="string">&#x27;EPERM&#x27;</span>,</span><br><span class="line">npm ERR!   syscall: <span class="string">&#x27;symlink&#x27;</span>,</span><br><span class="line">npm ERR!   path: <span class="string">&#x27;../esprima/bin/esparse.js&#x27;</span>,</span><br><span class="line">npm ERR!   dest: <span class="string">&#x27;/e/hexo-blog/node_modules/.bin/esparse&#x27;</span>,</span><br><span class="line">npm ERR!   parent: <span class="string">&#x27;hexo-blog&#x27;</span></span><br><span class="line">npm ERR! &#125;</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! The operation was rejected by your operating system.</span><br><span class="line">npm ERR! It is likely you <span class="keyword">do</span> not have the permissions to access this file as the current user</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! If you believe this might be a permissions issue, please double-check the</span><br><span class="line">npm ERR! permissions of the file and its containing directories, or try running</span><br><span class="line">npm ERR! the <span class="built_in">command</span> again as root/Administrator.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     /root/.npm/_logs/2021-01-01T13_14_56_876Z-debug.log</span><br></pre></td></tr></table></figure>

<p>我也是一脸懵逼，使用WSL也好几年了，第一次遇到这样的问题。然后去Google了一下，发现了很多文章，但是最主要的解决方案还是来自<a href="https://github.com/MicrosoftDocs/WSL/issues/26#issuecomment-206991754">https://github.com/MicrosoftDocs/WSL/issues/26#issuecomment-206991754</a></p>
<p>解决方案如下：</p>
<p>Using this I’ve had some luck installing some npm modules, but it still does have issues with permission errors whenever npm tries to rename a file.</p>
<p>INSTALL GLOBAL NPM PACKAGES</p>
<p><code>npm config set unsafe-perm true</code></p>
<p>CLEAN CACHE</p>
<p><code>npm cache clean</code> (注：高版本的npm 需要使用 <code>npm cache verify</code>)</p>
<p>BYPASS SYMLINK ISSUES</p>
<p><code>npm install --no-bin-links</code></p>
<p>执行完之后，确实能够成功npm install</p>
<p><img src="error-log-1.png" alt="error-log-1.png"></p>
<p>当到了一步的时候，你以为你解决了，但是打脸总是猝不及防。</p>
<p><img src="error-log-2.png" alt="error-log-2.png"></p>
<p>然后又开始懵逼了，然后尝试着干了几件蠢事。</p>
<ul>
<li>重装WSL，问题依旧存在</li>
<li>重装系统，问题依旧存在</li>
</ul>
<p>突然想起来，这个硬盘之前是被我当作移动硬盘的，是不是格式不对。</p>
<p><img src="disk-info.png" alt="disk-info.png"></p>
<p>当这里，终于发现了一丝丝希望。</p>
<p>然后查看了WSL的文档（<a href="https://docs.microsoft.com/en-us/archive/blogs/wsl/wsl-file-system-support#drvfs">https://docs.microsoft.com/en-us/archive/blogs/wsl/wsl-file-system-support#drvfs</a>），发现了如下描述，请注意加粗的那句话。</p>
<p>To facilitate interoperability with Windows, WSL uses the DrvFs file system. WSL automatically mounts all fixed drives with supported file systems under /mnt, such as /mnt/c, /mnt/d, etc. <strong>Currently, only NTFS and ReFS volumes are supported.（当前，仅支持NTFS和ReFS卷）</strong></p>
<p>然后格式磁盘为NTFS，再次尝试。一切都好了。</p>
]]></content>
      <categories>
        <category>Windows</category>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>wsl</tag>
        <tag>symlink</tag>
      </tags>
  </entry>
  <entry>
    <title>2020, 2021</title>
    <url>/2020/12/31/2020-2021/</url>
    <content><![CDATA[<p>2020，六年。<br>2021，七年。</p>
<p>2020，flag差不多都倒了。<br>2021，简单点，健康地活下去。</p>
<p>2020，100篇技术博客没有写完，只完成了27篇。写到最后，真的不知道写什么了。<br>2021，52篇博客（争取都能改成公众号文章），不限于技术，争取能够完成。</p>
<p>2020，考证计划也搁置了。<br>2021，看时间吧，但是也得争取薅羊毛，不薅白不薅。</p>
<p>2020，没有看完一本社科书籍。<br>2021，一定要把《中国乡村》看完。</p>
<p>2020，没怎么看电影，就看《信条》（不咋地）、《姜子牙》（与预期有点差距）、《我和我的家乡》（单纯是去看东大的）<br>2021，希望能在新加坡看一场电影。</p>
<p>2020，看过的剧《异星灾变》《焕脸》《大秦赋》（等了好久好久）<br>2021，随缘吧。</p>
<p>2020，依旧热爱看小说，依旧喜欢宅猪，感觉到他一直在成长。也喜欢步枪，步枪的作品也是有水准的，看得热血沸腾，看完了《鹰隼》，之前还看过他的好几部小说，可惜政策原因，正版渠道很难找到了。<br>2021，继续追《临渊行》，《帅教官》。</p>
<p>2020，注册了小破站会员，关注了观视频。马逆（独山县），沈逸（总是想起在他生日时，当众面无表情地抱着他老婆就啃），温铁军（看他讲三个世界的时候，真的看哭了），先嘿为敬的政委，半佛老师等。<br>2021，继续在小破站学习。</p>
<p>2020， 从西安到成都，再从成都到新加坡。<br>2021，希望能够顺利回到祖国。</p>
<p>2021，打工人加油！！！</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>2020</tag>
        <tag>总结</tag>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 脚本获取gradle project 版本</title>
    <url>/2020/12/04/get-gradle-project-version-via-shell/</url>
    <content><![CDATA[<p>在目前的项目中，我们采用的微服务架构，后端服务主要使用gradle进行依赖管理。我们希望在线上环境出现问题的时候，能够快速的定位是哪一个版本出现了问题。目前没有做应用监控，应用是部署到了Kubernetes集群中的， 因此我们希望通过一条比较简单的命令获取到应用名称、应用版本、应用使用的版本。</p>
<span id="more"></span>
<h2 id="获取Gradle-Project-Version"><a href="#获取Gradle-Project-Version" class="headerlink" title="获取Gradle Project Version"></a>获取Gradle Project Version</h2><p>第一种方案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version=&quot;$(./gradlew properties | grep &#x27;^version:&#x27; | awk &#x27;&#123;printf $2&#125;&#x27;)&quot;</span><br></pre></td></tr></table></figure>
<p>这种方案还是被放弃了。因为需要下载<code>gradlew</code>，而在我们的高环境上，并不能访问外网。</p>
<p>第二种方案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version=&quot;$(cat &quot;./build.gradle&quot; | sed &quot;s/=//g&quot; | grep &#x27;^version&#x27; | awk &#x27;&#123;printf $2&#125;&#x27; | sed &quot;s/&#x27;//g&quot;)&quot;</span><br></pre></td></tr></table></figure>
<p>这种方案中，最开始的版本中没有<code>sed &quot;s/=//g&quot;</code>，为什么加上这个语句？因为在<code>build.gradle</code>中，可以通过<code>version = 1.0.0</code>或者 <code>version 1.0.0</code>这两种方式设置版本。</p>
<h2 id="获取Kubernetes-Deployment的name、version、image"><a href="#获取Kubernetes-Deployment的name、version、image" class="headerlink" title="获取Kubernetes Deployment的name、version、image"></a>获取Kubernetes Deployment的name、version、image</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get deploy -o custom-columns&#x3D;NAMESPACE:.metadata.namespace,NAME:.metadata.name,&quot;VERSION&quot;:&quot;.metadata.labels.app\.kubernetes\.io&#x2F;version&quot;,&quot;IMAGE&quot;:&quot;.spec.template.spec.containers[0].image&quot; --selector&#x3D;app.kubernetes.io&#x2F;managed-by&#x3D;Helm -A</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>提升效率</tag>
      </tags>
  </entry>
  <entry>
    <title>一键更换SSH密码</title>
    <url>/2020/11/24/one-key-change-ssh-password-to-key-pair/</url>
    <content><![CDATA[<p>之前，在vSphere上搭建Kubernetes集群，所有的节点都是通过一个CentOS模板克隆出来的。也就是所有的节点的密码都是一样的，但是这样是不咋安全的，因此尝试着去关闭使用密码登录。</p>
<span id="more"></span>

<p>下面是我的脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash -e</span></span><br><span class="line"></span><br><span class="line">cd $(dirname $0)/..</span><br><span class="line"></span><br><span class="line">IPS=(&quot;192.168.0.120&quot; &quot;192.168.0.238&quot; &quot;192.168.0.134&quot; &quot;192.168.0.122&quot; &quot;192.168.0.162&quot; &quot;192.168.0.159&quot;)</span><br><span class="line"></span><br><span class="line">for ip in $IPS[*];  </span><br><span class="line">do</span><br><span class="line">  ssh-keygen -f &quot;ssh/id_rsa_$&#123;ip&#125;&quot; -t rsa -N &#x27;&#x27;</span><br><span class="line">  sshpass -e ssh-copy-id -o &quot;StrictHostKeyChecking no&quot; -i &quot;ssh/id_rsa_$&#123;ip&#125;&quot; root@$ip -f </span><br><span class="line">  ssh -i ssh/id_rsa root@$ip &lt;&lt;&#x27;ENDSSH&#x27;</span><br><span class="line">      sed -i &#x27;s/^PasswordAuthentication\s*yes$/PasswordAuthentication no/g&#x27; /etc/ssh/sshd_config</span><br><span class="line">      service sshd restart</span><br><span class="line">ENDSSH</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>在使用这个脚本之前，需要自己安装一下<code>sshpass</code>, 并 <code>export SSHPASS=YOUR_PASSWAORD</code>。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>提升效率</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>一键更新Kubernetes集群</title>
    <url>/2020/11/21/one-key-upgrade-k8s-cluster/</url>
    <content><![CDATA[<p>每次使用手动升级集群总是很难受，重复地机械地搬砖是没有意义的。因此，我尝试着将升级过程脚本化。</p>
<p>在分享我的脚本之前，我先说一下我的集群情况：</p>
<ul>
<li>3个master节点+3个worker节点</li>
<li>每个节点都是基于同一样的vm template创建的，均使用CentOS。</li>
<li>每个节点均使用 <code>ssh key pair</code> 登录</li>
</ul>
<span id="more"></span>

<h2 id="更新master节点"><a href="#更新master节点" class="headerlink" title="更新master节点"></a>更新master节点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash -e</span></span><br><span class="line"></span><br><span class="line">is_first=<span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> $(kubectl get nodes --no-headers=<span class="literal">true</span> -o wide | grep master | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span>);  </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  node_name=$(kubectl get nodes --no-headers=<span class="literal">true</span> -o wide | grep <span class="variable">$&#123;ip&#125;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">  kubectl drain <span class="variable">$&#123;node_name&#125;</span> --ignore-daemonsets</span><br><span class="line">  ssh -i <span class="string">&quot;ssh/<span class="variable">$&#123;node_name&#125;</span>&quot;</span> root@<span class="variable">$ip</span> <span class="string">&#x27;yum update -y&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> <span class="variable">$&#123;is_first&#125;</span>;</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    ssh -i <span class="string">&quot;ssh/<span class="variable">$&#123;node_name&#125;</span>&quot;</span> root@<span class="variable">$ip</span> &lt;&lt;<span class="string">&#x27;ENDSSH&#x27;</span></span><br><span class="line">      kubeadm upgrade plan</span><br><span class="line">      kubeadm upgrade apply v1.19.4 -y</span><br><span class="line">ENDSSH</span><br><span class="line">    is_first=<span class="literal">false</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     ssh -i <span class="string">&quot;ssh/<span class="variable">$&#123;node_name&#125;</span>&quot;</span> root@<span class="variable">$ip</span> <span class="string">&#x27;kubeadm upgrade node&#x27;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  ssh -i <span class="string">&quot;ssh/<span class="variable">$&#123;node_name&#125;</span>&quot;</span> root@<span class="variable">$ip</span> &lt;&lt;-<span class="string">ENDSSH</span></span><br><span class="line"><span class="string">    systemctl daemon-reload</span></span><br><span class="line"><span class="string">    systemctl restart kubelet</span></span><br><span class="line"><span class="string">ENDSSH</span></span><br><span class="line">  kubectl uncordon <span class="variable">$&#123;node_name&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="更新worker节点"><a href="#更新worker节点" class="headerlink" title="更新worker节点"></a>更新worker节点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash -e</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> $(kubectl get nodes --no-headers=<span class="literal">true</span> -o wide | grep -v master | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span>);  </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  node_name=$(kubectl get nodes --no-headers=<span class="literal">true</span> -o wide | grep <span class="variable">$&#123;ip&#125;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">  kubectl drain <span class="variable">$&#123;node_name&#125;</span> --ignore-daemonsets --delete-local-data --force</span><br><span class="line">  ssh -i <span class="string">&quot;ssh/<span class="variable">$&#123;node_name&#125;</span>&quot;</span> root@<span class="variable">$ip</span>  &lt;&lt;<span class="string">&#x27;ENDSSH&#x27;</span> </span><br><span class="line">		yum update -y</span><br><span class="line">    kubeadm upgrade node</span><br><span class="line">    systemctl daemon-reload</span><br><span class="line">    systemctl restart kubelet</span><br><span class="line">ENDSSH</span><br><span class="line">  kubectl uncordon <span class="variable">$&#123;node_name&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p>为什么不用Ansible？ 因为没有使用过，以及这个逻辑很简单。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>提升效率</tag>
      </tags>
  </entry>
  <entry>
    <title>在Laravel 中如何mock Trait</title>
    <url>/2020/10/02/laravel-mock-trait/</url>
    <content><![CDATA[<p>Trait是PHP 提供的一个代码复用方法。本文中将聊一聊如何mock 封装在Trait中的方法。</p>
<span id="more"></span>

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SayHelloFormatter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hello &#x27;</span>.<span class="variable">$name</span>.<span class="string">&#x27;, this a test message&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">SayHelloFormatter</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;format(<span class="variable">$name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单元测试中Mock-SayHelloFormatter"><a href="#单元测试中Mock-SayHelloFormatter" class="headerlink" title="单元测试中Mock SayHelloFormatter"></a>单元测试中Mock SayHelloFormatter</h2><p>当没有对 <code>SayHelloFormatter</code> 中的 <code>format</code> 进行mock时：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testShouldReturnTestMessageWithTomWhenCallSayHelloGivenNameTom</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$response</span> = <span class="keyword">$this</span>-&gt;get(<span class="string">&#x27;/sayHello/tom&#x27;</span>);</span><br><span class="line">    <span class="variable">$response</span>-&gt;assertStatus(<span class="number">200</span>)-&gt;assertSee(<span class="string">&#x27;Hello tom, this a test message&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对 <code>SayHelloFormatter</code> 中的 <code>format</code> 进行mock时：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testShouldReturnMethodHasBeenMockedWhenCallSayHelloGivenNameTomAndUsingMockery</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$mock</span> = Mockery::mock(Controller::class)-&gt;makePartial();</span><br><span class="line">    <span class="variable">$mock</span>-&gt;shouldReceive(<span class="string">&#x27;format&#x27;</span>)-&gt;andReturn(<span class="string">&#x27;This method has been mocked.&#x27;</span>);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;instance(Controller::class, <span class="variable">$mock</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$response</span> = <span class="keyword">$this</span>-&gt;get(<span class="string">&#x27;/sayHello/tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$response</span>-&gt;assertStatus(<span class="number">200</span>)-&gt;assertSee(<span class="string">&#x27;This method has been mocked.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Development</category>
        <category>PHP</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>curl</tag>
        <tag>mock</tag>
        <tag>in-built</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>在Laravel中如何mock curl方法</title>
    <url>/2020/09/29/laravel-mock-curl/</url>
    <content><![CDATA[<p>在某些情况下，我们需要调用第三方提供的HTTP API来获取特定的信息。在Laravel中，我们可以使用curl来调用HTTP API。在开发和测试的过程中，我们不可以调用真实的API，真实的API可能是需要付费的，所以我们需要Mock API的调用。</p>
<p>在本文中，虽然讲的是如何Mock curl，但是也可以推广到如何Mock PHP的标准方法。下面是一个简单的例子，我将针对这个例子进行mock测试。</p>
<span id="more"></span>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurlService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getContentFrom</span>(<span class="params"><span class="variable">$url</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$curl</span> = curl_init();</span><br><span class="line">        curl_setopt(<span class="variable">$curl</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        curl_setopt(<span class="variable">$curl</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">        curl_setopt(<span class="variable">$curl</span>, CURLOPT_HTTPHEADER, [</span><br><span class="line">            <span class="string">&#x27;Accept: application/json&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Type: application/json&#x27;</span></span><br><span class="line">        ]);</span><br><span class="line">        <span class="variable">$response</span> = curl_exec(<span class="variable">$curl</span>);</span><br><span class="line">        <span class="keyword">return</span> json_decode(<span class="variable">$response</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用第三方包"><a href="#使用第三方包" class="headerlink" title="使用第三方包"></a>使用第三方包</h2><p><code>php-mock/php-mock-phpunit</code> 是一个第三包，它对PHPUnit进行了扩展，让我们能够更加轻松地对一个方法进行Mock。</p>
<p>使用下面的命令安装：</p>
<p><code>composer require --dev php-mock/php-mock-phpunit</code></p>
<p>测试代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testShouldReturnResponseWhenCallGetContentFromGivenURL</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$url</span> = <span class="string">&#x27;https://generator.swagger.io/api/gen/clients/android&#x27;</span>;</span><br><span class="line">    <span class="variable">$response</span> = [<span class="string">&#x27;status&#x27;</span> =&gt; <span class="number">200</span>, <span class="string">&#x27;data&#x27;</span> =&gt; [<span class="string">&#x27;id&#x27;</span> =&gt; <span class="number">1</span>]];</span><br><span class="line">    <span class="variable">$curl</span> = <span class="keyword">$this</span>-&gt;getFunctionMock(<span class="string">&#x27;App\Service&#x27;</span>, <span class="string">&#x27;curl_exec&#x27;</span>);</span><br><span class="line">    <span class="variable">$curl</span>-&gt;expects(<span class="keyword">$this</span>-&gt;any())-&gt;willReturn(json_encode(<span class="variable">$response</span>));</span><br><span class="line"></span><br><span class="line">    <span class="variable">$service</span> = <span class="keyword">new</span> CurlService();</span><br><span class="line">    <span class="variable">$result</span> = <span class="variable">$service</span>-&gt;getContentFrom(<span class="variable">$url</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">self</span>::assertEquals(<span class="variable">$response</span>[<span class="string">&#x27;status&#x27;</span>], <span class="variable">$result</span>-&gt;status);</span><br><span class="line">    <span class="built_in">self</span>::assertEquals(<span class="variable">$response</span>[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;id&#x27;</span>], <span class="variable">$result</span>-&gt;data-&gt;id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$this-&gt;getFunctionMock(&#39;App\Service&#39;, &#39;curl_exec&#39;)</code> 中<code>App\Service</code> 是指<code>curl_exec</code> 所在的namespace，如果你是在 <code>App\Controller</code> 中调用该方法，则该处就应该是 <code>App\Controller</code> 。</p>
<h2 id="重载内置函数"><a href="#重载内置函数" class="headerlink" title="重载内置函数"></a>重载内置函数</h2><p>重载namespace下的 <code>curl_exec</code> ，如下代码所示。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title">function</span> <span class="title">curl_exec</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        return json_encode([&#x27;status&#x27; =&gt; 200, &#x27;data&#x27; =&gt; [&#x27;id&#x27; =&gt; 1]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Tests</span>\<span class="title">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title">use</span> <span class="title">App</span>\<span class="title">Service</span>\<span class="title">CurlService</span>;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CurlServiceTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testShouldReturnResponseWhenCallGetContentFromGivenURL</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable">$url</span> = <span class="string">&#x27;https://generator.swagger.io/api/gen/clients/android&#x27;</span>;</span><br><span class="line">            <span class="variable">$response</span> = [<span class="string">&#x27;status&#x27;</span> =&gt; <span class="number">200</span>, <span class="string">&#x27;data&#x27;</span> =&gt; [<span class="string">&#x27;id&#x27;</span> =&gt; <span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">            <span class="variable">$service</span> = <span class="keyword">new</span> CurlService();</span><br><span class="line">            <span class="variable">$result</span> = <span class="variable">$service</span>-&gt;getContentFrom(<span class="variable">$url</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">self</span>::assertEquals(<span class="variable">$response</span>[<span class="string">&#x27;status&#x27;</span>], <span class="variable">$result</span>-&gt;status);</span><br><span class="line">            <span class="built_in">self</span>::assertEquals(<span class="variable">$response</span>[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;id&#x27;</span>], <span class="variable">$result</span>-&gt;data-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用类封装"><a href="#使用类封装" class="headerlink" title="使用类封装"></a>使用类封装</h2><p>将 <code>curl</code>这样PHP inbuilt函数封装到一个新的类中，我们就可以通过Mock这个新的类进而mock inbuilt函数。</p>
<p>代码如下所示</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Curl</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$curl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;curl = curl_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setopt</span>(<span class="params"><span class="variable">$key</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        curl_setopt(<span class="keyword">$this</span>-&gt;curl, <span class="variable">$key</span>, <span class="variable">$value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curl_exec(<span class="keyword">$this</span>-&gt;curl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurlService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$curl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$curl</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;curl = <span class="variable">$curl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getContentFrom</span>(<span class="params"><span class="variable">$url</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;curl-&gt;setopt(CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;curl-&gt;setopt(CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;curl-&gt;setopt(CURLOPT_HTTPHEADER, [</span><br><span class="line">            <span class="string">&#x27;Accept: application/json&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Type: application/json&#x27;</span></span><br><span class="line">        ]);</span><br><span class="line">        <span class="variable">$response</span> = <span class="keyword">$this</span>-&gt;curl-&gt;exec();</span><br><span class="line">        <span class="keyword">return</span> json_decode(<span class="variable">$response</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurlServiceTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testShouldReturnWhenCallGetContentFromGivenURL</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$url</span> = <span class="string">&#x27;https://generator.swagger.io/api/gen/clients/android&#x27;</span>;</span><br><span class="line">        <span class="variable">$response</span> = [<span class="string">&#x27;status&#x27;</span> =&gt; <span class="number">200</span>, <span class="string">&#x27;data&#x27;</span> =&gt; [<span class="string">&#x27;id&#x27;</span> =&gt; <span class="number">1</span>]];</span><br><span class="line">        <span class="variable">$curlMock</span> = \Mockery::mock(Curl::class);</span><br><span class="line">        <span class="variable">$curlMock</span>-&gt;shouldReceive(<span class="string">&#x27;setopt&#x27;</span>);</span><br><span class="line">        <span class="variable">$curlMock</span>-&gt;shouldReceive(<span class="string">&#x27;exec&#x27;</span>)-&gt;andReturn(json_encode(<span class="variable">$response</span>));</span><br><span class="line"></span><br><span class="line">        <span class="variable">$service</span> = <span class="keyword">new</span> CurlService(<span class="variable">$curlMock</span>);</span><br><span class="line">        <span class="variable">$result</span> = <span class="variable">$service</span>-&gt;getContentFrom(<span class="variable">$url</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">self</span>::assertEquals(<span class="variable">$response</span>[<span class="string">&#x27;status&#x27;</span>], <span class="variable">$result</span>-&gt;status);</span><br><span class="line">        <span class="built_in">self</span>::assertEquals(<span class="variable">$response</span>[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;id&#x27;</span>], <span class="variable">$result</span>-&gt;data-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Development</category>
        <category>PHP</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>curl</tag>
        <tag>mock</tag>
        <tag>in-built</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>如何从shell数组中删除一个元素</title>
    <url>/2020/07/15/delete-ele-from-array/</url>
    <content><![CDATA[<p>这一篇博客，最开始是想写在shell数组中*和@的区别。但是写着写着，发现之前出问题不是因为 * 和 @，而是因为从数组中删除元素的方式有点小问题。接下来，我将介绍如何从shell数组上删除一个元素。</p>
<span id="more"></span>

<h2 id="根据下标删除"><a href="#根据下标删除" class="headerlink" title="根据下标删除"></a>根据下标删除</h2><p>先上一个数组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array1=(a b c d a b c d)</span><br></pre></td></tr></table></figure>

<p>我希望从上面的数组中删除第二个元素，如何删除呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array1=(a b c d a b c d)</span><br><span class="line">unset array1[1]</span><br><span class="line"></span><br><span class="line">echo $&#123;array1[*]&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a c d a b c d</span><br></pre></td></tr></table></figure>

<h2 id="根据元素值删除"><a href="#根据元素值删除" class="headerlink" title="根据元素值删除"></a>根据元素值删除</h2><p>在有些情况下，我们想删除数组中指定元素，比如删除上述数组中的<code>b</code>。代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array1=(a b c d a b c d)</span><br><span class="line">array1=( $&#123;array1[*]/b&#125; )</span><br><span class="line"></span><br><span class="line">echo $&#123;array1[*]&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a c d a c d</span><br></pre></td></tr></table></figure>
<p>如果将<code>array1=( $&#123;array1[*]/b&#125; )</code>中的<code>*</code>换成<code>@</code>，结果输出一样。</p>
<h3 id="将-array1-b-换成-quot-array1-b-quot"><a href="#将-array1-b-换成-quot-array1-b-quot" class="headerlink" title="将${array1[*]/b} 换成 &quot;${array1[*]/b}&quot;"></a>将<code>$&#123;array1[*]/b&#125;</code> 换成 <code>&quot;$&#123;array1[*]/b&#125;&quot;</code></h3><p>为了更好的测试，加入一个循环，对移除<code>b</code>之后的数组进行循环输出。<br>代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array1=(a b c d a b c d)</span><br><span class="line">array1=( &quot;$&#123;array1[*]/b&#125;&quot; )</span><br><span class="line"></span><br><span class="line">echo $&#123;array1[*]&#125;</span><br><span class="line"></span><br><span class="line">for value in $&#123;array1[@]&#125;</span><br><span class="line">do</span><br><span class="line">  echo $value</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a c d a c d</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<h4 id="将for循环中的-换成"><a href="#将for循环中的-换成" class="headerlink" title="将for循环中的 @ 换成 *"></a>将for循环中的 <code>@</code> 换成 <code>*</code></h4><p>结果和上面一致</p>
<h4 id="将for循环换成for-value-in-quot-array1-quot-或者-for-value-in-quot-array1-quot"><a href="#将for循环换成for-value-in-quot-array1-quot-或者-for-value-in-quot-array1-quot" class="headerlink" title="将for循环换成for value in &quot;${array1[@]}&quot; 或者 for value in &quot;${array1[*]}&quot;"></a>将for循环换成<code>for value in &quot;$&#123;array1[@]&#125;&quot;</code> 或者 <code>for value in &quot;$&#123;array1[*]&#125;&quot;</code></h4><p>代码如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array1=(a b c d a b c d)</span><br><span class="line">array1=( &quot;$&#123;array1[*]/b&#125;&quot; )</span><br><span class="line"></span><br><span class="line">echo $&#123;array1[*]&#125;</span><br><span class="line"></span><br><span class="line">for value in &quot;$&#123;array1[@]&#125;&quot;</span><br><span class="line">do</span><br><span class="line">  echo $value</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a c d a c d</span><br><span class="line">a c d a c d</span><br></pre></td></tr></table></figure>

<h3 id="将-array1-b-换成-quot-array1-b-quot-1"><a href="#将-array1-b-换成-quot-array1-b-quot-1" class="headerlink" title="将${array1[*]/b} 换成 &quot;${array1[@]/b}&quot;"></a>将<code>$&#123;array1[*]/b&#125;</code> 换成 <code>&quot;$&#123;array1[@]/b&#125;&quot;</code></h3><p>代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array1=(a b c d a b c d)</span><br><span class="line">array1=( &quot;$&#123;array1[@]/b&#125;&quot; )</span><br><span class="line"></span><br><span class="line">echo $&#123;array1[*]&#125;</span><br><span class="line"></span><br><span class="line">for value in $&#123;array1[@]&#125;</span><br><span class="line">do</span><br><span class="line">  echo $value</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a c d a c d</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<h4 id="将for循环中的-换成-1"><a href="#将for循环中的-换成-1" class="headerlink" title="将for循环中的 @ 换成 *"></a>将for循环中的 <code>@</code> 换成 <code>*</code></h4><p>结果和上面一致</p>
<h4 id="将for循环换成for-value-in-quot-array1-quot"><a href="#将for循环换成for-value-in-quot-array1-quot" class="headerlink" title="将for循环换成for value in &quot;${array1[@]}&quot;"></a>将for循环换成<code>for value in &quot;$&#123;array1[@]&#125;&quot;</code></h4><p>代码如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array1=(a b c d a b c d)</span><br><span class="line">array1=( &quot;$&#123;array1[@]/b&#125;&quot; )</span><br><span class="line"></span><br><span class="line">echo $&#123;array1[*]&#125;</span><br><span class="line"></span><br><span class="line">for value in &quot;$&#123;array1[@]&#125;&quot;</span><br><span class="line">do</span><br><span class="line">  echo $value</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a c d a c d</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<h4 id="将for循环换成for-value-in-quot-array1-quot-1"><a href="#将for循环换成for-value-in-quot-array1-quot-1" class="headerlink" title="将for循环换成for value in &quot;${array1[*]}&quot;"></a>将for循环换成<code>for value in &quot;$&#123;array1[*]&#125;&quot;</code></h4><p>代码如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array1=(a b c d a b c d)</span><br><span class="line">array1=( &quot;$&#123;array1[@]/b&#125;&quot; )</span><br><span class="line"></span><br><span class="line">echo $&#123;array1[*]&#125;</span><br><span class="line"></span><br><span class="line">for value in &quot;$&#123;array1[*]&#125;&quot;</span><br><span class="line">do</span><br><span class="line">  echo $value</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a c d a c d</span><br><span class="line">a c d a c d</span><br></pre></td></tr></table></figure>

<h2 id="删除包含某个字符的元素"><a href="#删除包含某个字符的元素" class="headerlink" title="删除包含某个字符的元素"></a>删除包含某个字符的元素</h2><p>为了更好的测试， 换了一个新的数组。代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array1=(abc bcd cdf dfg)</span><br><span class="line">array1=( &quot;$&#123;array1[@]/*b*&#125;&quot; )</span><br><span class="line"></span><br><span class="line">echo $&#123;array1[*]&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cdf dfg</span><br></pre></td></tr></table></figure>

<p><strong>这个方案和上面的方案，本质上就是截取字符串。</strong></p>
<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="* 和 @ 的区别"></a>* 和 @ 的区别</h2><blockquote>
<p>These subscripts differ only when the word appears within double quotes. If the word is double-quoted, ${name[*]} expands to a single word with the value of each array member separated by the first character of the IFS variable, and ${name[@]} expands each element of name to a separate word.</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>ConfigMap</title>
    <url>/2020/06/09/config-map/</url>
    <content><![CDATA[<p>ConfigMap 是用来以键值对（key-value）的方式存储非敏感信息。Pod可以通过环境变量、命令行参数或者卷挂载等方式使用ConfigMap.<br>ConfigMap 可以将环境配置与具体的应用程序进行解耦，这意味着可以提升应用的可移植性。<br><strong>需要注意的是，ConfigMap没有加密功能。</strong></p>
<span id="more"></span>

<h2 id="如何写一个ConfigMap对象"><a href="#如何写一个ConfigMap对象" class="headerlink" title="如何写一个ConfigMap对象"></a>如何写一个ConfigMap对象</h2><p>下面是一个ConfigMap的对象示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-demo</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="string">enable</span></span><br><span class="line">  <span class="attr">index.html:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">hello,</span> <span class="string">world</span></span><br></pre></td></tr></table></figure>
<p>ConfigMap 处理每个API对象都有的<code>apiVersion</code>、<code>kind</code>和<code>metadata</code>，但是没有<code>spec</code>字段。 ConfigMap提供了两个字段<code>data</code>和<code>binaryData</code>来存储配置数据。<br><code>data</code>: 存储配置数据。 Value中只能包含UTF-8数据，非UTF-8的数据必须使用<code>binaryData</code>。<br><code>binaryData</code>: 存储二进制数据。</p>
<p>除此之外，还有一个字段<code>immutable</code>用来指定存储在ConfigMap中的数据是否可以被修改。<br>需要注意的是，同一个ConfigMap中，key是唯一的。在<code>data</code>中已经使用的key,就不能被<code>binaryData</code>使用，同理，在<code>binaryData</code>已使用的key，也不能在<code>data</code>中使用。</p>
<h2 id="如何使用ConfigMap"><a href="#如何使用ConfigMap" class="headerlink" title="如何使用ConfigMap"></a>如何使用ConfigMap</h2><p>Pod中的容器有四种方式来使用ConfigMap：</p>
<ol>
<li>作为容器的entrypoint的命令行参数</li>
<li>容器的环境变量</li>
<li>只读的存储卷</li>
<li>在应用程序中通过调用Kubernetes API读取ConfigMap</li>
</ol>
<p>下面是一个简单的示例, 该示例已上传的Github：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap-demo-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">      <span class="comment"># environment for container</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DEBUG</span> </span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">configmap-demo</span>          </span><br><span class="line">              <span class="attr">key:</span> <span class="string">debug</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="comment"># read-only volume</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">configmap-demo</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<ol>
<li>验证Env</li>
</ol>
<p><img src="env.png" alt="env"></p>
<ol start="2">
<li>验证只读文件</li>
</ol>
<p><img src="volume.png" alt="volume"></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>ConfigMap</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Pipeline</title>
    <url>/2020/05/09/what-is-pipeline/</url>
    <content><![CDATA[<p>Deployment Pipeline(简称pipeline)是将代码更改应用到生产环境的一系列步骤，是对CI/CD过程的描述，依赖于CI/CD平台（比如Jenkins, Gitlab CI/CD, Buildkite， GOCD等）。通过一条pipeline，代码更改在几分钟或者几十分钟内通过完全自动化的脚本化的流程部署到任何环境。</p>
<span id="more"></span>
<h2 id="pipeline的组成"><a href="#pipeline的组成" class="headerlink" title="pipeline的组成"></a>pipeline的组成</h2><p>一条pipeline由一系列连续的阶段（stage）组成。一个阶段（stage）会包含一个或者多个步骤（step）。</p>
<h3 id="阶段（stage）"><a href="#阶段（stage）" class="headerlink" title="阶段（stage）"></a>阶段（stage）</h3><p>一条pipeline由多个阶段组成，阶段与阶段之间是串行的，比如上一个阶段执行失败，下一个阶段就不会被执行，只有上一个阶段执行通过，下一个阶段才能执行。</p>
<p>比如下图中，如果Test这个阶段执行失败，则Acceptance test以及之后的阶段就不会被执行。</p>
<p><img src="stage.png" alt="stage"></p>
<p>由于阶段之间是串行的，因此合理地划分阶段是很重要的，不合理的阶段划分会导致执行时间变长。</p>
<h3 id="步骤（step）"><a href="#步骤（step）" class="headerlink" title="步骤（step）"></a>步骤（step）</h3><p>一个阶段中会包含一个或者多个步骤。</p>
<p>一个步骤代表一件将要执行的具体的事情，比如单元测试。每一个步骤都应当有唯一一个自动化脚本，步骤通过自动化脚本来说明自己要干什么。</p>
<p>步骤与步骤之间是并行的，互不干扰，同时执行。在一个阶段中，只有所有的步骤都成功执行，该阶段才算成功，如果其中有一个步骤执行失败，则该阶段失败。</p>
<p>如下图，在Test这个阶段，包含了两个步骤：unit test 和 code style check。如果unit test执行失败，那么Test这个阶段就失败了，下一个阶段就不会被执行。unit test 和 code style check这两步会同时执行。如果Unit test先于Code style check执行完成，无论成功与否，Test这个阶段都会等待Code style check执行完成。</p>
<p><img src="steps.png" alt="steps"></p>
<h3 id="Build-和-Job"><a href="#Build-和-Job" class="headerlink" title="Build 和 Job"></a>Build 和 Job</h3><p>每触发一次Pipeline都是一个build, 可以理解为Pipeline是一个class，而一个build就是pipeline的一个实例。每个build中由一连串的job组成，每个job都是对pipeline中的每个步骤（step）的实现。</p>
<h2 id="为什么需要pipeline"><a href="#为什么需要pipeline" class="headerlink" title="为什么需要pipeline"></a>为什么需要pipeline</h2><ul>
<li><p>Pipeline 可以让所有人看见应用的构建、部署、测试和发布过程。</p>
</li>
<li><p>更早地发现并解决问题。</p>
</li>
<li><p>可以通过完全自动化的过程在任意的环境上部署和发布应用的任意版本。</p>
</li>
</ul>
<h2 id="一个Pipeline的示例（Buildkite）"><a href="#一个Pipeline的示例（Buildkite）" class="headerlink" title="一个Pipeline的示例（Buildkite）"></a>一个Pipeline的示例（Buildkite）</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Test</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">auto/test</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Lint</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">auto/lint</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="string">wait</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Release</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">auto/release</span></span><br><span class="line">    <span class="attr">branchs:</span> <span class="string">master</span></span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="string">wait</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">staging</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">auto/deploy-to-staging</span></span><br><span class="line">    <span class="attr">branchs:</span> <span class="string">master</span></span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="string">wait</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Acceptance</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">auto/accptance-test</span></span><br><span class="line">    <span class="attr">branchs:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 这种方式是持续部署，如果需要使用持续交付则使用如下代码</span></span><br><span class="line">  <span class="comment"># - block: Deploy to production?</span></span><br><span class="line">  <span class="comment">#   branchs: master</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">wait</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">production</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">auto/deploy-to-production</span></span><br><span class="line">    <span class="attr">branchs:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>在Buildkite中，使用wait来分割阶段，使用block进行人工干预。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>介绍一些我在项目中实际应用到的最佳实践。</p>
<h3 id="使用Pipeline-as-Code，不要使用手动配置"><a href="#使用Pipeline-as-Code，不要使用手动配置" class="headerlink" title="使用Pipeline as Code，不要使用手动配置"></a>使用Pipeline as Code，不要使用手动配置</h3><p>CI/CD工具一般都支持Pipeline as Code和手动配置这两种方式去管理一条pipeline。但是不推荐使用手动配置，因为手动配置的过程不容易被追溯，手动配置很容易导致错误出现，<strong>我们不应该在任何基础设施上做任何的人工操作，应该Infrastructure as Code</strong>。</p>
<p>CI/CD相关的配置，如pipeline、自动化脚本、基础设施等，应当和业务代码放在同一个版本库里。它们具有与业务代码一样的地位，它们的每一次更改都被团队审查。</p>
<h3 id="使用“静态”pipeline，尽量不要使用动态Pipeline"><a href="#使用“静态”pipeline，尽量不要使用动态Pipeline" class="headerlink" title="使用“静态”pipeline，尽量不要使用动态Pipeline"></a>使用“静态”pipeline，尽量不要使用动态Pipeline</h3><p>越动态越灵活的pipeline越复杂，越复杂的pipeline可读性就越低。pipeline是自己团队共享的，甚至对其他团队也是可见的。通过CI/CD，我们期待的是让团队成员更加专注于业务，一个复杂的pipeline会给团队成员造成负担。</p>
<p>在我的理解中，pipeline的配置文件就应该是一个简单的YAML文件（如上述示例所示），而不是一个shell脚本，更不是Groovy。</p>
<h3 id="使用自动化脚本，不要使用命令"><a href="#使用自动化脚本，不要使用命令" class="headerlink" title="使用自动化脚本，不要使用命令"></a>使用自动化脚本，不要使用命令</h3><p>通常，CI/CD工具都会允许直接在pipeline中调用命令，比如上面的示例中，可以将Test中<code>command</code>后面跟着的脚本更换为一个命令，比如更换成<code>rspec</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Test</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>

<p>直接在pipeline中使用命令是一件很危险的事情。CI/CD工具的agent都是运行在我们的基础设施中，那么agent就有权限访问我们的基础设施，用于部署的agent通常是具有很高权限的。如果有人想干坏事，通过修改command就可以做到。但是使用自动化脚本就不会存在这种问题，因为自动化脚本是需要从代码库中读取出来的。</p>
<p>应当禁止在pipeline中直接使用命令。</p>
<h3 id="使用一套部署脚本，不要使用多套部署脚本"><a href="#使用一套部署脚本，不要使用多套部署脚本" class="headerlink" title="使用一套部署脚本，不要使用多套部署脚本"></a>使用一套部署脚本，不要使用多套部署脚本</h3><p>staging环境和production环境之间的区别，应当只有配置上的差距，比如其运行在不同的VPC中，或者运行在不同的AWS account上。在上面的示例中，要将应用部署到staging环境和production环境，虽然调用了两个不同的脚本，但是在实际过程中，它们都会调用另外一个<code>auto/deploy</code>的脚本。使用一套部署脚本，可以减少向不同环境部署的差异，更加能够确保我们的测试是可靠的。</p>
<h3 id="使用两条pipeline，不要使用All-in-one"><a href="#使用两条pipeline，不要使用All-in-one" class="headerlink" title="使用两条pipeline，不要使用All in one"></a>使用两条pipeline，不要使用All in one</h3><p>通常情况下，我们会将部署到生产环境及其之后的步骤拆分到另外的一个pipeline中。在这个过程中，我们也需要拆库，比如我们有一个<code>hello-world</code>的Git Repo，这是主要的代码库，我们也需要创建一个<code>hello-world-deploy</code>的Git Repo，这个库是用来部署到生产环境的。<code>hello-world</code>对应的pipeline最后一步会将Artifacts信息（比如docker image 的 tag）通过Git提交到<code>hello-world-deploy</code>中，然后触发<code>hello-world-deploy</code>对应的部署pipeline。</p>
<p>为什么要这样做？回滚是不可避免的，当某一次部署到生产环境上的应用出现了一些问题不得不回滚时。如果不拆库的话，我们就需要从头开始构建、测试等，这个过程比较漫长的。如果我们拆库了，我们就可以在<code>hello-world-deploy</code>revert这个部署相关的commit，然后提交代码，触发部署流程。</p>
<p>Git是唯一的真实来源。</p>
<p>因此上面的示例中的那种pipeline，并不推荐使用。</p>
<h3 id="Push代码之前，先执行一些简单的测试"><a href="#Push代码之前，先执行一些简单的测试" class="headerlink" title="Push代码之前，先执行一些简单的测试"></a>Push代码之前，先执行一些简单的测试</h3><p>在将代码提交到代码库之前，运行一些简单的测试，比如单元测试，代码风格检查，可以减轻CI/CD平台的负担。</p>
<h3 id="一次Build只生成一个Artifact"><a href="#一次Build只生成一个Artifact" class="headerlink" title="一次Build只生成一个Artifact"></a>一次Build只生成一个Artifact</h3><p>如果生成多个Artifact（比如docker image），我们无法保证我们测试的就一定是部署到生产上的。</p>
<h3 id="使用自动触发，不要使用手动触发"><a href="#使用自动触发，不要使用手动触发" class="headerlink" title="使用自动触发，不要使用手动触发"></a>使用自动触发，不要使用手动触发</h3><p>每一次的代码改动提交到代码时都应该触发pipeline，如果不这么做，我们将无法确保我们一定执行了相关的测试并部署了，这样会给后续的开发带来负担。当然每一次提交都需要去CI/CD平台手动触发pipeline，也会增加开发人员的负担。</p>
<h3 id="代码更改应当尽可能地小"><a href="#代码更改应当尽可能地小" class="headerlink" title="代码更改应当尽可能地小"></a>代码更改应当尽可能地小</h3><p>代码更改应当尽可能地小，这样能减少团队审查代码的成本，也能够减低引入bug的风险。</p>
<h3 id="pipeline不过夜"><a href="#pipeline不过夜" class="headerlink" title="pipeline不过夜"></a>pipeline不过夜</h3><p>当pipeline执行失败，应当立即停止手上的工作，着手于修复它。应当确保在下班前，pipeline一定是绿的。</p>
<h2 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h2><p><a href="https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment">Continuous integration vs. continuous delivery vs. continuous deployment</a></p>
<p><a href="https://docs.gitlab.com/ee/ci/introduction/">Introduction to CI/CD with GitLab</a></p>
<p><a href="https://martinfowler.com/articles/continuousIntegration.html">Continuous integration</a></p>
<p><a href="https://martinfowler.com/delivery.html">Delivery</a></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Pipeline</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernets 之 Persistent Volume 和 Persistent Volume Claim 的生命周期</title>
    <url>/2020/05/06/pvc-lifecycle/</url>
    <content><![CDATA[<p>PV 和 PVC的生命周期可以分为4个阶段：Provisioning（置备）、Binding（绑定）、Using（使用）和Reclaiming（回收）。<br>本文主要介绍这四个阶段。</p>
<span id="more"></span>

<h2 id="Provisioning（置备）"><a href="#Provisioning（置备）" class="headerlink" title="Provisioning（置备）"></a>Provisioning（置备）</h2><p>这个阶段主要的任务就是去置备PV给后续的阶段使用。总共有两种方式置备PV：静态和动态。</p>
<p><strong>静态方式</strong>：集群管理员创建一定数量可以被集群用户使用的PV。<br><strong>动态方式</strong>：根据PVC创建动态创建PV。当没有任何静态的PV能够匹配到PVC的时候，集群就会根据PVC去创建PV。这种方式需要集群管理员提前创建和配置StorageClass。如果不希望根据PVC动态创建PV，可以将PVC中的<code>spec.storageClassName</code>设置为””。</p>
<h2 id="Binding（绑定）"><a href="#Binding（绑定）" class="headerlink" title="Binding（绑定）"></a>Binding（绑定）</h2><p>这个阶段是将PV绑定到PVC上，这种绑定关系是一对一的，通过ClaimRef来实现PV和PVC的双向绑定。</p>
<p>当创建一个新的PVC的时候，会先查找是否有未绑定的PV，如果有，就将其与改PVC绑定。如果没有则会根据PVC去尝试动态置备PV（不一定会成功），这样的话，这个PVC和其动态置备的PV会始终绑定在一起。<br>当PVC没有任何可以匹配到的PV的时候，其状态为<code>unbound</code>。当它匹配到PV的时候，其状态为<code>bound</code>。</p>
<h2 id="Using（使用）"><a href="#Using（使用）" class="headerlink" title="Using（使用）"></a>Using（使用）</h2><p>Pod会将PVC作为volume。集群会更通过PVC找到其绑定的PV，然后其挂载到Pod上。当使用PVC的Pod存在时，该PVC就会处于活动状态。</p>
<p>为了保证PVC处于活动状态以及该PVC绑定的PV不会从系统中删除，因为一旦被删除，数据可能会丢失。Kubernetes提供了一个功能：使用中的存储对象保护（Storage Object in Use Protection）。因此，当用户删除一个处于活动状态的PVC的时候，该PVC并不会被删除，直到PVC没有被任何pod使用。同样，如果删除一个已经绑定了PVC的PV，PV也不会被删除，直到PV没有被任何PVC绑定。</p>
<h2 id="Reclaiming（回收）"><a href="#Reclaiming（回收）" class="headerlink" title="Reclaiming（回收）"></a>Reclaiming（回收）</h2><p>这个阶段主要指的是PV的回收。当PV被PVC释放之后（解除绑定），集群将会根据回收策略回收PV。<br>当前，支持3个策略：Retain（保留）、Recycle（再利用）、Delete（删除）</p>
<p><strong>Retained（保留）</strong>：该策略允许手动回收这些存储资源。当其绑定的PVC删除之后，PV仍然保留，但是不会被其它的PVC再次绑定。<br><strong>Delete（删除）</strong>: 该策略将会删除PV以及其关联的外部存储资源，比如AWS EBS、Azure Disk。<code>StorageClass</code>默认的回收策略是<code>Delete</code>，根据其动态置备的PV也会继承该值。<br><strong>Recycle（再利用，已弃用）</strong>：该策略会删除PV上的所有数据，然后使其可以再次被PVC绑定。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Storage</tag>
        <tag>PersistentVolumeClaim</tag>
        <tag>PersistentVolume</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernets 之 Persistent Volume Claim</title>
    <url>/2020/03/26/pvc/</url>
    <content><![CDATA[<p>PersistentVolumeClaim（PVC）是用户存储请求。它类似于Pod。Pod消耗Node资源，PVC消耗PV资源。Pod可以请求特定级别的资源（CPU和内存）。PVC可以请求特定的大小和访问模式（例如，可以将它们安装为读/写一次或多次只读）的PV。</p>
<span id="more"></span>

<h2 id="manifest示例"><a href="#manifest示例" class="headerlink" title="manifest示例"></a>manifest示例</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-first-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">8Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">hostpath</span></span><br></pre></td></tr></table></figure>

<p><code>volumeMode</code>: 当请求使用特定访问模式进行存储时，PVC使用与PV相同的约定。<br><code>resources</code>: PVC使用与PV相同的约定来表示将Volume作为文件系统或块设备使用。<br><code>storageClassName</code>: PVC可以通过使用属性<code>storageClassName</code>指定<code>StorageClass</code>的名称来请求特定的<code>StorageClass</code>。只能将具有与PVC相同的storageClassName的PV绑定到PVC。<br><code>selector</code>: PVC可以指定标签选择器以进一步过滤Volume。仅其标签与选择器匹配的PV可以绑定到PVC。</p>
<h2 id="创建PVC"><a href="#创建PVC" class="headerlink" title="创建PVC"></a>创建PVC</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;volumes&#x2F;pvc-example.yaml</span><br></pre></td></tr></table></figure>
<p>获取PVC状态，如下：<br><img src="pvc.png" alt="pvc"></p>
<p>获取PV状态，如下：<br><img src="pv.png" alt="pv"></p>
<h2 id="PVC-as-Volumes"><a href="#PVC-as-Volumes" class="headerlink" title="PVC as Volumes"></a>PVC as Volumes</h2><p><strong>Pod不能直接使用PV，需要通过PVC来使用</strong></p>
<p>PVC必须与使用PVC的Pod在相同的namespace中。集群在Pod的namespace中找到PVC，并使用它来获取支持PVC的PersistentVolume。然后将卷安装到主机上并安装到Pod中。</p>
<p>创建一个nginx Pod并使用PVC。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:1.16</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">      name: www-dir</span><br><span class="line">  volumes:</span><br><span class="line">  - name: www-dir</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: my-first-pvc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Storage</tag>
        <tag>PersistentVolumeClaim</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernets 之 Persistent Volume</title>
    <url>/2020/03/25/pv/</url>
    <content><![CDATA[<p>PersistentVolume（PV）是Kubernetes集群中的一块存储，由管理员创建或使用存储类动态创建。其生命周期独立于使用PV的任何单个Pod。</p>
<span id="more"></span>

<h2 id="如何手动创建一个PV"><a href="#如何手动创建一个PV" class="headerlink" title="如何手动创建一个PV"></a>如何手动创建一个PV</h2><p>下面是手动创建PV的manifest。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">task-pv-volume</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">hostpath</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/tmp/data&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>storageClassName</code>: StorageClass的名称。当一个PV配置了该字段之后，该PV就只能被使用该名称的PVC绑定。如果没有指定，则可以被任意StroageClass绑定。</p>
<p><code>capacity</code>: PV的存储能力，目前仅支持指定存储大小。</p>
<p><code>accessModes</code>：PV的访问模式。支持ReadWriteOnce(RWO)、ReadOnlyMany(ROX)、ReadWriteMany(RWX).Pod中的volume只能使用一个访问模式，即使PV支持多种模式。</p>
<p><code>persistentVolumeReclaimPolicy</code>：PV回收策略。支持Retain (手动创建的PersistentVolumes的默认值), Delete (动态创建的PersistentVolumes的默认值), and Recycle (已过时).</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;volumes&#x2F;pv.yaml</span><br></pre></td></tr></table></figure>


<p>执行<code>kubectl get pv task-pv-volume -o yaml</code>结果如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubectl.kubernetes.io/last-applied-configuration:</span> <span class="string">|</span></span><br><span class="line">      &#123;<span class="string">&quot;apiVersion&quot;</span><span class="string">:&quot;v1&quot;</span>,<span class="string">&quot;kind&quot;</span><span class="string">:&quot;PersistentVolume&quot;</span>,<span class="string">&quot;metadata&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;annotations&quot;</span><span class="string">:</span>&#123;&#125;,<span class="string">&quot;labels&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;type&quot;</span><span class="string">:&quot;local&quot;</span>&#125;,<span class="string">&quot;name&quot;</span><span class="string">:&quot;task-pv-volume&quot;</span>&#125;,<span class="string">&quot;spec&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;accessModes&quot;</span><span class="string">:</span>[<span class="string">&quot;ReadWriteOnce&quot;</span>],<span class="string">&quot;capacity&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;storage&quot;</span><span class="string">:&quot;10Gi&quot;</span>&#125;,<span class="string">&quot;hostPath&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;path&quot;</span><span class="string">:&quot;/tmp/data&quot;</span>&#125;,<span class="string">&quot;storageClassName&quot;</span><span class="string">:&quot;hostpath&quot;</span>&#125;&#125;</span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2020-03-25T14:45:48Z&quot;</span></span><br><span class="line">  <span class="attr">finalizers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">kubernetes.io/pv-protection</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">task-pv-volume</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;4540164&quot;</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/persistentvolumes/task-pv-volume</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">8d0c4711-38f7-456c-a402-14c34ccf2df3</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp/data</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">hostpath</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">phase:</span> <span class="string">Available</span></span><br></pre></td></tr></table></figure>

<h2 id="PV的阶段"><a href="#PV的阶段" class="headerlink" title="PV的阶段"></a>PV的阶段</h2><p>在上面的结果中，<code>status.phase</code>表示PV的所处的阶段。PV的阶段如下：</p>
<ul>
<li><p>Available: 该PV没有被PersistentVolumeClaim（PVC）绑定。</p>
</li>
<li><p>Bound: 该PV已经被PersistentVolumeClaim（PVC）绑定。</p>
</li>
<li><p>Released: 绑定该PV的PersistentVolumeClaim（PVC）已经被删除，但是该PV对应的资源还没有被回收。</p>
</li>
<li><p>Failed: 该PV自动回收失败</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Storage</tag>
        <tag>PersistentVolumes</tag>
      </tags>
  </entry>
  <entry>
    <title>我如何管理数字资产</title>
    <url>/2020/03/21/protect-your-digital-assets/</url>
    <content><![CDATA[<p>我们每一个人基本上都会有很多种移动设备，也会遇到很多问题，比如密码太多了记不住，以及密码很弱不安全，设备丢失导致的文件丢失，以及跨设备工作不方便等等。<br>下面我将尝试着介绍一下我是如何管理我的密码，以及文件同步和备份。以下内容只针对于个人非商业用途。</p>
<span id="more"></span>

<h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><p>作为一只网虫，我会注册很多网站，因此会有很多账户和密码。那么问题来了：</p>
<ul>
<li>如果所有的账户使用同样的密码必然是不安全的</li>
<li>如果密码使用一些有规律的密码也是不安全的，比如与自己个人信息相关，</li>
<li>如果长时间不更换密码不安全</li>
<li>如果密码多了，就很难记忆，也很容易忘记</li>
<li>在不同的设备上总是不停的输入各种密码是很麻烦的</li>
</ul>
<p>如何解决这些问题呢？有很多密码工具可以帮助我们解决这些问题。下面推荐两种：</p>
<h3 id="推荐的工具"><a href="#推荐的工具" class="headerlink" title="推荐的工具"></a>推荐的工具</h3><h4 id="1password"><a href="#1password" class="headerlink" title="1password"></a>1password</h4><p><strong>需要付费订阅</strong>。1Password 是一个由 AgileBits 公司开发的密码管理软件。它能用来存放各种不同的密码，除普通登录密码，信用卡、软件许可证等敏感信息也可一同存放在PBKDF2加密的虚拟保险箱里，由主密码保护。</p>
<h4 id="LastPass"><a href="#LastPass" class="headerlink" title="LastPass"></a>LastPass</h4><p><strong>有免费的版本</strong>。LastPass是一款Freemium的跨平台在线密码管理工具。旨在通过将用户的密码集中在云端以解决密码疲劳。LastPass使用Web界面为基础，但还提供使用于许多现代浏览器的插件和小书签。</p>
<h3 id="我是如何做的"><a href="#我是如何做的" class="headerlink" title="我是如何做的"></a>我是如何做的</h3><p>我使用的是1password，简单说一个1password的使用场景。</p>
<p>在Dell笔记本上创建了一个Twitter账号之后，将密码保存到1password上，当我想在Mac上访问Twitter的时候（使用chrome浏览器），我可以通过1password的插件获取密码登录。当我想在Android手机上的Twitter App上登录的时候，我可以通过1password工具获取密码登录。</p>
<p>1password支持跨平台和自动同步密码，还可以检查网站是否安全以及多个账户是否使用同一个密码等。</p>
<p><strong>使用了1password之后，我自己都不知道自己账户的密码是啥了，都是生成的随机字符串。</strong></p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>虽然我不是一个正儿八经的摄影爱好者，但是也喜欢随手拍拍。那么问题来了：</p>
<ul>
<li>手机的存储空间再大，总会被耗尽的。</li>
<li>手机有可能丢失，丢失之后数据就完全没了。</li>
<li>手机有可能坏，坏了之后数据也可能会丢失。</li>
</ul>
<p>我会经常使用Word写一些文档之类的东西，或者使用Excel制作表格，或者使用一些工程类的源文件。问题主要是：</p>
<ul>
<li>如果将文件存放在本地，换一台电脑上使用的时候就会很不方便。</li>
<li>在我正在写东西的时候，电脑或者应用突然崩了。</li>
<li>小概率事件，硬盘损坏了。</li>
</ul>
<p>对于照片、视频以及文件这一类的资料同步/备份，通常会在云端备份或者本地备份。推荐以下的工具/服务。</p>
<h3 id="推荐的工具-服务"><a href="#推荐的工具-服务" class="headerlink" title="推荐的工具/服务"></a>推荐的工具/服务</h3><h4 id="OneDrive"><a href="#OneDrive" class="headerlink" title="OneDrive"></a>OneDrive</h4><p>OneDrive，全名Microsoft OneDrive，前称Windows Live SkyDrive，是微软所推出的网络硬盘及云端服务。用户可以上传他们的文件到网络服务器上，并且透过网络浏览器来浏览那些文件。更可直接编辑和观看Microsoft Office文件。同时推出同步上传软件，可于电脑直接访问和同步文件。另外，OneDrive并允许用户透过Microsoft Account来限制不同的用户访问文件，允许用户决定是否将文件与公众分享，或是限于联系菜单上的人才能访问；而对所有人公开的文件则不需要Microsoft Account即可访问。</p>
<p>OneDrive与Windows 10和Microsoft Office的集成体验非常好。如果使用Windows 10，可以很方便地将照片、文件拖拽到OneDrive中。如果购买了Office 365，还可以使用office的自动保存功能，编辑中的文件就可以自动保存到OneDrive中。</p>
<p>当跨平台的使用的时候，OneDrive提供了多种客户端。在手机端上还有照片自动上传功能。</p>
<h4 id="iCloud"><a href="#iCloud" class="headerlink" title="iCloud"></a>iCloud</h4><p>iCloud是苹果公司所提供的在线同步存储服务和云端计算服务，初始空间有5GB，可以购买存储空间。用户能在iCloud中存储音乐、照片、App数据、文件、联系人和日历等，并将无线推送到用户所有支持iCloud同步的设备上，而不用使用连接线来同步。iCloud现在可以存储第三方应用的数据并同步苹果设备上。</p>
<p>如果使用Apple全家桶的话，这是绝配。iCloud能够很方便的备份应用数据，照片等资料。</p>
<h4 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h4><p>网络附加存储（英语：Network Attached Storage，缩写：NAS），是一种专门的数据存储技术的名称，它可以直接连接在电脑网络上面，对异质网络用户提供了集中式数据访问服务。</p>
<p>市面上主要的两种NAS品牌：Synology和QNAP。QNAP的性能更高，Synology的用户体验更好。</p>
<h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><p>在我的观点中，将数据保存到哪里，大致取决于两点：</p>
<ol>
<li>能否接受数据丢失？如果不能接受数据丢失，最好的便是使用云服务，或者NAS做RAID。</li>
<li>能否接受数据泄露？如果不能接受数据泄露，最好的便是使用NAS，或者把文件加密之后再保存到云上。</li>
</ol>
<h3 id="我是如何做的-1"><a href="#我是如何做的-1" class="headerlink" title="我是如何做的"></a>我是如何做的</h3><ul>
<li><p>使用Office 365家庭版。<br> Office 365会赠送1TB的OneDrive存储空间。在我使用PPT、Excel以及Word的时候，我会将“自动保存”功能打开，然后我做的东西就会自动保存到OneDrive中。我们会给客户做一些小故事的分享，通常就是下班之后在家做但是我又不喜欢将公司的电脑带回家（公司的电脑就做工作相关的事情，个人学习还是比较喜欢用自己的电脑），我可以在做PPT的时候，PPT会自动保存到OneDrive上，第二天分享的时候，可以在公司的电脑上从OneDrive下载已经做好了PPT，或者直接使用Office Online展示。</p>
<p> 我也会把一些清单做成Excel，即使没有电脑的情况下，我也可以在手机通过“office”应用去查看清单，也可以编辑。</p>
</li>
<li><p>NAS<br> 我有两台NAS，一台专用于vSphere虚拟化环境，一台就是自己平时使用。照片、文件以及笔记都会放在自己平时使用的NAS上。</p>
<p> 我比较喜欢使用BoostNote做笔记，主要记录在工作中或者学习中遇到的问题，在Mac和Windows 上都安装了Synology Drive用来同步一些笔记，这样我家或者公司都能够找到这些笔记，还可以查到历史版本。</p>
<p> 手机上使用Synology Drive来查看文件，使用Synology Moments来同步手机里面的视频和照片到NAS上。想重置手机就重置手机，重要数据都已经备份了。</p>
<p> 我Dell笔记本上的资料盘直接备份到了NAS上，即使重置了电脑也不会担心文件丢失。</p>
<p> 同时我也会把NAS上的照片同步到OneDrive上，这样我就可以通过Windows 10自带的“照片”应用浏览和照片。<br> 我会将个人比较重要的文件加密备份到Synology C2上。</p>
</li>
</ul>
<h3 id="不推荐的备份工具和服务"><a href="#不推荐的备份工具和服务" class="headerlink" title="不推荐的备份工具和服务"></a>不推荐的备份工具和服务</h3><ul>
<li>百度网盘。速度慢以及我对它完全不信任。</li>
<li>移动硬盘/U盘。我认为，移动硬盘或者U盘这一类的设备只是一个临时的传输设备。移动存储设备容易丢失以及损坏。</li>
</ul>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>password</tag>
        <tag>密码</tag>
        <tag>文件备份</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>一键在Rancher上创建一个Kubernetes集群</title>
    <url>/2020/03/20/rancher-vsphere-cluster/</url>
    <content><![CDATA[<p>之前，在Rancher手动的创建Kubernetes集群。为了做一些测试，我会经常创建/删除集群。如果一直手动做这样的事情会比较痛苦。<br>在本文中，将介绍创建Rancher Cluster以及后续的操作。</p>
<span id="more"></span>

<h2 id="创建一个Cluster"><a href="#创建一个Cluster" class="headerlink" title="创建一个Cluster"></a>创建一个Cluster</h2><p>在一个崭新的Rancher上部署一个新的集群。我们需要做如下的事情：</p>
<ol>
<li>创建一个Cloud Credential，之后Node Template需要。</li>
<li>创建Kubernetes Master和Worker Node Template。在Rancher 2.3.5 中， 已经支持手动选择配置，比如Datacenter, Datastore, Folder以及Network等。</li>
<li>创建一个Cluster.</li>
<li>（可选）配置Kubernetes Cloud Provider</li>
</ol>
<p>这是一个重复的过程，因此尝试着使用Terraform将这些可重复的过程代码化，即基础设施即代码（Infrastructure As Code）。我已经将代码保存到了Github上。<a href="https://github.com/chengqing-su/vsphere-cluster-on-rancher">https://github.com/chengqing-su/vsphere-cluster-on-rancher</a></p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>首先，拉取代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:chengqing-su&#x2F;vsphere-cluster-on-rancher.git</span><br></pre></td></tr></table></figure>
<p>然后，新建一个文件<code>terraform/terraform.tfvars</code>，编辑如下内容并复制到文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; &quot;&lt;YOUR-CLUSTER-NAME&gt;&quot;</span><br><span class="line">rancher_url &#x3D; &quot;&lt;YOUR-RANCHER-URL&gt;&quot;</span><br><span class="line">rancher_access_key &#x3D; &quot;&lt;YOUR-RANCHER-ACCESS-KEY&gt;&quot;</span><br><span class="line">rancher_secret_key &#x3D; &quot;&lt;YOUR-RANCHER-SECRET-KEY&gt;&quot;</span><br><span class="line"></span><br><span class="line">vcenter_server &#x3D; &quot;&lt;YOUR-VCENTER-IP-OR-DOMAIN&gt;&quot;</span><br><span class="line">vcenter_username &#x3D; &quot;&lt;YOUR-VCENTER-USERNAME&gt;&quot;</span><br><span class="line">vcenter_password &#x3D; &quot;&lt;YOUR-VCENTER-PASSWORD&gt;&quot;</span><br><span class="line">vcenter_datacenter &#x3D; &quot;&lt;YOUR-VCENTER-DATACENTER&gt;&quot; #absolute path, like &#x2F;datacenter</span><br><span class="line">vcenter_datastore &#x3D; &quot;&lt;YOUR-VCENTER-DATASTORE&gt;&quot; #absolute path, like &#x2F;&lt;your-datacenter-name&gt;&#x2F;datastore&#x2F;&lt;your-datastore-name&gt;&quot;</span><br><span class="line">vcenter_folder &#x3D; &quot;&lt;YOUR-VCENTER-VM-FOLDER&gt;&quot; #absolute path, like &#x2F;&lt;your-datacenter-name&gt;&#x2F;vm&#x2F;&lt;your-vm-folder&gt;&quot;</span><br><span class="line">vcenter_resourcepool &#x3D; &quot;&lt;YOUR-VCENTER-RESOURCE-POOL&gt;&quot; # absolute path, like &#x2F;&lt;your-datacenter-name&gt;&#x2F;host&#x2F;&lt;your-cluster-name&gt;&#x2F;Resources&#x2F;&lt;your-resource-pool&gt;</span><br></pre></td></tr></table></figure>
<p>然后，运行自动化脚本<code>auto/deploy</code>一键部署。</p>
<p>当不需要这个集群的时候可以运行<code>auto/destory</code>一键删除。</p>
<h2 id="创建Cluster之后"><a href="#创建Cluster之后" class="headerlink" title="创建Cluster之后"></a>创建Cluster之后</h2><p>在我们创建好了一个Cluster之后，我们还要一些后续的操作帮助我们由更好的体验。</p>
<h3 id="创建一个默认Storage-Class"><a href="#创建一个默认Storage-Class" class="headerlink" title="创建一个默认Storage Class"></a>创建一个默认Storage Class</h3><p>我们知道PV的创建总共由两种方式，第一种是管理员直接创建，第二种是用通过Storage Class动态创建。因此我们经常需要创建一个Storage Class来使用存储资源。</p>
<p>下面是Storage Class的manifest：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">storageclass.kubernetes.io/is-default-class:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vsphere</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">datastore:</span> <span class="string">&lt;YOUR-DATASTORE&gt;</span></span><br><span class="line">  <span class="attr">diskformat:</span> <span class="string">thin</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/vsphere-volume</span></span><br></pre></td></tr></table></figure>

<p>使用kubectl命令apply一下上面的manifest就可以创建一个默认的Storage Class.</p>
<h3 id="配置Loadbalancer"><a href="#配置Loadbalancer" class="headerlink" title="配置Loadbalancer"></a>配置Loadbalancer</h3><p>在创建一个LoadBalancer类型的Service的时候，发现一直不成功。<br>为了解决这个问题，可以在App种安装一个叫做metallb的应用。安装完成之后，还需要创建一个ConfigMap，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metallb</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metallb-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">config:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">address-pools:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">layer2</span></span><br><span class="line">      <span class="attr">addresses:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.10</span><span class="number">-192.168</span><span class="number">.0</span><span class="number">.50</span> <span class="comment">#修改此处地址为你的地址</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>vSphere</tag>
        <tag>Terraform</tag>
        <tag>Rancher</tag>
      </tags>
  </entry>
  <entry>
    <title>Volume</title>
    <url>/2020/03/17/volumes/</url>
    <content><![CDATA[<p>当一个容器崩溃了，kubelet将会尝试重启它，但是之前容器中的文件将会丢失。另外，一个Pod中多个容器之间共享文件也是必需的。Kubernetes提供了一个Volume抽象概念来解决这些问题。</p>
<span id="more"></span>

<h2 id="Volume的生命周期"><a href="#Volume的生命周期" class="headerlink" title="Volume的生命周期"></a>Volume的生命周期</h2><p><strong>Volume的生命周期与Pod一致</strong>。当Pod停止，Volume也将停止。<br><strong>比Pod中的任何容器存活时间长</strong>。容器如果意外退出后，可能会自动重启。</p>
<h2 id="如何使用Volume"><a href="#如何使用Volume" class="headerlink" title="如何使用Volume"></a>如何使用Volume</h2><p>通过<code>.spec.volumes</code>字段为Pod指定一组Volume。<br>通过<code>.spec.containers[*].volumeMounts</code>为某一个容器挂在一组Volume。</p>
<p>示例： 创建一个Nginx的deployment并暴露出去，在浏览器中请求该服务，显示”Hello World!”</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">--- </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-app</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">            <span class="attr">name:</span>  <span class="string">web-dir</span></span><br><span class="line">      <span class="attr">initContainers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">          <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;sh&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;echo &#x27;Hello World!&#x27;&gt; /web/index.html&quot;</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/web</span></span><br><span class="line">            <span class="attr">name:</span>  <span class="string">web-dir</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-dir</span></span><br><span class="line">        <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;volumes&#x2F;example-01.yaml</span><br><span class="line">kubectl proxy --port 8081</span><br></pre></td></tr></table></figure>

<p>在浏览器打开<a href="http://localhost:8081/api/v1/namespaces/default/services/nginx-service/proxy/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%A7%81%60Hello">http://localhost:8081/api/v1/namespaces/default/services/nginx-service/proxy/就可以看见`Hello</a> World!`</p>
<h2 id="Volume的类型"><a href="#Volume的类型" class="headerlink" title="Volume的类型"></a>Volume的类型</h2><p>Kubenetes支持的Volume很多，详细的可以看<a href="https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes%E3%80%82">https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes。</a><br>我大致将其分为如下四类：</p>
<ol>
<li>云提供者提供的存储资源：<code>awsElasticBlockStore</code>、<code>azureDisk</code>、<code>azureFile</code>、<code>gcePersistentDisk</code>、<code>vsphereVolume</code>（vSphere）和<code>cinder</code>（OpenStack）。</li>
<li>Kubernetes对象和集群中的存储资源：<code>configMap</code>、<code>secret</code>、<code>downwardAPI</code>、<code>emptyDir</code>、<code>projected</code>、<code>local</code>、<code>hostPath</code>和<code>persistentVolumeClaim</code>。</li>
<li>其他外部存储资源：<code>cephfs</code>、<code>fc (fibre channel)</code>、<code>flocker</code>、<code>gitRepo (deprecated)</code>、<code>glusterfs</code>、<code>iscsi</code>、<code>nfs</code>、<code>portworxVolume</code>、<code>quobyte</code>、<code>rbd</code>、<code>scaleIO</code> 和<code>storageos</code>。</li>
<li>插件：<code>Container Storage Interface (CSI)</code> 和 <code>FlexVolume</code></li>
</ol>
<h3 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a><code>emptyDir</code></h3><p>该类型的Volume是一个临时的空间，主要用来临时存储数据。当Pod被删除（被kubelet驱逐，手动删除等）时，在该类型Volume上的数据会被永久清除。<br>上面的示例中使用的就是该类型的Volume。还可以用来在不同容器之间共享数据。</p>
<h3 id="configMap、secret和downwardAPI"><a href="#configMap、secret和downwardAPI" class="headerlink" title="configMap、secret和downwardAPI"></a><code>configMap</code>、<code>secret</code>和<code>downwardAPI</code></h3><p>ConfigMap 和 Secret 是Kubernetes对象。<br>ConfigMap用于存储配置信息，Secret用来存储敏感信息（比如密码），这两种资源可以挂载到Pod上作为Volume。<br><code>downwardAPI</code>类型的Volume用来使应用程序可以使用下行的API数据。</p>
<p>如果一个应用程序需要很多很多配置信息和敏感信息，如果直接挂载Pod上会很麻烦。<code>projected</code>可以帮助我们将多个volume映射到同一个目录下。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>k8s</tag>
        <tag>Storage</tag>
        <tag>Volume</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化脚本的一些原则与实践</title>
    <url>/2020/03/02/auto-script/</url>
    <content><![CDATA[<p>在实现持续集成前，有一项很重要的工作就是自动化构建。</p>
<p>自动化构建必须满足一个条件：<strong>人和计算机都能通过命令行自动执行应用的构建、测试以及部署过程</strong>。而自动化脚本就是将自动化构建脚本化的产物。</p>
<p>本文中，将介绍一些自动化脚本的原则和实践。</p>
<span id="more"></span>

<h3 id="自动化脚本应当与业务代码放在同一个版本库中"><a href="#自动化脚本应当与业务代码放在同一个版本库中" class="headerlink" title="自动化脚本应当与业务代码放在同一个版本库中"></a>自动化脚本应当与业务代码放在同一个版本库中</h3><p>自动化脚本和业务代码是同样重要的，应当有版本控制。放在同一个版本库中，能够让开发人员和运维人员更好地配合。<strong>推荐将所有的自动化脚本都放在<code>auto</code>目录下。</strong> </p>
<p>一个pipeline的最终形态并不是在软件开发一开始就能确定的，最开始的时候可能只需要单元测试和代码风格检查，随着软件的开发，会逐步增加<code>build</code>,<code>smoke-test</code>,<code>deploy-to-production</code>等步骤。<strong>pipeline的构建以及自动化脚本都是增量式演进的</strong></p>
<h3 id="为pipeline中的每一个阶段中的每一步创建自动化脚本"><a href="#为pipeline中的每一个阶段中的每一步创建自动化脚本" class="headerlink" title="为pipeline中的每一个阶段中的每一步创建自动化脚本"></a>为pipeline中的每一个阶段中的每一步创建自动化脚本</h3><p>一个pipeline通常会定义多个阶段，比如test-&gt;build-&gt;deploy，阶段之间一定是串行的。而一个阶段中会有一步或者多步，每步之间可以是串行的也可以是并行的，比如，在test阶段，我们会执行单元测试、代码风格检查，这两步没有任何逻辑上的依赖，因此它们可以并行运行的。</p>
<p>应该为pipeline中的每一个阶段中的每一步都创建自动化脚本。这样做的好处：</p>
<ul>
<li>能够保证<strong>一个脚本只做一件事情</strong>。一个阶段中某一步已经确定了这个脚本的功能边界，因此该脚本只负责这一步的功能。</li>
<li><strong>自动化脚本的命名应当有意义</strong>。因为功能边界已经限制住，pipeline中的每一步我们都是明确知道是做什么的，因此而我们能够更好得对其命名。推荐脚本的命名方式是<code>动词+名词</code>的风格，比如脚本的功能是部署到QA环境的，那么脚本命名可以为<code>deploy-to-qa</code>。我们推荐脚本不加任何后缀，采用shebang机制。</li>
</ul>
<h3 id="在本地PC和CI上运行结果应当一致"><a href="#在本地PC和CI上运行结果应当一致" class="headerlink" title="在本地PC和CI上运行结果应当一致"></a>在本地PC和CI上运行结果应当一致</h3><p>在这一条实践中，有一个隐含的条件就是<strong>自动化脚本在本地应当是可执行的</strong>，即需要在本地PC上执行所编写的自动化脚本。需要保证在本地PC和CI上运行结果应当一致，比如，我们现在有一个单元测试的自动化脚本<code>auto/test</code>，我们在开发过程中使用该脚本运行该脚本可以帮助我们提前发现问题，该脚本在本地运行通过，那么在CI上运行也一定是过的。</p>
<p>但是当本地环境和CI的环境不一致时，脚本可能会执行失败，比如jq在Mac OS上和在Linux上是有区别的。这个时候可以考虑<strong>使用容器化的方式保证环境的一致性</strong></p>
<h3 id="使用同样的脚本向所有环境部署"><a href="#使用同样的脚本向所有环境部署" class="headerlink" title="使用同样的脚本向所有环境部署"></a>使用同样的脚本向所有环境部署</h3><p>在软件的开发过程中，我们可能会有测试环境、QA环境、类生产环境、生产环境等。这些环境之间的区别是资源配置信息不同。自动化脚本<code>auto/deploy</code>可以将应用部署到不同的环境上，在上面有提到要为pipeline中的每一步提供自动化脚本，而部署到测试环境和部署到生产环境明显是不同的两步，我们可以将测试环境相关的配置信息放入到<code>auto/deploy-to-test</code>脚本中去，将生产环境相关的配置信息放入到<code>auto/deploy-to-production</code>中，这两个脚本会去调<code>auto/deploy</code>去做部署。</p>
<h3 id="确保部署流程是幂等的"><a href="#确保部署流程是幂等的" class="headerlink" title="确保部署流程是幂等的"></a>确保部署流程是幂等的</h3><p>无论开始部署时目标环境处于何种状态，部署流程应该总是令目标环境达到同样的状态，并以之为结束点。</p>
<p>同一个commit，无论触发多少次构建，最终的结果都应该是一致的。</p>
<h3 id="自动化脚本应当对具体的CI工具解耦"><a href="#自动化脚本应当对具体的CI工具解耦" class="headerlink" title="自动化脚本应当对具体的CI工具解耦"></a>自动化脚本应当对具体的CI工具解耦</h3><p>在软件的部署过程中，我们需要给应用程序指定一个版本号，而CI工具正好提供一个Build number，比如Gitlab的<code>CI_PIPELINE_ID</code>, Buildkite的<code>BUILDKITE_BUILD_NUMBER</code>，因此在脚本中直接使用这些环境变量就能获取一个版本号。<strong>但是不推荐这样使用CI提供的环境变量</strong>，这样会造成你的自动化脚本与CI工具强耦合，以后切换CI工具的时候会很痛。</p>
<h3 id="使用相对路径"><a href="#使用相对路径" class="headerlink" title="使用相对路径"></a>使用相对路径</h3><p>使用绝对路径会让构建流程与某台特定的机器形成强依赖，从而很难被用于配置和维护其他服务器。</p>
<h3 id="消除手工步骤"><a href="#消除手工步骤" class="headerlink" title="消除手工步骤"></a>消除手工步骤</h3><p>消除手工或者通过图形用户界面工具来部署软件。部署过程应当是通过自动化脚本自动完成的，而不是根据一个很详细的文档，这文档中包含了每一步做什么，执行什么命令。使用手工部署会增加部署成本，同时增加出错的可能性。</p>
<h3 id="不要把任何生成物放到版本控制库"><a href="#不要把任何生成物放到版本控制库" class="headerlink" title="不要把任何生成物放到版本控制库"></a>不要把任何生成物放到版本控制库</h3><p>在一次部署的过程中，可能会生成一个Docker镜像、Java的War包或者AWS Lambda Code的zip包。这些生成物应该放入其对应的文件存储系统，而不是直接放回到版本库中。如果这些生成物丢失了或者需要重新生成，应该通过触发Pipeline的方式去重新生成。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>AutoScript</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>Service</title>
    <url>/2020/02/29/service/</url>
    <content><![CDATA[<p>Service是Kubernetes的核心概念，通过创建Service，可以为一组具有相同功能的容器应用提供一个统一的入口地址，并且将请求负载分发到后端的各个容器应用上。</p>
<span id="more"></span>

<h2 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h2><p>该示例是将Service的80端口映射到具有<code>app: nginx</code>标签的Pod上。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>spec.selector</code>: 通过label选择需要将流量转发哪些Pod。</p>
<p><code>spec.ports[].port</code>: 这个Service将会暴露的端口。该端口需要是一个整型。</p>
<p><code>spec.ports[].targetPort</code>: 目标Pod的端口号或者端口名称。如果是端口名称，则必须是<a href="https://tools.ietf.org/html/rfc6335"><code>IANA_SVC_NAME</code></a>。如果不指定，则<code>targetPort</code>的值与<code>port</code>是一致。</p>
<p>关于Service Spec更多配置，请查看官方<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/#servicespec-v1-core">API Reference</a></p>
<p>通过如下执行命令创建一个Service：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;service&#x2F;nginx-service.yaml</span><br></pre></td></tr></table></figure>

<p>我们可以得到下面的结果：</p>
<p><img src="create-service.png" alt="create-service.png"></p>
<h2 id="Service的类型（Service的访问方式）"><a href="#Service的类型（Service的访问方式）" class="headerlink" title="Service的类型（Service的访问方式）"></a>Service的类型（Service的访问方式）</h2><p>上面的截图中，我们可以看见Service是有类型的。可以通过<code>spec.type</code>指定Service的类型，有<code>ClusterIP</code>、<code>NodePort</code>、<code>LoadBalancer</code> 和<code>ExternalName</code>四种。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ClusterIP</td>
<td>默认的Service类型。使用集群内部的IP公开Service，使用该类型之后，服务只有在集群的内部被访问</td>
</tr>
<tr>
<td>NodePort</td>
<td>通过静态端口（NodePort）在每个节点的IP上公开Service。</td>
</tr>
<tr>
<td>LoadBalancer</td>
<td>使用云提供商的负载平衡器对外公开Service。</td>
</tr>
<tr>
<td>ExternalName</td>
<td>通过返回CNAME记录，将服务映射到externalName字段的内容（例如foo.bar.example.com）</td>
</tr>
</tbody></table>
<h2 id="为什么需要Service"><a href="#为什么需要Service" class="headerlink" title="为什么需要Service?"></a>为什么需要Service?</h2><p>为了更好地理解Service，我们可以创建一个Deployment，相关的代码如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.16</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>通过下面的命令创建该Deployment：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;service&#x2F;nginx-deployment.yaml</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="create-deployment.png" alt="create-deployment.png"></p>
<p>这时候我们可以看到<code>Endpoints</code>中有了值，这些IP就是Deployment所创建的Pod的IP。</p>
<p>现在需要把Deployment所管理的应用暴露给集群内部的应用A使用，应用A可以使用Pod的IP或者通过Service去访问该应用。</p>
<p>但是应用总是在不停的升级迭代中，而Pod在一开始设计的时候就没有被当作一个会永久存在的对象。Pod总会死的，死了之后也不会被复活。</p>
<p>现在，尝试着更新一下上面的这个Nginx应用。执行下面的命令可以升级nginx到1.17, 不推荐通过该方式去升级生产环境上的任何应用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl set image deployment nginx-deployment nginx&#x3D;nginx:1.17</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="update-deployment.png" alt="update-deployment.png"></p>
<p><code>Endpoints</code>发生了改变，Deployment之前所创建的Pod已经被删除，<code>Endpoints</code>指向的是新的Pod。应用A如果使用了Pod的IP访问该应用，此时它就需要更新它的访问IP。</p>
<p><strong>Service是一种抽象，定义了Pod的逻辑集和访问Pod的策略（有时将该模式称为微服务）。</strong> 我们的具体应用都是运行在Pod中，而Pod又是不稳定的，如果直接使用Pod到Pod的通信会有很大的维护成本。 而Service是相对稳定的，能给其他应用提供一个稳定的接口。这也可以帮助我们对Pod进行解耦。</p>
<h2 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h2><p>有些时候，我们并不需要Service提供的默认负载均衡功能和一个Service IP，或者其他应用希望知道该Service下面的实例。可以将<code>spec.clusterIP</code>设置为<code>None</code>来实现一个Headless Service。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title>Job</title>
    <url>/2020/02/26/job/</url>
    <content><![CDATA[<p>一个Job会创建一个或多个Pod，并保证这些Pod成功终止。</p>
<p>一个简单的场景，创建一个Job以保证一个Pod可靠地执行完成。如果第一个Pod执行失败或者在未执行完成前被删除，Job将会启动一个新的Pod。</p>
<span id="more"></span>

<h2 id="一个简单的案例"><a href="#一个简单的案例" class="headerlink" title="一个简单的案例"></a>一个简单的案例</h2><p>计算π的小数点后的2000位。该manifest以上传到了Github上，地址是：<a href="https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/job/pi.yaml">https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/job/pi.yaml</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<p>在该示例中，指定<code>restartPolicy</code>的值为<code>Never</code>。是否可以不指定呢？不可以，这个字段对Job来说是必须指定的，因为 Job 只支持<code>Never</code>和<code>OnFailure</code>，而<code>restartPolicy</code>的默认值是<code>Always</code>。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;job&#x2F;pi.yaml</span><br></pre></td></tr></table></figure>

<p>过程：</p>
<p><img src="create.gif" alt="create"></p>
<h2 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h2><p>在介绍Job的任务类型之前，会先介绍两个相关的字段：</p>
<p><code>.spec.completions</code>：指定该Job所期待成功完成的Pod数量。只有成功运行完指定数量的Pod之后，Job才会变成完成状态。默认值为1。</p>
<p><code>.spec.parallelism</code>：指定Job在任何给定时间应运行的Pod的最大数目。默认值为1。</p>
<h3 id="非并行Job"><a href="#非并行Job" class="headerlink" title="非并行Job"></a>非并行Job</h3><p>不需要指定上面的两个字段。</p>
<p>除非Pod发生故障，否则仅启动一个Pod。一旦该Pod成功终止，Job进入完成状态。</p>
<p>上面示例中的Job就是非并行Job。</p>
<h3 id="固定完成计数的并行Job"><a href="#固定完成计数的并行Job" class="headerlink" title="固定完成计数的并行Job"></a>固定完成计数的并行Job</h3><p>必须为<code>.spec.completions</code>指定一个非零的正值，比如N。只有1到N这个范围中的每个值都有一个成功的Pod时，Job才会进入完成状态。</p>
<p><code>.spec.parallelism</code>可以不指定。下面的示例中<code>.spec.completions</code>为6，<code>.spec.parallelism</code>为2. Github地址：<a href="https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/job/pi-fixed.yaml">https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/job/pi-fixed.yaml</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">6</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<p>该示例的执行过程如下：<br><img src="fixed.gif" alt="fixed"></p>
<p>每次最多有2个Pod在创建或者运行状态，只有这2个运行完成之后，后续的Pod才能创建。当有6个Pod成功终止后，Job完成。</p>
<h3 id="具有工作队列的并行Job"><a href="#具有工作队列的并行Job" class="headerlink" title="具有工作队列的并行Job"></a>具有工作队列的并行Job</h3><p>不能指定<code>.spec.completions</code>的值，同时需要为<code>.spec.parallelism</code>指定一个非负整数N。Job会启动N个Pod, 当其中的一个Pod成功终止，其他的Pod也都终止时，Job进入完成状态。当一个Pod成功退出后，其他的Pod不应该继续为这个Job做任何工作或者任何输出，它们都应该进入退出的过程。</p>
<p>下面的示例中<code>.spec.completions</code>没有指定，<code>.spec.parallelism</code>为2. Github地址：<a href="https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/job/pi-work.yaml">https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/job/pi-work.yaml</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<p>该示例的执行过程如下：<br><img src="work-queue.gif" alt="work-queue"></p>
<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>Job完成后，不会再创建其他Pod，但是Pod也不会被删除。因此可以查看已完成的容器的日志，检查是否有错误、警告或其他诊断输出。Job也会保留下来，但是通常情况下，系统是不需要这些已经完成了的Job。如果将它们保留在系统中会给API服务器带来压力。如何来清理这些Job？</p>
<ul>
<li><p>如果Job是直接被CornJob管理，则可以通过指定CornJob的策略来进行清理。</p>
</li>
<li><p>手动删除。比如，上面的示例都可以通过<code>kubectl delete jobs pi</code>来清理。</p>
</li>
<li><p>（该功能还处于alpha状态）使用TTL机制自动删除已完成或者失败了的Job。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>k8s</tag>
        <tag>Controller</tag>
        <tag>Job</tag>
      </tags>
  </entry>
  <entry>
    <title>DaemonSet</title>
    <url>/2020/02/21/daemon-set/</url>
    <content><![CDATA[<p>DaemonSet 确保所有（或某些）节点都运行Pod的副本。Daemon 在计算机中领域的意思是守护程序。</p>
<p>当一个新的节点被添加集群时，DaemonSet 会在该节点上创建一个新的Pod。当一个节点从集群中删除时，这些Pod会被回收。删除DaemonSet将清除其创建的Pod。</p>
<span id="more"></span>

<h2 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h2><p>在每一个Node上都运行一个<code>nginx:1.16</code>的Pod。Github 链接：<a href="https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/daemon-set/nginx-daemon-set.yaml%E3%80%82">https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/daemon-set/nginx-daemon-set.yaml。</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-daemon-set</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.16</span></span><br></pre></td></tr></table></figure>

<h2 id="创建-更新-删除"><a href="#创建-更新-删除" class="headerlink" title="创建/更新/删除"></a>创建/更新/删除</h2><p>在此之前，我已经创建了一个3个master节点，3个worker节点的Kubernetes集群。</p>
<p><img src="nodes.png" alt="nodes"></p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;daemon-set&#x2F;nginx-daemon-set.yaml</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="create.gif" alt="create"></p>
<p>DaemonSet 也是直接去管理Pod的，下面展示的是<code>nginx-daemon-set-d6c6l</code>的<code>metadata</code>.其<code>metadata.ownerReferences</code>指向的是上面创建的名为<code>nginx-daemon-set</code>的DaemonSet。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">cni.projectcalico.org/podIP:</span> <span class="number">10.42</span><span class="number">.5</span><span class="number">.218</span><span class="string">/32</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2020-02-25T12:27:10Z&quot;</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">nginx-daemon-set-</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">controller-revision-hash:</span> <span class="string">59d5958c9f</span></span><br><span class="line">    <span class="attr">pod-template-generation:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-daemon-set-d6c6l</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-daemon-set</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">fd40fc4d-c31f-42ca-bdc3-48c13e7348f1</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;11004234&quot;</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/pods/nginx-daemon-set-d6c6l</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">2dde39cb-867c-46a9-b211-22d88e489d9a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>升级nginx容器的版本到<code>1.17</code>。创建了一个新的manifest，其地址是：<a href="https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/daemon-set/nginx-daemon-set-update.yaml">https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/daemon-set/nginx-daemon-set-update.yaml</a></p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;daemon-set&#x2F;nginx-daemon-set-update.yaml</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="update.gif" alt="update"></p>
<p>DeamonSet 更新PodTemplate之后，会自动删除旧的Pod，然后再根据新的PodTemplate创建新的Pod。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="从DaemonSet中删除一个Pod"><a href="#从DaemonSet中删除一个Pod" class="headerlink" title="从DaemonSet中删除一个Pod"></a>从DaemonSet中删除一个Pod</h4><p>从上述DaemonSet中删除名为<code>nginx-daemon-set-cpqqd</code>的Pod</p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete pod nginx-daemon-set-cpqqd</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="delete-a-pod.gif" alt="delete-a-pod"></p>
<p>当该Pod被删除之后，DaemonSet会再旧Pod运行的节点上启动一个新的Pod。</p>
<h4 id="删除-DaemonSet"><a href="#删除-DaemonSet" class="headerlink" title="删除 DaemonSet"></a>删除 DaemonSet</h4><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete daemonset nginx-daemon-set</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="delete.gif" alt="delete"></p>
<h2 id="什么时候使用"><a href="#什么时候使用" class="headerlink" title="什么时候使用"></a>什么时候使用</h2><p>DaemonSet的一些典型用法是：</p>
<ul>
<li><p>在每个节点上运行集群存储守护程序，例如glusterd，ceph。</p>
</li>
<li><p>在每个节点上运行日志收集守护程序，例如fluentd或filebeat。</p>
</li>
<li><p>在每个节点（例如Prometheus Node Exporter，Flowmill，Sysdig Agent，collected，Dynatrace OneAgent，AppDynamics Agent，Datadog代理，New Relic代理，Ganglia gmond，Instana代理或Elastic Metricbeat）上运行节点监视守护程序。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>k8s</tag>
        <tag>DaemonSet</tag>
        <tag>Controller</tag>
      </tags>
  </entry>
  <entry>
    <title>StatefulSet</title>
    <url>/2020/02/20/stateful-set/</url>
    <content><![CDATA[<p>StatefulSet是用于来管理有状态应用的对象。StatefulSet管理了一组Pod的部署和伸缩，并保证了这些Pod的顺序和唯一性。</p>
<p>像Deployment一样，StatefulSet管理基于相同容器规范的Pod。与Deployment不同，StatefulSet为其每个Pod维护一个<a href="#sticky_identity"><strong>粘性身份</strong></a>。这些Pod是根据相同的spec创建的，但不能互换，因为每个Pod都有一个永久性标识符，该标识符在任何重新计划中都会维护。</p>
<span id="more"></span>

<h2 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web-stateful-set</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-stateful-set</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># has to match .spec.template.metadata.labels</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># by default is 1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># has to match .spec.selector.matchLabels</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [ <span class="string">&quot;ReadWriteOnce&quot;</span> ]</span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>

<p>上面的Service是一个Headless Service，用来控制网络域。</p>
<p><code>spec.serviceName</code>： 必须字段。serviceName是管理此StatefulSet的服务名称。并且负责该集合的网络标识。Pod会遵循以下格式获取DNS/主机名：<code>pod-specific-string.serviceName.default.svc.cluster.local</code>，其中<code>pod-specific-string</code>由StatefulSet控制器管理。</p>
<p>该manifest已保存到Github：<a href="https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/stateful-set%20/nginx-stateful-set.yaml">https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/stateful-set%20/nginx-stateful-set.yaml</a></p>
<h2 id="如何创建-更新-删除一个StatefulSet"><a href="#如何创建-更新-删除一个StatefulSet" class="headerlink" title="如何创建/更新/删除一个StatefulSet"></a>如何创建/更新/删除一个StatefulSet</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;stateful-set%20&#x2F;nginx-stateful-set.yaml</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="create.gif" alt="create"></p>
<h4 id="如何管理Pod"><a href="#如何管理Pod" class="headerlink" title="如何管理Pod"></a>如何管理Pod</h4><p>与 Deployment 不同的是， StatefulSet 是直接管理Pod的。下面展示的是<code>web-stateful-set-0</code>的<code>metadata</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2020-02-20T12:52:31Z&quot;</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">web-stateful-set-</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">controller-revision-hash:</span> <span class="string">web-stateful-set-7579f5f4d9</span></span><br><span class="line">    <span class="attr">statefulset.kubernetes.io/pod-name:</span> <span class="string">web-stateful-set-0</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-stateful-set-0</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web-stateful-set</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">c509a152-6096-44a9-aea9-b4b9f5168c86</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;2219083&quot;</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/pods/web-stateful-set-0</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">5da1a0a6-a952-40c5-96d5-f32048f4e5a6</span></span><br></pre></td></tr></table></figure>

<h4 id="粘性身份"><a href="#粘性身份" class="headerlink" title="粘性身份"></a><span id="sticky_identity">粘性身份</span></h4><p>ReplicaSet 创建的Pod的名称是由ReplicaSet的名称和一个随机字符串组成，比如<code>web-server-jqxfq</code>。 Deployment 是通过ReplicaSet管理Pod，因此名称规则和 ReplicaSet 一致。</p>
<p>StatefulSet 有一个唯一的身份，它由一个序数、一个稳定的网络身份和稳定的存储组成。无论它(重新)调度在哪个节点上，标识都与Pod保持一致。</p>
<ul>
<li>其序数是从0到N-1（其中N为Pod的数量）。</li>
<li>稳定的网络身份。StatefulSet中的每个Pod都从StatefulSet的名称和Pod的序数派生其主机名。 构造的主机名的模式为<code>$(StatefulSet name)-$(序数)</code>。 上面的示例了创建三个名为<code>web-stateful-set-0</code>，<code>web-stateful-set-1</code>，<code>web-stateful-set-2</code>的Pod。</li>
<li>稳定的存储。Kubernetes为每个<code>VolumeClaimTemplate</code>创建一个<code>PersistentVolume</code>。将Pod调度（重新）到节点上时，其<code>volumeMounts</code>会安装与其<code>PersistentVolume Claims</code>关联的<code>PersistentVolumes</code>。<strong>删除Pod或StatefulSet时，不会删除与Pods的PersistentVolume声明关联的PersistentVolumes，必须手动完成。</strong></li>
</ul>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>将上述manifest中的nginx的版本升级到1.17，新的一份manifest：<a href="https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/stateful-set%20/nginx-stateful-set-update.yaml">https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/stateful-set%20/nginx-stateful-set-update.yaml</a></p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;stateful-set%20&#x2F;nginx-stateful-set-update.yaml</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="update.gif" alt="update"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;stateful-set%20&#x2F;nginx-stateful-set-update.yaml</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete sts web-stateful-set</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="delete.gif" alt="delete"></p>
<h3 id="部署和伸缩的保证"><a href="#部署和伸缩的保证" class="headerlink" title="部署和伸缩的保证"></a>部署和伸缩的保证</h3><p>在上面的创建/更新/删除的操作中，能够更好的验证下述规则。</p>
<ul>
<li><p>对于具有N个副本的StatefulSet，在部署Pod时，将按{0..N-1}的顺序顺序创建它们。</p>
</li>
<li><p>删除Pod时，它们以相反的顺序从{N-1..0}终止。</p>
</li>
<li><p>在对Pod进行缩放操作之前，其所有前面的Pod必须处于“运行且就绪”状态。</p>
</li>
<li><p>在终止Pod之前，必须完全关闭其所有后面所有的。</p>
</li>
</ul>
<h2 id="什么时候使用"><a href="#什么时候使用" class="headerlink" title="什么时候使用"></a>什么时候使用</h2><p>StatefulSet对于需要以下一项或多项的应用程序非常有用。</p>
<ul>
<li><p>稳定的唯一网络标识符。</p>
</li>
<li><p>稳定（跨Pod调度/重新计划的持久性），持久的存储。</p>
</li>
<li><p>有序，顺畅的部署和扩展。</p>
</li>
<li><p>有序的自动滚动更新。</p>
</li>
</ul>
<h2 id="有哪些局限"><a href="#有哪些局限" class="headerlink" title="有哪些局限"></a>有哪些局限</h2><ul>
<li><p>给定Pod的存储必须由PersistentVolume提供者根据请求的存储类进行设置，或者由管理员预先设置。</p>
</li>
<li><p>删除或缩小StatefulSet不会删除与StatefulSet关联的卷。这样做是为了确保数据安全，这通常比自动清除所有相关的StatefulSet资源有价值。</p>
</li>
<li><p>StatefulSet当前需要Headless Service来负责Pod的网络身份。</p>
</li>
<li><p>删除StatefulSet时，StatefulSet不提供有关Pod终止的任何保证。为了实现StatefulSet中Pod的有序且正常的终止，可以在删除之前将StatefulSet缩小为0。</p>
</li>
<li><p>如果将滚动更新与默认的Pod管理策略（OrderedReady）结合使用，则可能会陷入损坏状态，需要人工干预才能进行修复。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>k8s</tag>
        <tag>Controller</tag>
        <tag>StatefulSet</tag>
      </tags>
  </entry>
  <entry>
    <title>Deployments</title>
    <url>/2020/02/13/deployments/</url>
    <content><![CDATA[<p>Deployment为Pod和ReplicaSets提供了声明性更新（简单理解，就是直接使用kubectl apply更新ReplicaSets中的Pod配置）。</p>
<span id="more"></span>

<h2 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h2><p>在该实例中，将部署3个版本为1.16的nginx. 示例地址：<a href="https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/deployment/nginx-deployment.yaml">https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/deployment/nginx-deployment.yaml</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 # 可选，用于指定所期望的Pod的数量。默认为1。</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template: # Pod的模板</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.16</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>

<h2 id="创建一个新的Deployment"><a href="#创建一个新的Deployment" class="headerlink" title="创建一个新的Deployment"></a>创建一个新的Deployment</h2><p>使用声明式的方式去部署一下上面的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;deployment&#x2F;nginx-deployment.yaml</span><br></pre></td></tr></table></figure>

<p>过程 &amp; 结果：</p>
<p><img src="create-a-new.gif" alt="create-a-new"></p>
<p>可以看到的是，在上述的部署过程中，有一个名为<code>nginx-deployment-79fb9cc9bb</code>的ReplicaSet被创建，还有以<code>nginx-deployment-79fb9cc9bb</code>为前缀的Pod被创建。</p>
<h2 id="更新一个的Deployment"><a href="#更新一个的Deployment" class="headerlink" title="更新一个的Deployment"></a>更新一个的Deployment</h2><p>我将上面示例中nginx的版本升级到了1.17。并创建了一个新的manifests，其地址为<a href="https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/deployment/nginx-deployment-update.yaml%E3%80%82">https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/deployment/nginx-deployment-update.yaml。</a></p>
<p>使用声明式的方式去部署一下上面的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;deployment&#x2F;nginx-deployment-update.yaml</span><br></pre></td></tr></table></figure>

<p>过程 &amp; 结果：</p>
<p><img src="update.gif" alt="update"></p>
<p>可以看到的是，在上述的部署过程中，有一个名为<code>nginx-deployment-6c5bfff4d9</code>的ReplicaSet被创建，开始的时候里面只有一个Pod，然后逐渐增加到3，同旧的ReplicaSet管理的pod数量逐渐减少，直至为0。</p>
<p>在上述的manifest中我都没有指定其部署策略，Deployment会默认选择<code>RollingUpdate</code>作为其部署策略。目前Deployment支持两种部署策略：<code>RollingUpdate</code> 和 <code>Recreate</code>，可以通过<code>.spec.strategy.type</code>来选择部署策略。</p>
<p>Q: 当我们完成了一次更新后，旧的ReplicaSet <code>nginx-deployment-79fb9cc9bb</code>，为什么还会存在？</p>
<p>这取决于我们配置的清除策略，Deployment默认保留10个的ReplicaSet。我们可以通过<code>.spec.revisionHistoryLimit</code>字段来指定我希望保留ReplicaSet的数量。</p>
<h2 id="命令式管理Deployment"><a href="#命令式管理Deployment" class="headerlink" title="命令式管理Deployment"></a>命令式管理Deployment</h2><p><strong>不推荐使用命令式的方式去维护一个Kubernetes资源</strong>，其操作无法被版本化，无法存储到版本库中。因此下面的内容只是简单介绍。</p>
<h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><p>还可以通过命令式的方式去更新一个Deployment，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl set image deployment.v1.apps&#x2F;nginx-deployment nginx&#x3D;nginx:1.17 --record&#x3D;true</span><br></pre></td></tr></table></figure>
<p>使用<code>--record</code>可以把这次改动记录到资源上。</p>
<p>可以使用<code>kubectl rollout history</code>查看资源的历史版本。</p>
<p>再通过<code>kubectl rollout undo</code>将资源回滚到上一个版本或者指定版本。</p>
<h3 id="伸缩"><a href="#伸缩" class="headerlink" title="伸缩"></a>伸缩</h3><p>有两种伸缩机制：</p>
<p>第一种是比较简单扩展Pod的数量到指定的数量。比如将上面的3增加到10。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment.v1.apps&#x2F;nginx-deployment --replicas&#x3D;10</span><br></pre></td></tr></table></figure>

<p>还有一种就是自动伸缩，它可以根据一些指标来对Deployment进行动态的伸缩，比如根据CPU的使用率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl autoscale deployment.v1.apps&#x2F;nginx-deployment --min&#x3D;10 --max&#x3D;15 --cpu-percent&#x3D;80</span><br></pre></td></tr></table></figure>

<h2 id="删除一个Deployment"><a href="#删除一个Deployment" class="headerlink" title="删除一个Deployment"></a>删除一个Deployment</h2><p>执行删除命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete deployment nginx-deployment</span><br></pre></td></tr></table></figure>

<p>过程 &amp; 结果：</p>
<p><img src="delete.gif" alt="delete"></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>k8s</tag>
        <tag>Controller</tag>
        <tag>Deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>ReplicaSet</title>
    <url>/2020/02/11/replica-set/</url>
    <content><![CDATA[<p>在Kubernetes中，控制器是控制回路（在机器人技术和自动化领域，控制回路是一个非终止回路，用于调节系统状态），用于监视集群的状态，然后在需要时进行更改或请求更改。每一个控制器都会尝试将集群的状态调节至所期望的状态。</p>
<p>ReplicaSet是Kubernetes的一个控制器。在任何给定的时间，ReplicaSet都会维持一组稳定的Pod副本集。它通常用于保证指定数量的相同Pod的可用性。</p>
<p>ReplicaSets是ReplicationControllers的后继者。两者的作用相同，行为相似。不同之处在于，ReplicationController不支持基于集合的选择器。 因此，ReplicaSets优于ReplicationControllers</p>
<span id="more"></span>

<h2 id="如何创建一个ReplicaSet"><a href="#如何创建一个ReplicaSet" class="headerlink" title="如何创建一个ReplicaSet?"></a>如何创建一个ReplicaSet?</h2><p>下面展示的是一个ReplicaSet的manifest案例。案例的地址：<a href="https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/replica-set/web-server.yaml">https://raw.githubusercontent.com/chengqing-su/kubernetes-learning/master/replica-set/web-server.yaml</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 应该同时运行多少个pod，默认为1</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># label选择器</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># pod 模板</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span> <span class="comment"># 必须有label，并且这个label必须匹配 spec.selector，否则将会被API拒绝</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<p>执行下面命令可以创建一个ReplicaSet。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;replica-set&#x2F;web-server.yaml</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="example.png" alt="example"></p>
<h2 id="什么时候使用ReplicaSet"><a href="#什么时候使用ReplicaSet" class="headerlink" title="什么时候使用ReplicaSet?"></a>什么时候使用ReplicaSet?</h2><p>ReplicaSet确保在任何给定时间都运行指定数量的Pod副本。但是，Deployment 是一个更高级的概念，用于管理ReplicaSet，并提供了对Pod的声明性更新以及许多其他有用的功能。<strong>因此，除非需要自定义更新编排或完全不需要更新，否则建议使用Deployment而不是直接使用ReplicaSet。</strong></p>
<h2 id="ReplicaSet如何管理Pod？"><a href="#ReplicaSet如何管理Pod？" class="headerlink" title="ReplicaSet如何管理Pod？"></a>ReplicaSet如何管理Pod？</h2><p>ReplicaSet使用Pod模板去创建新的Pod。</p>
<p>所有被ReplicaSet管理的pod在都有一个<code>metedata.ownerReferences</code>字段，用来记录ReplicaSet的辨识信息。这就是从ReplicaSet指向其pod的链接，通过这个链接，ReplicaSet知道它所维护的Pod的状态，并据此做出相应的计划。上面的案例中，创建了一个名为<code>web-server</code>的ReplicaSet，下面展示的是由该ReplicaSet创建的一个Pod的<code>metadata</code>内容。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2020-02-11T13:52:23Z&quot;</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">web-server-</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-server-jqxfq</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">330e32af-f027-48f4-a3c0-f2f16a661d3d</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;1468260&quot;</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/pods/web-server-jqxfq</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">41fedd1a-1ed0-4fa6-a74a-fbbcb2ece16e</span></span><br></pre></td></tr></table></figure>

<h3 id="ReplicaSet通过它的选择器来识别要获取的新Pod"><a href="#ReplicaSet通过它的选择器来识别要获取的新Pod" class="headerlink" title="ReplicaSet通过它的选择器来识别要获取的新Pod"></a>ReplicaSet通过它的选择器来识别要获取的新Pod</h3><p>如果一个新Pod没有<code>ownerReferences</code>或者其<code>ownerReferences</code>指定的不是一个控制器，并且它能够匹配一个ReplicaSet的选择器，它就会立即被这个ReplicaSet获取。</p>
<p>先创建一个名为<code>nginx-pod</code>的Pod，这个Pod有一个<code>tier: nginx</code>的标签，其manifest如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;replica-set&#x2F;nginx-pod.yaml</span><br></pre></td></tr></table></figure>

<p>然后在创建上面案例中的<code>web-server</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;replica-set&#x2F;web-server.yaml</span><br></pre></td></tr></table></figure>
<p>其结果如下：<br><img src="example3.png" alt="example3"></p>
<p>删除这个ReplicaSet，之前创建的<code>nginx-pod</code>会被删掉吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete rs web-server</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="delete-rs.png" alt="delete-rs"></p>
<h3 id="如果-spec-selector相同，-spec-template-metadata-labels和-spec-template-spec不同"><a href="#如果-spec-selector相同，-spec-template-metadata-labels和-spec-template-spec不同" class="headerlink" title="如果.spec.selector相同，.spec.template.metadata.labels和.spec.template.spec不同"></a>如果<code>.spec.selector</code>相同，<code>.spec.template.metadata.labels</code>和<code>.spec.template.spec</code>不同</h3><p>上面的案例中，创建了一个名为<code>web-server</code>的ReplicaSet。接下来我们创建一个名为<code>web-server-2</code>的ReplicaSet，manifest如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-server-2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span> </span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<p>部署该manifest：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chengqing-su&#x2F;kubernetes-learning&#x2F;master&#x2F;replica-set&#x2F;web-server-2.yaml</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="example2.png" alt="example2"><br><strong>结论：</strong> 对于<code>.spec.selector</code>相同，<code>.spec.template.metadata.labels</code>和<code>.spec.template.spec</code>不同的2个ReplicaSet，每个ReplicaSet将忽略另一个ReplicaSet创建的Pod。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>k8s</tag>
        <tag>Controller</tag>
        <tag>ReplicaSet</tag>
      </tags>
  </entry>
  <entry>
    <title>Pod之容器探针</title>
    <url>/2020/02/01/pod-container-probe/</url>
    <content><![CDATA[<p>kubelet对容器执行的定期诊断。要执行诊断，kubelet需要调用由容器实现的Handler。</p>
<span id="more"></span>

<h2 id="Handler的类型"><a href="#Handler的类型" class="headerlink" title="Handler的类型"></a>Handler的类型</h2><ul>
<li>ExecAction: 在容器内执行指定的命令。 如果命令以状态代码0退出，则认为诊断成功。</li>
<li>TCPSocketAction: 根据指定端口上容器的IP地址执行TCP检查。 如果端口打开，则认为诊断成功。</li>
<li>HTTPGetAction: 针对指定端口和路径上容器的IP地址执行HTTP Get请求。如果响应的状态码大于或等于200且小于400，则认为诊断成功。</li>
</ul>
<h3 id="Handler的执行结果"><a href="#Handler的执行结果" class="headerlink" title="Handler的执行结果"></a>Handler的执行结果</h3><p>Handler的执行结果也就是探针的执行结果，有以下三种：</p>
<ul>
<li>Success: 容器通过了诊断。</li>
<li>Failure: 容器诊断失败。</li>
<li>Unknown: 诊断失败，所以不应该采取任何行动。</li>
</ul>
<h2 id="Probe的类型"><a href="#Probe的类型" class="headerlink" title="Probe的类型"></a>Probe的类型</h2><p>Probe总共有3种类型：</p>
<ul>
<li>livenessProbe: 指示容器是否正在运行。</li>
<li>readinessProbe：指示容器是否准备为请求提供服务。</li>
<li>startupProbe：指示容器内的应用程序是否已启动。</li>
</ul>
<h3 id="livenessProbe"><a href="#livenessProbe" class="headerlink" title="livenessProbe"></a>livenessProbe</h3><p>指示容器是否正在运行。如果探针的执行结果为<code>Failure</code>，kubectl将会杀死该容器，容器会根据配置的重启策略决定是否重启该容器。如果容器没有配置该探针，则默认为<code>Success</code>.</p>
<p>如果容器在遇到问题或变得不健康时能够自行崩溃，则不需要该探针。<br>如果希望在探测失败时杀死容器并重新启动,则需要配置该探针，并将<code>restartPolicy</code>配置为<code>Always</code> 或<code>OnFailure</code>。</p>
<h3 id="readinessProbe"><a href="#readinessProbe" class="headerlink" title="readinessProbe"></a>readinessProbe</h3><p>指示容器是否准备为请求提供服务。如果探针的执行结果为<code>Failure</code>，则端点控制器将从与Pod匹配的所有Service的端点中删除该Pod的IP地址。初始延迟之前的默认为<code>Failure</code>。如果容器没有配置该探针，则默认为<code>Success</code>.</p>
<p>在下列情况下，建议使用该探针。</p>
<ul>
<li>该探针执行成功后，Pod才开始接受流量。</li>
<li>在启动过程中，容器需要加载大型数据、配置文件或迁移。</li>
<li>希望容器能够自行下线进行维护</li>
</ul>
<p>如果只是想在删除Pod时耗尽请求，则不一定需要该探针；在删除的过程中，无论是否有该探针，Pod都会自动将自己置于未就绪状态。在等待容器被停止的过程中，Pod会保持未就绪状态。</p>
<h3 id="startupProbe"><a href="#startupProbe" class="headerlink" title="startupProbe"></a>startupProbe</h3><p><strong>该探针是Kubenetes 1.16新增的探针，目前依然处于<code>alpha</code>阶段。</strong></p>
<p>指示容器内的应用程序是否已启动。如果配置了该探针，该探针的执行结果为<code>Success</code>之前，其他探针都会被禁用。如果探针的执行结果为<code>Failure</code>，kubectl将会杀死该容器，容器会根据配置的重启策略决定是否重启该容器。如果容器没有配置该探针，则默认为<code>Success</code>.</p>
<p>如果容器的启动时间超过initialDelaySeconds + failureThreshold×periodSeconds，则需要配置该探针，该探针检查的终结点与livenessProbe一致。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在不同的重启策略下，<code>livenessProbe</code>和<code>readinessProbe</code>探针执行结果为<code>Success</code>和<code>Failure</code>的示例。</p>
<p>所有的manifests都在 <a href="https://github.com/chengqing-su/kubernetes-learning/tree/master/container-probes%E3%80%82">https://github.com/chengqing-su/kubernetes-learning/tree/master/container-probes。</a></p>
<h3 id="livenessProbe-1"><a href="#livenessProbe-1" class="headerlink" title="livenessProbe"></a>livenessProbe</h3><p><img src="liveness-probe-pods.png" alt="liveness-probe-pods"></p>
<h3 id="readinessProbe-1"><a href="#readinessProbe-1" class="headerlink" title="readinessProbe"></a>readinessProbe</h3><p><img src="readiness-probe-pods.png" alt="readiness-probe-pods"></p>
<p><img src="readiness-probe-failure-service.png" alt="readiness-probe-failure-service"></p>
<p><img src="readiness-probe-success-service.png" alt="readiness-probe-success-service"></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>k8s</tag>
        <tag>pod</tag>
      </tags>
  </entry>
  <entry>
    <title>初始化容器（Init Containers）</title>
    <url>/2020/01/24/pod-init-containers/</url>
    <content><![CDATA[<p>初始化容器（Init Containers）是Pod中在应用程序容器启动之前运行的专用容器。</p>
<p>一个Pod中可以用多个初始化容器。</p>
<span id="more"></span>

<h2 id="与正常的应用程序容器的区别"><a href="#与正常的应用程序容器的区别" class="headerlink" title="与正常的应用程序容器的区别"></a>与正常的应用程序容器的区别</h2><ul>
<li>正常的应用程序容器可以一直处于运行状态（Running），初始化容器必须要进入一个终结状态（Terminated）。</li>
<li>在一个Pod中可以有多个同时运行的应用程序容器，初始化容器必须按序执行，在下一个启动之前，上一个必须运行完成且成功</li>
<li>初始化容器不支持readiness探针，因为Pod就绪之前初始化容器必须运行完成。</li>
</ul>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>通过配置<code>PodSpec</code>中的<code>initContainers</code>来实现初始化容器。</p>
<p>下面是一个初始化容器的案例。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo The app is running! &amp;&amp; sleep 3600&#x27;</span>]</span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-myservice</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-mydb</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="初始化容器什么时候运行"><a href="#初始化容器什么时候运行" class="headerlink" title="初始化容器什么时候运行"></a>初始化容器什么时候运行</h2><ol>
<li>新建Pod的时候</li>
<li>Pod重启之后，所有的初始化容器都需要重新运行</li>
<li>改变Pod中的配置，导致初始化容器发生变化。改变初始化容器的image将会重启整个Pod， 应用程序image的改变仅仅重启应用程序容器</li>
<li>Pod基础设施容器重新启动。</li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>k8s</tag>
        <tag>pod</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS 数据传输费用怎么算？</title>
    <url>/2020/01/22/aws-data-transfer/</url>
    <content><![CDATA[<p>AWS的数据传输类型大致有如下三类：</p>
<ul>
<li>与Internet之间的数据传输</li>
<li>AWS内部跨区域的数据传输</li>
<li>AWS内部同一区域的数据传输</li>
</ul>
<p>本文将以ap-southeast-2区域中的EC2和S3为例。</p>
<span id="more"></span>
<h2 id="与Internet之间的数据传输费用计算"><a href="#与Internet之间的数据传输费用计算" class="headerlink" title="与Internet之间的数据传输费用计算"></a>与Internet之间的数据传输费用计算</h2><p>所有从Internet到AWS的流量是免费的，所有从AWS到Internet的流量是收费的。即对AWS服务而言，上行收费，下行免费。</p>
<p>针对上行流量，AWS根据不同的使用量采用不同的费率，下表中展示的是ap-southeast-2区域从AWS到Internet的数据传输费率。</p>
<table>
<thead>
<tr>
<th>Rate tiers</th>
<th>Pricing</th>
</tr>
</thead>
<tbody><tr>
<td>Up to 1 GB / Month</td>
<td>$0.00 per GB</td>
</tr>
<tr>
<td>Next 9.999 TB / Month</td>
<td>$0.114 per GB</td>
</tr>
<tr>
<td>Next 40 TB / Month</td>
<td>$0.098 per GB</td>
</tr>
<tr>
<td>Next 100 TB / Month</td>
<td>$0.094 per GB</td>
</tr>
<tr>
<td>Greater than 150 TB / Month</td>
<td>$0.092 per GB</td>
</tr>
</tbody></table>
<p>那么问题来了，在这一个月中S3和EC2均产生了1GB到Internet的上行流量，AWS应该收我多少钱？$0? 不是的，会产生 $0.114 费用。</p>
<p><strong>为啥？</strong></p>
<p>AWS会根据从AWS服务传输到Internet的数据总量计算数据传输费率。具体而言，AWS会将从Amazon EC2, Amazon S3, Amazon Glacier, Amazon RDS, Amazon Redshift, Amazon SES, Amazon SimpleDB, Amazon SQS, Amazon SNS, Amazon DynamoDB, AWS Storage Gateway, 和 Amazon CloudWatch Logs到Internet的流量进行合并计算数据传输费率。</p>
<p>比如，我们只使用了EC2和S3服务，在本月我们已经使用了10TB，那么接下来EC2或者S3到Internet的费用到会按照$0.098/GB收费，知道使用到下一个费率标准。</p>
<p>简单说，下行免费，上行收费，费率算总量。</p>
<h2 id="跨区域的数据传输费用计算"><a href="#跨区域的数据传输费用计算" class="headerlink" title="跨区域的数据传输费用计算"></a>跨区域的数据传输费用计算</h2><p>不同区域对跨区域数据传输的费率是不一样的。对于上行的数据传输会按照费率收取费用，对于下行的数据传输不收费。</p>
<p>比如现在有2台EC2实例A和B，A在悉尼(ap-southeast-2)，B在新加坡(ap-southeast-1)。这两台实例之间如何收取数据传输费用？</p>
<p>已知从悉尼ap-southeast-2到其他区域的数据传输费用为 $0.14/GB，从新加坡ap-southeast-1到其他区域的数据传输费用为 $0.09/GB</p>
<p>则从A给B传输1GB的数据，A需要付出数据传输费用 $0.14，B不需要付费。从B给A传输1GB的数据，A不需要付费，B需要付费 $0.09。</p>
<p>下行免费，上行收费，费率分区域。</p>
<h2 id="到CloudFront的数据传输费用计算"><a href="#到CloudFront的数据传输费用计算" class="headerlink" title="到CloudFront的数据传输费用计算"></a>到CloudFront的数据传输费用计算</h2><p>无论EC2还是S3到CloudFront的数据传输都是免费的。</p>
<h2 id="同一区域内的数据传输费用计算"><a href="#同一区域内的数据传输费用计算" class="headerlink" title="同一区域内的数据传输费用计算"></a>同一区域内的数据传输费用计算</h2><h3 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h3><p>S3 bucket之间在同一区域进行数据传输不收费。</p>
<p>S3和其他AWS服务在同一区域进行数据传输不收费。比如EC2和S3之间传输数据是免费的。</p>
<h3 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h3><ul>
<li>Amazon EC2，Amazon RDS，Amazon Redshift，Amazon DynamoDB Accelerator（DAX），Amazon ElastiCach 和 Elastic Network Interfaces进行跨可用区或使用VPC对等连接传输数据，上下行都需要收费，$0.01/GB</li>
</ul>
<p>比如在可用区A中有1台EC2 EC2-A，在可用区B中有1台EC EC2-B。当EC2-A向EC2-B传输1G数据，EC2-A需要支付 $0.01 上行数据传输费用，EC2-B需要支付 $0.01 下行数据传输费用。总共需要 $0.02 数据传输费用。</p>
<ul>
<li>同一个区域内，使用公网IPv4或者弹性IPv4地址传输数据，上下行都需要收费，$0.01/GB。</li>
</ul>
<p>比如在可用区A中有两台EC2 EC2-A和EC2-B，它们之间使用公网IP传输数据是需要收费的，假如EC2-A向EC2-B发送1GB的数据，EC2-A需要支付 $0.01 上行数据传输费用，EC2-B需要支付 $0.01 下行数据传输费用。总共需要 $0.02 数据传输费用。</p>
<p>Q: 跨可用区使用Public IP传输数据如何收费？<br>跨区域使用Public IP或者EIP传输数据只会收一次费用。<br>比如在可用区A中有1台EC2 EC2-A，在可用区B中有1台EC EC2-B。当EC2-A通过EIP向EC2-B传输1G数据，EC2-A需要支付 $0.01 上行数据传输费用，EC2-B需要支付 $0.01 下行数据传输费用。总共需要 $0.02 数据传输费用。</p>
<ul>
<li><p>同一个区域内，使用IPv6跨VPC传输数据，上下行都需要收费，$0.01/GB。</p>
</li>
<li><p>同一个可用区内Amazon EC2, Amazon RDS, Amazon Redshift, Amazon ElastiCache instances 和 Elastic Network Interfaces 之间传输数据免费。如果使用VPC对等连接，则需要按照VPC对等连接的费率收费。</p>
</li>
</ul>
<p>比如在可用区A中有两台EC2 EC2-A和EC2-B，它们之间使用私有IP传输数据是免费的。</p>
<ul>
<li><p>在同一区域中内 Amazon S3、Amazon Glacier、Amazon DynamoDB、Amazon SES、Amazon SQS、Amazon Kinesis、Amazon ECR、Amazon SNS、Amazon SimpleDB 和 Amazon EC2 实例之间传输数据是免费的。通过PrivateLink终端节点访问的AWS服务将产生标准PrivateLink费用。</p>
</li>
<li><p>使用私有 IP 地址从 Amazon Classic Elastic Load Balancer 和 Amazon Application Elastic Load Balancer与EC2 实例之间传输数据是免费的。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="EC2-1"><a href="#EC2-1" class="headerlink" title="EC2"></a>EC2</h3><p><img src="ec2.png" alt="ec2"></p>
<h3 id="S3-1"><a href="#S3-1" class="headerlink" title="S3"></a>S3</h3><p><img src="s3.png" alt="s3"></p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
        <category>Public Cloud Provider</category>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>aws</tag>
        <tag>data transfer</tag>
        <tag>ec2</tag>
        <tag>s3</tag>
      </tags>
  </entry>
  <entry>
    <title>Pod的生命周期</title>
    <url>/2020/01/20/pod-lifecycle/</url>
    <content><![CDATA[<p>kubelet 接受通过各种机制（主要是通过 apiserver）提供的一组 PodSpec，并确保这些 PodSpec 中描述的容器处于良好的运行状态。</p>
<p>在本文中主要介绍在Kubernetes中容器的状态，Pod阶段以及两者之间的关系。</p>
<span id="more"></span>

<h2 id="容器的状态"><a href="#容器的状态" class="headerlink" title="容器的状态"></a>容器的状态</h2><p>容器有3个状态: <strong>Waiting, Running and Terminated</strong></p>
<table>
<thead>
<tr>
<th>State</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Waiting</td>
<td>该状态是容器的默认状态。如果容器的状态不是Running或者Terminated，那么一定就是Waiting状态。为了提供更多的信息，与该状态一起显示的还有出现该状态的原因以及相关信息。</td>
</tr>
<tr>
<td>Running</td>
<td>如果容器的状态是Running，则说明容器正常运行且没有任何异常。一旦容器进入Running状态，如果存在<code>postStart</code>钩子（hook），则执行这个钩子。与该状态一起出现的还有容器进入该状态的时间。</td>
</tr>
<tr>
<td>Terminated</td>
<td>当容器中的任务已经执行完成且容器已经停止运行。在容器退出前，如果存在<code>preStop</code>钩子，则先执行该钩子。与该状态一起出现的还有出现该状态的原因以及退出码。</td>
</tr>
</tbody></table>
<h2 id="Pod的阶段（phase）"><a href="#Pod的阶段（phase）" class="headerlink" title="Pod的阶段（phase）"></a>Pod的阶段（phase）</h2><p>Pod的阶段是Pod在其生命周期中所处位置的简单概括。</p>
<p>Pod阶段的含义以及数量是受到严格保护的。目前总共有5个阶段，如下所示。</p>
<table>
<thead>
<tr>
<th>Phase</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>挂起（Pending）</td>
<td>Pod 已被 Kubernetes 系统接受，但<strong>有一个或者多个容器镜像尚未创建</strong>。等待时间包括调度 Pod 的时间和通过网络下载镜像的时间，这可能需要花点时间。</td>
</tr>
<tr>
<td>运行中（Running）</td>
<td>该 Pod 已经绑定到了一个节点上，Pod 中<strong>所有的容器都已被创建，且至少有一个容器正在运行或者正处于启动或重启状态。</strong></td>
</tr>
<tr>
<td>成功（Succeeded）</td>
<td>Pod 中的<strong>所有容器都被成功终止，并且不会再重启。</strong></td>
</tr>
<tr>
<td>失败（Failed）</td>
<td>Pod 中的<strong>所有容器都已终止了，并且至少有一个容器是因为失败终止</strong>。也就是说，容器以非0状态退出或者被系统终止。</td>
</tr>
<tr>
<td>未知（Unknown）</td>
<td>因为某些原因<strong>无法取得 Pod 的状态</strong>，通常是因为与 Pod 所在主机通信失败。</td>
</tr>
</tbody></table>
<h2 id="容器的状态与Pod阶段之间的关系"><a href="#容器的状态与Pod阶段之间的关系" class="headerlink" title="容器的状态与Pod阶段之间的关系"></a>容器的状态与Pod阶段之间的关系</h2><p>下面通过一个例子来讲述容器和Pod以及Pod重启策略之间的关系。前两列是一个Pod中两个容器的状态，后面三列是Pod的restartPolicy为None，Always，OnFailure时的状态。</p>
<table>
<thead>
<tr>
<th>Container   A</th>
<th>Container B</th>
<th>None</th>
<th>Always</th>
<th>OnFailure</th>
</tr>
</thead>
<tbody><tr>
<td>Waiting</td>
<td>Waiting</td>
<td>Pending</td>
<td>Pending</td>
<td>Pending</td>
</tr>
<tr>
<td>Waiting</td>
<td>Running</td>
<td>Pending</td>
<td>Pending</td>
<td>Pending</td>
</tr>
<tr>
<td>Waiting</td>
<td>Non-zero terminated</td>
<td>Pending</td>
<td>Pending</td>
<td>Pending</td>
</tr>
<tr>
<td>Waiting</td>
<td>Zero terminated</td>
<td>Pending</td>
<td>Pending</td>
<td>Pending</td>
</tr>
<tr>
<td>Running</td>
<td>Running</td>
<td>Running</td>
<td>Running</td>
<td>Running</td>
</tr>
<tr>
<td>Running</td>
<td>Non-zero terminated</td>
<td>Running</td>
<td>Running</td>
<td>Running</td>
</tr>
<tr>
<td>Running</td>
<td>Zero terminated</td>
<td>Running</td>
<td>Running</td>
<td>Running</td>
</tr>
<tr>
<td>Non-zero terminated</td>
<td>Non-zero terminated</td>
<td>Failed</td>
<td>Running</td>
<td>Running</td>
</tr>
<tr>
<td>Non-zero terminated</td>
<td>Zero terminated</td>
<td>Failed</td>
<td>Running</td>
<td>Running</td>
</tr>
<tr>
<td>Zero terminated</td>
<td>Zero terminated</td>
<td>Succeeded</td>
<td>Running</td>
<td>Succeeded</td>
</tr>
</tbody></table>
<p>这是我用来测试的manifest，如果有兴趣可以自己动手做一做。<a href="https://github.com/chengqing-su/kubernetes-learning/tree/master/pod-lifecycle">https://github.com/chengqing-su/kubernetes-learning/tree/master/pod-lifecycle</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>k8s</tag>
        <tag>pod</tag>
        <tag>pod lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title>Pod介绍</title>
    <url>/2020/01/15/pod-overview/</url>
    <content><![CDATA[<p>Pod 是啥？ Pod是豆荚，这是一个很形象的名字。在一个豆荚中，通常都会有一个或者多个豆子，这些豆子就像是Pod中运行着的容器。</p>
<span id="more"></span>
<h2 id="Pod-是什么？"><a href="#Pod-是什么？" class="headerlink" title="Pod 是什么？"></a>Pod 是什么？</h2><p>Pod 是Kubernetes基本的执行单元，是我们可以创建、部署的最小最简单的单元。</p>
<h3 id="Pod-中有什么？"><a href="#Pod-中有什么？" class="headerlink" title="Pod 中有什么？"></a>Pod 中有什么？</h3><ul>
<li>一个或者多个应用程序容器。</li>
<li>存储资源。</li>
<li>网络资源。</li>
<li>应用程序容器的运行策略配置。</li>
</ul>
<h3 id="Manifest-Example"><a href="#Manifest-Example" class="headerlink" title="Manifest Example"></a>Manifest Example</h3><p>这是一个很简单的Pod的manifest，在Pod中运行了nginx的容器。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<h3 id="Pod中容器之间的关系"><a href="#Pod中容器之间的关系" class="headerlink" title="Pod中容器之间的关系"></a>Pod中容器之间的关系</h3><p>下面这个Pod的manifest中包含了3个容器。可以使用<code>kubectl apply</code>的方式将该Pod部署到Kubernetes上。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">validate-network</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;telnet localhost 80 &amp;&amp; echo nginx works &amp;&amp; sleep 3600&#x27;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">validate-volumes</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;tail -f /logs/*.log&#x27;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-共享网络IP地址和端口"><a href="#1-共享网络IP地址和端口" class="headerlink" title="1. 共享网络IP地址和端口"></a>1. 共享网络IP地址和端口</h4><p>容器之间可以使用<code>localhost</code>通信。在一个Pod中多个容器不能使用同一个端口。</p>
<p>在上面的例子中，<code>nginx</code>容器启动之后会默认占用80端口。在<code>validate-network</code>容器中执行了<code>telnet localhost 80</code>，结果如下。</p>
<p><img src="validate-network.png" alt="validate-network"></p>
<h4 id="2-共享存储资源"><a href="#2-共享存储资源" class="headerlink" title="2. 共享存储资源"></a>2. 共享存储资源</h4><p>Pod可以指定一组共享存储卷。 Pod中的所有容器都可以访问共享卷，从而使这些容器可以共享数据。</p>
<p>在上面的例子中，<code>nginx</code>和<code>validate-volumes</code>容器共同使用了<code>logs</code>这个共享存储卷。<code>nginx</code>容器会将日志输出到该存储卷中，<code>validate-volumes</code>容器会把<code>nginx</code>的日志读取出来。</p>
<p><img src="validate-volumes.png" alt="validate-volumes"></p>
<h4 id="3-紧耦合的"><a href="#3-紧耦合的" class="headerlink" title="3. 紧耦合的"></a>3. 紧耦合的</h4><h2 id="如何使用Pod？"><a href="#如何使用Pod？" class="headerlink" title="如何使用Pod？"></a>如何使用Pod？</h2><p><strong>Pod被设计为相对短暂的（非持久的）一次性的实体。</strong> 因此不推荐在Kubernetes中直接创建Pod。比如，一个Pod被创建之后，由于资源不足被驱逐或者运行这个Pod的节点挂了，Pod是无法自我恢复的。</p>
<p>在Kubernetes中有一个更高层次的抽象来负责管理Pod，Controller。比如Deployment、ReplicaSets，DaemonSet。在这些Controller中，会使用Pod模板管理Pod，下面是一个ReplicaSets的例子。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">rs-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> </span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">template:</span> </span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>k8s</tag>
        <tag>pod</tag>
      </tags>
  </entry>
  <entry>
    <title>Amazon ECS 滚动更新部署</title>
    <url>/2020/01/14/aws-ecs-rolling-deployment/</url>
    <content><![CDATA[<p>滚动更新部署是由Amazon ECS控制的，服务调度程序会将容器的当前运行版本替换为所指定的版本（可以是新版本，也可以是更旧的版本）。</p>
<p>在滚动更新期间，Amazon ECS在服务中添加或从服务中删除的任务数由<strong>部署配置(DeploymentConfiguration)</strong> 控制。</p>
<p><strong>部署配置(DeploymentConfiguration)</strong> 由服务部署期间允许的最小和最大任务数组成。</p>
<span id="more"></span>
<h2 id="部署配置-DeploymentConfiguration-？"><a href="#部署配置-DeploymentConfiguration-？" class="headerlink" title="部署配置(DeploymentConfiguration)？"></a>部署配置(DeploymentConfiguration)？</h2><h3 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h3><p>DeploymentConfiguration 是AWS ECS中一个服务(Service)的属性。<br>该属性指定可选的部署参数，这些参数控制部署期间运行的任务数以及停止和启动任务的顺序。</p>
<p>DeploymentConfiguration含有2个属性：<code>MaximumPercent</code>和<br><code>MinimumHealthyPercent</code>。</p>
<h3 id="MaximumPercent"><a href="#MaximumPercent" class="headerlink" title="MaximumPercent"></a>MaximumPercent</h3><p>MaximumPercent以期望的Task数量的百分比形式表示部署批次大小，即在部署过程中RUNNING 或 PENDING 状态的Task的数量上限（向下取整）。如果使用了EC2启动类型，且Task中存在DRAINING状态的容器也会占用上限。</p>
<p>最大百分比的默认值为 200%。</p>
<h3 id="MinimumHealthyPercent"><a href="#MinimumHealthyPercent" class="headerlink" title="MinimumHealthyPercent"></a>MinimumHealthyPercent</h3><p>MinimumHealthyPercent以期望的Task数量的百分比形式表示部署期间必须保持 RUNNING 状态的Task的数量下限（向上取整）。如果使用了EC2启动类型，且Task中存在DRAINING状态的容器也会占用下限。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现有一个Service，其所期望的Task数量为4。当前运行版本为Version A，将更新到的版本为Version B.</p>
<h4 id="MaximumPercent-200-MinimumHealthyPercent-100"><a href="#MaximumPercent-200-MinimumHealthyPercent-100" class="headerlink" title="MaximumPercent=200, MinimumHealthyPercent=100"></a>MaximumPercent=200, MinimumHealthyPercent=100</h4><p>在部署期间，Task数量的上限为8(⌊4*200%⌋)，下限为4(⌈4*100%⌉)</p>
<p><img src="deployment-200-100.gif" alt="deployment-200-100.gif"></p>
<h4 id="MaximumPercent-100-MinimumHealthyPercent-75"><a href="#MaximumPercent-100-MinimumHealthyPercent-75" class="headerlink" title="MaximumPercent=100, MinimumHealthyPercent=75"></a>MaximumPercent=100, MinimumHealthyPercent=75</h4><p>在部署期间，Task数量的上限为4(⌊4*100%⌋)，下限为3(⌈4*75%⌉)</p>
<p><img src="deployment-100-75.gif" alt="deployment-100-75.gif"></p>
<h4 id="MaximumPercent-121-MinimumHealthyPercent-74"><a href="#MaximumPercent-121-MinimumHealthyPercent-74" class="headerlink" title="MaximumPercent=121, MinimumHealthyPercent=74"></a>MaximumPercent=121, MinimumHealthyPercent=74</h4><p>在部署期间，Task数量的上限为4(⌊4*121%⌋)，下限为3(⌈4*74%⌉)</p>
<p><img src="deployment-121-74.gif" alt="deployment-121-74.gif"></p>
<h4 id="MaximumPercent-100-MinimumHealthyPercent-0"><a href="#MaximumPercent-100-MinimumHealthyPercent-0" class="headerlink" title="MaximumPercent=100, MinimumHealthyPercent=0"></a>MaximumPercent=100, MinimumHealthyPercent=0</h4><p>在部署期间，Task数量的上限为4(⌊4*100%⌋)，下限为0(⌈4*0%⌉)</p>
<p><img src="deployment-100-0.gif" alt="deployment-100-0.gif"></p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
        <category>Public Cloud Provider</category>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>aws</tag>
        <tag>ecs</tag>
        <tag>deployment</tag>
        <tag>rolling upate</tag>
      </tags>
  </entry>
  <entry>
    <title>收获满满的2019， 可期的2020</title>
    <url>/2019/12/31/2019to2020/</url>
    <content><![CDATA[<p>2019，和某位恋爱达成5年新成就。回了趟老家，去了趟兰州，爬了一次华山（上下缆车，走完5个峰）。<br>2020，再接再厉。打卡集齐东3省。</p>
<p>2019，去电影院看了12部电影。我居然把最脑残的《雷霆沙赞》看完了。还有《流浪地球》、《飞驰人生》、《神探蒲松龄》、《阿丽塔：战斗天使》、《惊奇队长》、《复仇者联盟4:终局之战》、《黑衣人：全球追缉》、《蜘蛛侠：英雄远征》、《银河补习班》、《哪吒：魔童降世》、《攀登者》。<br>2020，我也不会知道会去看几部，有值得看的就去看。</p>
<span id="more"></span>

<p>2019，阅读时长超过500+小时，《微信读书》267小时，《QQ阅读》起码也有250小时。最喜欢的一本小说是宅猪的《牧神记》，把改革变法和阶级斗争以玄幻小说的形式写出来。<br>2020，追宅猪的《临渊行》。</p>
<p>2019，追剧应该有10部。最近刚追完《庆余年》。<br>2020，随缘吧。有几部一直很期待的剧，《白夜追凶2》、《余罪》等</p>
<p>2019，看完社科类书籍0本。虽然每次都很冲动地卖了社科类的书籍，但是就是看不下去，不是书太厚就是书太枯燥。<br>2020，争取把《中国乡村》看完。</p>
<p>2019，学了2门新的编程语言。一门目前JavaScript最流行的方言Typescript,一门及其灵活的OO语言Ruby.<br>2020，Multi-Cloud和Kubernetes是自己目前的方向，学一下Golang。</p>
<p>2019，考了2个证。一个是读题读到哭的AWS Certified Solutions Architect Associate，一个是找文档找到死的Certified Kubernetes Administrator。<br>2020，有2个证在计划中，AWS Certified Solutions Architect - Professional和Microsoft Certified Azure Administrator。</p>
<p>2019，读技术类书籍10本。《Linux命令行与shell脚本编程大全》、《Clean Code》、《重构》、《Ruby元编程》、《Git版本控制》、《Learning Typescript》、《云原生应用》、《敏捷软件开发 原则、模式与实践》、《Kubernetes权威指南》、《基于Kubernetes的容器云平台实践》.<br>2020，主要会读一些Java编程、Multi-Cloud、DevOps相关的书籍。</p>
<p>2019，尝试过用Jira管理自己的学习计划。实践失败，太重了。<br>2020，使用Trello来管理自己的读书和学习计划。</p>
<p>2019，学了TDD，真香。</p>
<p>2019，入了DevOps的坑，真香。<br>2020，学习更多的DevOps工具。</p>
<p>2019，坚持了写博客的没多久就放弃了。<br>2020，每周能够输出1篇博客。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>2020</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>KVM 实践</title>
    <url>/2019/11/07/kvm-practice/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>KVM 是目前硬件虚拟化中应用较为广泛的技术。在本文中将介绍KVM 环境搭建，KVM 虚拟机操作以及利用libvirt进行Java编程等。</p>
<p>操作系统：CentOS 7(1804)</p>
<p>CPU: 2</p>
<p>内存：2G</p>
<p>ISO镜像: <a href="http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso">http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso</a></p>
<span id="more"></span>

<h2 id="KVM-环境搭建"><a href="#KVM-环境搭建" class="headerlink" title="KVM 环境搭建"></a>KVM 环境搭建</h2><p>KVM 环境搭建可以分为四步。</p>
<h3 id="第一步：查看CPU是否支持虚拟化"><a href="#第一步：查看CPU是否支持虚拟化" class="headerlink" title="第一步：查看CPU是否支持虚拟化"></a>第一步：查看CPU是否支持虚拟化</h3><p>KVM硬件虚拟化技术是全虚拟化，需要硬件的支持。因此在搭建KVM环境之前需要先确认CPU是否支持虚拟化。<br><strong>命令：</strong><br><code>grep -E &quot;(vmx|svm)&quot; /proc/cpuinfo</code><br><strong>结果：</strong></p>
<p><img src="image-20181119111100651.png"></p>
<p><strong>说明：</strong></p>
<ul>
<li>/proc : proc文件系统，一种伪文件系统，存储的是当前内核运行状态的一系列特殊文件。用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</li>
<li>/proc/cpuinfo： CPU相关信息。</li>
<li>vmx: Intel 虚拟化技术</li>
<li>svm: AMD 虚拟化技术</li>
</ul>
<h3 id="第二步：安装KVM相关组件"><a href="#第二步：安装KVM相关组件" class="headerlink" title="第二步：安装KVM相关组件"></a>第二步：安装KVM相关组件</h3><p><strong>命令：</strong><br><code>yum -y install qemu-kvm qemu-kvm-tools virt-manager virt-install libvirt </code><br><strong>说明：</strong></p>
<ul>
<li>qemu-kvm:  用户态管理KVM，网卡、声卡、PCI设备等的管理.</li>
<li>qemu-kvm-tools:  KVM调试和诊断工具</li>
<li>virt-manager: 可选。通过libvirt管理虚拟机的桌面工具。</li>
<li>virt-install: 安装虚拟机的工具。</li>
<li>libvirt: 一种实现Linux 虚拟化功能的Linux API，它支持各种Hypervisor，包括Xen 和KVM，以及QEMU 和用于其他操作系统的一些虚拟产品。</li>
</ul>
<h3 id="第三步：查看KVM是否加载成功"><a href="#第三步：查看KVM是否加载成功" class="headerlink" title="第三步：查看KVM是否加载成功"></a>第三步：查看KVM是否加载成功</h3><p><strong>命令：</strong><br><code>lsmod | grep kvm</code><br><strong>结果：</strong></p>
<p><img src="image-20181119111218567.png"></p>
<p><strong>说明：</strong></p>
<ul>
<li>lsmod: 用于显示已经加载到内核中的模块的状态信息。</li>
</ul>
<h3 id="第四步：启动libvirtd"><a href="#第四步：启动libvirtd" class="headerlink" title="第四步：启动libvirtd"></a>第四步：启动libvirtd</h3><p><strong>命令：</strong><br><code>systemctl start libvirtd</code><br><code>systemctl staus libvirtd</code><br><code>systemctl enable libvirtd</code><br><strong>结果：</strong></p>
<p><img src="image-20181119121304479.png"></p>
<p><strong>说明：</strong></p>
<ul>
<li>systemctl: 一个systemd工具，主要负责控制systemd系统和服务管理器</li>
</ul>
<h2 id="虚拟机操作"><a href="#虚拟机操作" class="headerlink" title="虚拟机操作"></a>虚拟机操作</h2><h3 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h3><h4 id="第一步：创建磁盘"><a href="#第一步：创建磁盘" class="headerlink" title="第一步：创建磁盘"></a>第一步：创建磁盘</h4><p><strong>命令：</strong><br><code>qemu-img create -f qcow2 /opt/test.qcow 10G</code><br><strong>结果：</strong></p>
<p><img src="image-20181119122831031.png"></p>
<p><strong>说明：</strong></p>
<ul>
<li>qemu-img: 是QEMU的磁盘管理工具。</li>
<li>qemu-img create [-f fmt][-o options] filename [size] : <ul>
<li>-f 指定磁盘格式，</li>
<li>-o 其他可选项，</li>
<li>filename 磁盘文件名称</li>
<li>size 磁盘大小</li>
</ul>
</li>
</ul>
<h4 id="第二步：创建虚拟机"><a href="#第二步：创建虚拟机" class="headerlink" title="第二步：创建虚拟机"></a>第二步：创建虚拟机</h4><p><strong>命令：</strong><br><code>virt-install --name CentOS-7.5-x86_64 --virt-type kvm --ram 1024 --cdrom=/root/CentOS-7-x86_64-Minimal-1804.iso --disk path=/opt/test.qcow --network network=default --graphics vnc,listen=0.0.0.0</code><br><strong>结果：</strong></p>
<p><img src="image-20181119124538122.png"></p>
<p><strong>说明：</strong></p>
<ul>
<li>–name: 虚拟机名称</li>
<li>–virt-type 虚拟类型</li>
<li>–ram 内存</li>
<li>–cdrom 系统安装镜像</li>
<li>–disk 系统磁盘</li>
<li>–network 网络相关配置</li>
<li>–graphics 配置客户机图形化</li>
</ul>
<h4 id="第三步：查看虚拟机状态-可选"><a href="#第三步：查看虚拟机状态-可选" class="headerlink" title="第三步：查看虚拟机状态(可选)"></a>第三步：查看虚拟机状态(可选)</h4><p><strong>命令：</strong><br><code>virsh list --all</code><br><strong>结果：</strong><br><img src="image-20181119125214344.png"></p>
<h4 id="第四步：远程虚拟机-可选"><a href="#第四步：远程虚拟机-可选" class="headerlink" title="第四步：远程虚拟机(可选)"></a>第四步：远程虚拟机(可选)</h4><p><img src="image-20181119125321280.png"></p>
<p><strong>说明：</strong></p>
<p>通过VNC客户端连接宿主机的IP和端口访问虚拟机。</p>
<h3 id="虚拟机相关操作"><a href="#虚拟机相关操作" class="headerlink" title="虚拟机相关操作"></a>虚拟机相关操作</h3><p><strong>常见命令：</strong></p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">virsh list [–all]</td>
<td align="left">查看虚拟机和状态。不加 –all 只显示活动的虚拟机。</td>
</tr>
<tr>
<td align="left">virsh start  [Name]</td>
<td align="left">启动名称为Name虚拟机。</td>
</tr>
<tr>
<td align="left">virsh reboot [Id/Name]</td>
<td align="left">根据虚拟机的id或者name重启虚拟机。</td>
</tr>
<tr>
<td align="left">virsh suspend [Id/Name]</td>
<td align="left">根据虚拟机的id或者name挂起虚拟机。</td>
</tr>
<tr>
<td align="left">virsh resume [Id/Name]</td>
<td align="left">根据虚拟机的id或者name把虚拟机唤醒，使其恢复到running状态</td>
</tr>
<tr>
<td align="left">virsh shutdown [Id/Name]</td>
<td align="left">根据虚拟机的id或者name关闭虚拟机</td>
</tr>
<tr>
<td align="left">virsh destroy [Id/Name]</td>
<td align="left">强制关闭该虚拟机。</td>
</tr>
<tr>
<td align="left">virsh undefine [Id/Name]</td>
<td align="left">根据虚拟机的id或者name移除虚拟机</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<p><img src="image-20181119141935635.png"></p>
<h3 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h3><p><strong>命令：</strong></p>
<p><code>virt-clone -o CentOS-7.5-x86_64 --auto-clone</code></p>
<p><strong>结果：</strong></p>
<p><img src="image-20181119144413516.png"></p>
]]></content>
      <categories>
        <category>Cloud Computing</category>
        <category>Virtualization</category>
      </categories>
      <tags>
        <tag>kvm</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
</search>
